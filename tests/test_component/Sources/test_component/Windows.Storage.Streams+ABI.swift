// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
import Ctest_component

private var IID___x_ABI_CWindows_CStorage_CStreams_CIBuffer: test_component.IID {
    .init(Data1: 0x905A0FE0, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ))// 905A0FE0-BC53-11DF-8C49-001E4FC686DA
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIBufferFactory: test_component.IID {
    .init(Data1: 0x71AF914D, Data2: 0xC10F, Data3: 0x484B, Data4: ( 0xBC,0x50,0x14,0xBC,0x62,0x3B,0x3A,0x27 ))// 71AF914D-C10F-484B-BC50-14BC623B3A27
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIBufferStatics: test_component.IID {
    .init(Data1: 0xE901E65B, Data2: 0xD716, Data3: 0x475A, Data4: ( 0xA9,0x0A,0xAF,0x72,0x29,0xB1,0xE7,0x41 ))// E901E65B-D716-475A-A90A-AF7229B1E741
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider: test_component.IID {
    .init(Data1: 0x97D098A5, Data2: 0x3B99, Data3: 0x4DE9, Data4: ( 0x88,0xA5,0xE1,0x1D,0x2F,0x50,0xC7,0x95 ))// 97D098A5-3B99-4DE9-88A5-E11D2F50C795
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIInputStream: test_component.IID {
    .init(Data1: 0x905A0FE2, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ))// 905A0FE2-BC53-11DF-8C49-001E4FC686DA
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference: test_component.IID {
    .init(Data1: 0x43929D18, Data2: 0x5EC9, Data3: 0x4B5A, Data4: ( 0x91,0x9C,0x42,0x05,0xB0,0xC8,0x04,0xB6 ))// 43929D18-5EC9-4B5A-919C-4205B0C804B6
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIOutputStream: test_component.IID {
    .init(Data1: 0x905A0FE6, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ))// 905A0FE6-BC53-11DF-8C49-001E4FC686DA
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream: test_component.IID {
    .init(Data1: 0x905A0FE1, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ))// 905A0FE1-BC53-11DF-8C49-001E4FC686DA
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference: test_component.IID {
    .init(Data1: 0x33EE3134, Data2: 0x1DD6, Data3: 0x4E3A, Data4: ( 0x80,0x67,0xD1,0xC1,0x62,0xE8,0x64,0x2B ))// 33EE3134-1DD6-4E3A-8067-D1C162E8642B
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType: test_component.IID {
    .init(Data1: 0xCC254827, Data2: 0x4B3D, Data3: 0x438F, Data4: ( 0x92,0x32,0x10,0xC7,0x6B,0xC7,0xE0,0x38 ))// CC254827-4B3D-438F-9232-10C76BC7E038
}

public enum __ABI_Windows_Storage_Streams {
    public class IBuffer: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIBuffer }

        open func get_CapacityImpl() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Capacity(pThis, &value))
            }
            return value
        }

        open func get_LengthImpl() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Length(pThis, &value))
            }
            return value
        }

        open func put_LengthImpl(_ value: UInt32) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_Length(pThis, value))
            }
        }

    }

    internal static var IBufferVTable: __x_ABI_CWindows_CStorage_CStreams_CIBufferVtbl = .init(
        QueryInterface: { IBufferWrapper.queryInterface($0, $1, $2) },
        AddRef: { IBufferWrapper.addRef($0) },
        Release: { IBufferWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IBufferWrapper.IID
            iids[3] = __ABI_.IBufferByteAccessWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IBuffer").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Capacity: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.capacity
            $1?.initialize(to: value)
            return S_OK
        },

        get_Length: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.length
            $1?.initialize(to: value)
            return S_OK
        },

        put_Length: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UInt32 = $1
            __unwrapped__instance.length = value
            return S_OK
        }
    )

    public typealias IBufferWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IBufferBridge>
    public class IBufferFactory: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIBufferFactory }

        internal func CreateImpl(_ capacity: UInt32) throws -> IBuffer {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBufferFactory.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.Create(pThis, capacity, &valueAbi))
                }
            }
            return IBuffer(value!)
        }

    }

    public class IBufferStatics: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIBufferStatics }

        internal func CreateCopyFromMemoryBufferImpl(_ input: test_component.AnyIMemoryBuffer?) throws -> test_component.Buffer? {
            let (value) = try ComPtrs.initialize { valueAbi in
                let inputWrapper = __ABI_Windows_Foundation.IMemoryBufferWrapper(input)
                let _input = try! inputWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBufferStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateCopyFromMemoryBuffer(pThis, _input, &valueAbi))
                }
            }
            return .from(abi: value)
        }

        internal func CreateMemoryBufferOverIBufferImpl(_ input: test_component.AnyIBuffer?) throws -> test_component.MemoryBuffer? {
            let (value) = try ComPtrs.initialize { valueAbi in
                let inputWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(input)
                let _input = try! inputWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBufferStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateMemoryBufferOverIBuffer(pThis, _input, &valueAbi))
                }
            }
            return .from(abi: value)
        }

    }

    public class IContentTypeProvider: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider }

        open func get_ContentTypeImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ContentType(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IContentTypeProviderVTable: __x_ABI_CWindows_CStorage_CStreams_CIContentTypeProviderVtbl = .init(
        QueryInterface: { IContentTypeProviderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IContentTypeProviderWrapper.addRef($0) },
        Release: { IContentTypeProviderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IContentTypeProvider").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_ContentType: {
            guard let __unwrapped__instance = IContentTypeProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.contentType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        }
    )

    public typealias IContentTypeProviderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IContentTypeProviderBridge>
    public class IInputStream: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIInputStream }

        open func ReadAsyncImpl(_ buffer: test_component.AnyIBuffer?, _ count: UInt32, _ options: test_component.InputStreamOptions) throws -> test_component.AnyIAsyncOperationWithProgress<test_component.AnyIBuffer?, UInt32>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                let _buffer = try! bufferWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIInputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadAsync(pThis, _buffer, count, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IInputStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamVtbl = .init(
        QueryInterface: { IInputStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IInputStreamWrapper.addRef($0) },
        Release: { IInputStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IInputStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        ReadAsync: {
            do {
                guard let __unwrapped__instance = IInputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer: test_component.AnyIBuffer? = __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: ComPtr($1))
                let count: UInt32 = $2
                let options: test_component.InputStreamOptions = $3
                let operation = try __unwrapped__instance.readAsync(buffer, count, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IInputStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IInputStreamBridge>
    public class IInputStreamReference: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference }

        open func OpenSequentialReadAsyncImpl() throws -> test_component.AnyIAsyncOperation<test_component.AnyIInputStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenSequentialReadAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IInputStreamReferenceVTable: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamReferenceVtbl = .init(
        QueryInterface: { IInputStreamReferenceWrapper.queryInterface($0, $1, $2) },
        AddRef: { IInputStreamReferenceWrapper.addRef($0) },
        Release: { IInputStreamReferenceWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IInputStreamReference").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenSequentialReadAsync: {
            do {
                guard let __unwrapped__instance = IInputStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openSequentialReadAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IInputStreamReferenceWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IInputStreamReferenceBridge>
    public class IOutputStream: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIOutputStream }

        open func WriteAsyncImpl(_ buffer: test_component.AnyIBuffer?) throws -> test_component.AnyIAsyncOperationWithProgress<UInt32, UInt32>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                let _buffer = try! bufferWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIOutputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.WriteAsync(pThis, _buffer, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.unwrapFrom(abi: operation)
        }

        open func FlushAsyncImpl() throws -> test_component.AnyIAsyncOperation<Bool>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIOutputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.FlushAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IOutputStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIOutputStreamVtbl = .init(
        QueryInterface: { IOutputStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IOutputStreamWrapper.addRef($0) },
        Release: { IOutputStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IOutputStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        WriteAsync: {
            do {
                guard let __unwrapped__instance = IOutputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer: test_component.AnyIBuffer? = __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.writeAsync(buffer)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        FlushAsync: {
            do {
                guard let __unwrapped__instance = IOutputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.flushAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1_booleanWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IOutputStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IOutputStreamBridge>
    public class IRandomAccessStream: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream }

        open func get_SizeImpl() throws -> UInt64 {
            var value: UINT64 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &value))
            }
            return value
        }

        open func put_SizeImpl(_ value: UInt64) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_Size(pThis, value))
            }
        }

        open func GetInputStreamAtImpl(_ position: UInt64) throws -> test_component.AnyIInputStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetInputStreamAt(pThis, position, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IInputStreamWrapper.unwrapFrom(abi: stream)
        }

        open func GetOutputStreamAtImpl(_ position: UInt64) throws -> test_component.AnyIOutputStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetOutputStreamAt(pThis, position, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IOutputStreamWrapper.unwrapFrom(abi: stream)
        }

        open func get_PositionImpl() throws -> UInt64 {
            var value: UINT64 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Position(pThis, &value))
            }
            return value
        }

        open func SeekImpl(_ position: UInt64) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Seek(pThis, position))
            }
        }

        open func CloneStreamImpl() throws -> test_component.AnyIRandomAccessStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CloneStream(pThis, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.unwrapFrom(abi: stream)
        }

        open func get_CanReadImpl() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_CanRead(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_CanWriteImpl() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_CanWrite(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IRandomAccessStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamVtbl = .init(
        QueryInterface: { IRandomAccessStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamWrapper.addRef($0) },
        Release: { IRandomAccessStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 6).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            $1!.pointee = 6
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Size: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.size
            $1?.initialize(to: value)
            return S_OK
        },

        put_Size: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UInt64 = $1
            __unwrapped__instance.size = value
            return S_OK
        },

        GetInputStreamAt: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                let stream = try __unwrapped__instance.getInputStreamAt(position)
                let streamWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(stream)
                streamWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetOutputStreamAt: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                let stream = try __unwrapped__instance.getOutputStreamAt(position)
                let streamWrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(stream)
                streamWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        get_Position: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.position
            $1?.initialize(to: value)
            return S_OK
        },

        Seek: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                try __unwrapped__instance.seek(position)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CloneStream: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let stream = try __unwrapped__instance.cloneStream()
                let streamWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper(stream)
                streamWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        get_CanRead: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.canRead
            $1?.initialize(to: .init(from: value))
            return S_OK
        },

        get_CanWrite: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.canWrite
            $1?.initialize(to: .init(from: value))
            return S_OK
        }
    )

    public typealias IRandomAccessStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamBridge>
    public class IRandomAccessStreamReference: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference }

        open func OpenReadAsyncImpl() throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStreamWithContentType?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenReadAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IRandomAccessStreamReferenceVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReferenceVtbl = .init(
        QueryInterface: { IRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamReferenceWrapper.addRef($0) },
        Release: { IRandomAccessStreamReferenceWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStreamReference").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenReadAsync: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openReadAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamReferenceBridge>
    public class IRandomAccessStreamWithContentType: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType }

    }

    internal static var IRandomAccessStreamWithContentTypeVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentTypeVtbl = .init(
        QueryInterface: { IRandomAccessStreamWithContentTypeWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamWithContentTypeWrapper.addRef($0) },
        Release: { IRandomAccessStreamWithContentTypeWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 8).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            iids[6] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.IID
            iids[7] = __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper.IID
            $1!.pointee = 8
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStreamWithContentType").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        }
    )

    public typealias IRandomAccessStreamWithContentTypeWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeBridge>
}
