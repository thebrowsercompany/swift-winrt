// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
import Ctest_component

public protocol IArrayScenarios : WinRTInterface {
    func inArray(_ value: [Int32]) throws
    func outArray(_ value: inout [Int32]) throws
    func refArray(_ value: inout [Int32]) throws
    func returnArray() throws -> [Int32]
    func doubleIn(_ value1: [Int32], _ value2: [Int32]) throws
    func inAndOut(_ value: [Int32], _ results: inout [Int32]) throws
    func inAndRef(_ value: [Int32], _ results: inout [Int32]) throws
    func inAndRefNonBlittable(_ value: [Int32], _ results: inout [Bool]) throws
    func inAndReturn(_ value: [Int32]) throws -> [Int32]
    var arrayProperty: [Int32] { get set }
}

extension IArrayScenarios {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_test_component.IArrayScenariosWrapper.IID:
                let wrapper = __ABI_test_component.IArrayScenariosWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIArrayScenarios = any IArrayScenarios


// MARK: - Internals

@_spi(WinRTInternal)
extension __IMPL_test_component {
    public enum IArrayScenariosBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_Ctest__component_CIArrayScenarios
        public typealias SwiftABI = __ABI_test_component.IArrayScenarios
        public typealias SwiftProjection = AnyIArrayScenarios
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IArrayScenariosImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_test_component.IArrayScenariosVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IArrayScenariosImpl: IArrayScenarios, WinRTAbiImpl {
        fileprivate typealias Bridge = IArrayScenariosBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        fileprivate func inArray(_ value: [Int32]) throws {
            try _default.InArray(value)
        }

        fileprivate func outArray(_ value: inout [Int32]) throws {
            try _default.OutArray(&value)
        }

        fileprivate func refArray(_ value: inout [Int32]) throws {
            try _default.RefArray(&value)
        }

        fileprivate func returnArray() throws -> [Int32] {
            try _default.ReturnArray()
        }

        fileprivate func doubleIn(_ value1: [Int32], _ value2: [Int32]) throws {
            try _default.DoubleIn(value1, value2)
        }

        fileprivate func inAndOut(_ value: [Int32], _ results: inout [Int32]) throws {
            try _default.InAndOut(value, &results)
        }

        fileprivate func inAndRef(_ value: [Int32], _ results: inout [Int32]) throws {
            try _default.InAndRef(value, &results)
        }

        fileprivate func inAndRefNonBlittable(_ value: [Int32], _ results: inout [Bool]) throws {
            try _default.InAndRefNonBlittable(value, &results)
        }

        fileprivate func inAndReturn(_ value: [Int32]) throws -> [Int32] {
            try _default.InAndReturn(value)
        }

        fileprivate var arrayProperty : [Int32] {
            get { try! _default.get_ArrayProperty() }
            set { try! _default.put_ArrayProperty(newValue) }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_test_component {
    private static let IID___x_ABI_Ctest__component_CIArrayScenarios: test_component.IID = .init(
        Data1: 0x56558D36, Data2: 0xC35F, Data3: 0x5624, Data4: ( 0xB3,0xB1,0xF3,0xF3,0x65,0x26,0x57,0xA3 ) // 56558D36-C35F-5624-B3B1-F3F3652657A3
    ) 
    public class IArrayScenarios: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_Ctest__component_CIArrayScenarios }

        open func InArray(_ value: [Int32]) throws {
            try value.toABI { _value in
                _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.InArray(pThis, _value.count, _value.start))
                }
            }
        }

        open func OutArray(_ value: inout [Int32]) throws {
            var _value: WinRTArrayAbi<INT32> = (0, nil)
            _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.OutArray(pThis, &_value.count, &_value.start))
            }
            defer { CoTaskMemFree(_value.start) }
            value = .from(abi: _value)
        }

        open func RefArray(_ value: inout [Int32]) throws {
            try value.toABI { _value in
                _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.RefArray(pThis, _value.count, _value.start))
                }
            }
        }

        open func ReturnArray() throws -> [Int32] {
            var result: WinRTArrayAbi<INT32> = (0, nil)
            _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReturnArray(pThis, &result.count, &result.start))
            }
            defer { CoTaskMemFree(result.start) }
            return .from(abi: result)

        }

        open func get_ArrayProperty() throws -> [Int32] {
            var value: WinRTArrayAbi<INT32> = (0, nil)
            _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ArrayProperty(pThis, &value.count, &value.start))
            }
            defer { CoTaskMemFree(value.start) }
            return .from(abi: value)

        }

        open func put_ArrayProperty(_ value: [Int32]) throws {
            try value.toABI { _value in
                _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.put_ArrayProperty(pThis, _value.count, _value.start))
                }
            }
        }

        open func DoubleIn(_ value1: [Int32], _ value2: [Int32]) throws {
            try value1.toABI { _value1 in
                try value2.toABI { _value2 in
                _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DoubleIn(pThis, _value1.count, _value1.start, _value2.count, _value2.start))
                }
            }
            }
        }

        open func InAndOut(_ value: [Int32], _ results: inout [Int32]) throws {
            try value.toABI { _value in
                var _results: WinRTArrayAbi<INT32> = (0, nil)
                _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.InAndOut(pThis, _value.count, _value.start, &_results.count, &_results.start))
                }
                defer { CoTaskMemFree(_results.start) }
                results = .from(abi: _results)
            }
        }

        open func InAndRef(_ value: [Int32], _ results: inout [Int32]) throws {
            try value.toABI { _value in
                try results.toABI { _results in
                _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.InAndRef(pThis, _value.count, _value.start, _results.count, _results.start))
                }
            }
            }
        }

        open func InAndRefNonBlittable(_ value: [Int32], _ results: inout [Bool]) throws {
            try value.toABI { _value in
                try results.toABI { _results in
                _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.InAndRefNonBlittable(pThis, _value.count, _value.start, _results.count, _results.start))
                }
                results = .from(abi: _results)
            }
            }
        }

        open func InAndReturn(_ value: [Int32]) throws -> [Int32] {
            var result: WinRTArrayAbi<INT32> = (0, nil)
            try value.toABI { _value in
                _ = try perform(as: __x_ABI_Ctest__component_CIArrayScenarios.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.InAndReturn(pThis, _value.count, _value.start, &result.count, &result.start))
                }
            }
            defer { CoTaskMemFree(result.start) }
            return .from(abi: result)

        }

    }

    internal static var IArrayScenariosVTable: __x_ABI_Ctest__component_CIArrayScenariosVtbl = .init(
        QueryInterface: { IArrayScenariosWrapper.queryInterface($0, $1, $2) },
        AddRef: { IArrayScenariosWrapper.addRef($0) },
        Release: { IArrayScenariosWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_test_component.IArrayScenariosWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("test_component.IArrayScenarios").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        InArray: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: [Int32] = .from(abi: (count: $1, start: $2))
                try __unwrapped__instance.inArray(value)
                return S_OK
            } catch { return failWith(error: error) }
        },

        OutArray: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                var value = [Int32]()
                try __unwrapped__instance.outArray(&value)
                $1?.initialize(to: UInt32(value.count))
                value.fill(abi: $2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        RefArray: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                var value: [Int32] = .from(abi: (count: $1, start: $2))
                try __unwrapped__instance.refArray(&value)
                value.fill(abi: $2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        ReturnArray: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let result = try __unwrapped__instance.returnArray()
                $1?.initialize(to: UInt32(result.count))
                result.fill(abi: $2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        get_ArrayProperty: {
            guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.arrayProperty
            $1?.initialize(to: UInt32(value.count))
            value.fill(abi: $2)
            return S_OK
        },

        put_ArrayProperty: {
            guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: [Int32] = .from(abi: (count: $1, start: $2))
            __unwrapped__instance.arrayProperty = value
            return S_OK
        },

        DoubleIn: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value1: [Int32] = .from(abi: (count: $1, start: $2))
                let value2: [Int32] = .from(abi: (count: $3, start: $4))
                try __unwrapped__instance.doubleIn(value1, value2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        InAndOut: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: [Int32] = .from(abi: (count: $1, start: $2))
                var results = [Int32]()
                try __unwrapped__instance.inAndOut(value, &results)
                $3?.initialize(to: UInt32(results.count))
                results.fill(abi: $4)
                return S_OK
            } catch { return failWith(error: error) }
        },

        InAndRef: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: [Int32] = .from(abi: (count: $1, start: $2))
                var results: [Int32] = .from(abi: (count: $3, start: $4))
                try __unwrapped__instance.inAndRef(value, &results)
                results.fill(abi: $4)
                return S_OK
            } catch { return failWith(error: error) }
        },

        InAndRefNonBlittable: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: [Int32] = .from(abi: (count: $1, start: $2))
                var results: [Bool] = .from(abi: (count: $3, start: $4))
                try __unwrapped__instance.inAndRefNonBlittable(value, &results)
                do {
                    try results.fill(abi: $4)
                } catch { return failWith(error: error) }
                return S_OK
            } catch { return failWith(error: error) }
        },

        InAndReturn: {
            do {
                guard let __unwrapped__instance = IArrayScenariosWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: [Int32] = .from(abi: (count: $1, start: $2))
                let result = try __unwrapped__instance.inAndReturn(value)
                $3?.initialize(to: UInt32(result.count))
                result.fill(abi: $4)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IArrayScenariosWrapper = InterfaceWrapperBase<__IMPL_test_component.IArrayScenariosBridge>
}
@_spi(WinRTInternal)
public class IArrayScenariosMaker: MakeFromAbi {
    public typealias SwiftType = AnyIArrayScenarios
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_test_component.IArrayScenarios = try! abi.QueryInterface()
        return __IMPL_test_component.IArrayScenariosBridge.from(abi: RawPointer(swiftAbi))!
    }
}
