// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
import Ctest_component

// MARK: - IStorageFile

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile)
public protocol IStorageFile : IStorageItem, test_component.IRandomAccessStreamReference, test_component.IInputStreamReference {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.openasync)
    func openAsync(_ accessMode: test_component.FileAccessMode) throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStream?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.opentransactedwriteasync)
    func openTransactedWriteAsync() throws -> test_component.AnyIAsyncOperation<test_component.StorageStreamTransaction?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.copyasync)
    func copyAsync(_ destinationFolder: test_component.AnyIStorageFolder!) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.copyasync)
    func copyAsync(_ destinationFolder: test_component.AnyIStorageFolder!, _ desiredNewName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.copyasync)
    func copyAsync(_ destinationFolder: test_component.AnyIStorageFolder!, _ desiredNewName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.copyandreplaceasync)
    func copyAndReplaceAsync(_ fileToReplace: test_component.AnyIStorageFile!) throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.moveasync)
    func moveAsync(_ destinationFolder: test_component.AnyIStorageFolder!) throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.moveasync)
    func moveAsync(_ destinationFolder: test_component.AnyIStorageFolder!, _ desiredNewName: String) throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.moveasync)
    func moveAsync(_ destinationFolder: test_component.AnyIStorageFolder!, _ desiredNewName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.moveandreplaceasync)
    func moveAndReplaceAsync(_ fileToReplace: test_component.AnyIStorageFile!) throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.contenttype)
    var contentType: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.filetype)
    var fileType: String { get }
}

extension IStorageFile {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageFileWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageFileWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage.IStorageItemWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageFile = any IStorageFile

// MARK: - IStorageFile Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageFileBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageFile
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageFile
        public typealias SwiftProjection = AnyIStorageFile
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageFileImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageFileVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageFileImpl: IStorageFile, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageFileBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.openasync)
        fileprivate func openAsync(_ accessMode: FileAccessMode) throws -> AnyIAsyncOperation<test_component.AnyIRandomAccessStream?>! {
            try _default.OpenAsync(accessMode)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.opentransactedwriteasync)
        fileprivate func openTransactedWriteAsync() throws -> AnyIAsyncOperation<StorageStreamTransaction?>! {
            try _default.OpenTransactedWriteAsync()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.copyasync)
        fileprivate func copyAsync(_ destinationFolder: AnyIStorageFolder!) throws -> AnyIAsyncOperation<StorageFile?>! {
            try _default.CopyOverloadDefaultNameAndOptions(destinationFolder)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.copyasync)
        fileprivate func copyAsync(_ destinationFolder: AnyIStorageFolder!, _ desiredNewName: String) throws -> AnyIAsyncOperation<StorageFile?>! {
            try _default.CopyOverloadDefaultOptions(destinationFolder, desiredNewName)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.copyasync)
        fileprivate func copyAsync(_ destinationFolder: AnyIStorageFolder!, _ desiredNewName: String, _ option: NameCollisionOption) throws -> AnyIAsyncOperation<StorageFile?>! {
            try _default.CopyOverload(destinationFolder, desiredNewName, option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.copyandreplaceasync)
        fileprivate func copyAndReplaceAsync(_ fileToReplace: AnyIStorageFile!) throws -> test_component.AnyIAsyncAction! {
            try _default.CopyAndReplaceAsync(fileToReplace)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.moveasync)
        fileprivate func moveAsync(_ destinationFolder: AnyIStorageFolder!) throws -> test_component.AnyIAsyncAction! {
            try _default.MoveOverloadDefaultNameAndOptions(destinationFolder)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.moveasync)
        fileprivate func moveAsync(_ destinationFolder: AnyIStorageFolder!, _ desiredNewName: String) throws -> test_component.AnyIAsyncAction! {
            try _default.MoveOverloadDefaultOptions(destinationFolder, desiredNewName)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.moveasync)
        fileprivate func moveAsync(_ destinationFolder: AnyIStorageFolder!, _ desiredNewName: String, _ option: NameCollisionOption) throws -> test_component.AnyIAsyncAction! {
            try _default.MoveOverload(destinationFolder, desiredNewName, option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.moveandreplaceasync)
        fileprivate func moveAndReplaceAsync(_ fileToReplace: AnyIStorageFile!) throws -> test_component.AnyIAsyncAction! {
            try _default.MoveAndReplaceAsync(fileToReplace)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.contenttype)
        fileprivate var contentType : String {
            get { try! _default.get_ContentType() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.filetype)
        fileprivate var fileType : String {
            get { try! _default.get_FileType() }
        }

        private lazy var _IStorageItem: __ABI_Windows_Storage.IStorageItem! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.renameasync)
        fileprivate func renameAsync(_ desiredName: String) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.RenameAsyncOverloadDefaultOptions(desiredName)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.renameasync)
        fileprivate func renameAsync(_ desiredName: String, _ option: NameCollisionOption) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.RenameAsync(desiredName, option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.deleteasync)
        fileprivate func deleteAsync() throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.DeleteAsyncOverloadDefaultOptions()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.deleteasync)
        fileprivate func deleteAsync(_ option: StorageDeleteOption) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.DeleteAsync(option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.getbasicpropertiesasync)
        fileprivate func getBasicPropertiesAsync() throws -> AnyIAsyncOperation<test_component.BasicProperties?>! {
            try _IStorageItem.GetBasicPropertiesAsync()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.isoftype)
        fileprivate func isOfType(_ type: StorageItemTypes) throws -> Bool {
            try _IStorageItem.IsOfType(type)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.attributes)
        fileprivate var attributes : FileAttributes {
            get { try! _IStorageItem.get_Attributes() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.datecreated)
        fileprivate var dateCreated : test_component.DateTime {
            get { try! _IStorageItem.get_DateCreated() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.name)
        fileprivate var name : String {
            get { try! _IStorageItem.get_Name() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.path)
        fileprivate var path : String {
            get { try! _IStorageItem.get_Path() }
        }

        private lazy var _IRandomAccessStreamReference: __ABI_Windows_Storage_Streams.IRandomAccessStreamReference! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.openreadasync)
        fileprivate func openReadAsync() throws -> AnyIAsyncOperation<test_component.AnyIRandomAccessStreamWithContentType?>! {
            try _IRandomAccessStreamReference.OpenReadAsync()
        }

        private lazy var _IInputStreamReference: __ABI_Windows_Storage_Streams.IInputStreamReference! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile.opensequentialreadasync)
        fileprivate func openSequentialReadAsync() throws -> AnyIAsyncOperation<test_component.AnyIInputStream?>! {
            try _IInputStreamReference.OpenSequentialReadAsync()
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageFile: test_component.IID = .init(
        Data1: 0xFA3F6186, Data2: 0x4214, Data3: 0x428C, Data4: ( 0xA6,0x4C,0x14,0xC9,0xAC,0x73,0x15,0xEA ) // FA3F6186-4214-428C-A64C-14C9AC7315EA
    ) 
    public class IStorageFile: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFile }

        open func get_FileType() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_FileType(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_ContentType() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ContentType(pThis, &value))
            }
            return .init(from: value)
        }

        open func OpenAsync(_ accessMode: test_component.FileAccessMode) throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenAsync(pThis, accessMode, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        open func OpenTransactedWriteAsync() throws -> test_component.AnyIAsyncOperation<test_component.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverloadDefaultNameAndOptions(_ destinationFolder: test_component.AnyIStorageFolder?) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverloadDefaultNameAndOptions(pThis, _destinationFolder, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverloadDefaultOptions(_ destinationFolder: test_component.AnyIStorageFolder?, _ desiredNewName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverloadDefaultOptions(pThis, _destinationFolder, _desiredNewName.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverload(_ destinationFolder: test_component.AnyIStorageFolder?, _ desiredNewName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverload(pThis, _destinationFolder, _desiredNewName.get(), option, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyAndReplaceAsync(_ fileToReplace: test_component.AnyIStorageFile?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyAndReplaceAsync(pThis, _fileToReplace, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverloadDefaultNameAndOptions(_ destinationFolder: test_component.AnyIStorageFolder?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverloadDefaultNameAndOptions(pThis, _destinationFolder, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverloadDefaultOptions(_ destinationFolder: test_component.AnyIStorageFolder?, _ desiredNewName: String) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverloadDefaultOptions(pThis, _destinationFolder, _desiredNewName.get(), &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverload(_ destinationFolder: test_component.AnyIStorageFolder?, _ desiredNewName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverload(pThis, _destinationFolder, _desiredNewName.get(), option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveAndReplaceAsync(_ fileToReplace: test_component.AnyIStorageFile?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveAndReplaceAsync(pThis, _fileToReplace, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFileVTable: __x_ABI_CWindows_CStorage_CIStorageFileVtbl = .init(
        QueryInterface: { IStorageFileWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFileWrapper.addRef($0) },
        Release: { IStorageFileWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 6).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFileWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper.IID
            $1!.pointee = 6
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFile").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_FileType: {
            guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.fileType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_ContentType: {
            guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.contentType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        OpenAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let accessMode: test_component.FileAccessMode = $1
                let operation = try __unwrapped__instance.openAsync(accessMode)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        OpenTransactedWriteAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openTransactedWriteAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CopyOverloadDefaultNameAndOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.copyAsync(destinationFolder)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CopyOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let operation = try __unwrapped__instance.copyAsync(destinationFolder, desiredNewName)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CopyOverload: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let option: test_component.NameCollisionOption = $3
                let operation = try __unwrapped__instance.copyAsync(destinationFolder, desiredNewName, option)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CopyAndReplaceAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let fileToReplace: test_component.AnyIStorageFile? = __ABI_Windows_Storage.IStorageFileWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.copyAndReplaceAsync(fileToReplace)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        MoveOverloadDefaultNameAndOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.moveAsync(destinationFolder)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        MoveOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let operation = try __unwrapped__instance.moveAsync(destinationFolder, desiredNewName)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        MoveOverload: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let option: test_component.NameCollisionOption = $3
                let operation = try __unwrapped__instance.moveAsync(destinationFolder, desiredNewName, option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        },

        MoveAndReplaceAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let fileToReplace: test_component.AnyIStorageFile? = __ABI_Windows_Storage.IStorageFileWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.moveAndReplaceAsync(fileToReplace)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageFileWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFileBridge>
}
@_spi(WinRTInternal)
public class IStorageFileMaker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageFile
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageFile = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageFileBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageFile2

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile2)
public protocol IStorageFile2 : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile2.openasync)
    func openAsync(_ accessMode: test_component.FileAccessMode, _ options: test_component.StorageOpenOptions) throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStream?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile2.opentransactedwriteasync)
    func openTransactedWriteAsync(_ options: test_component.StorageOpenOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageStreamTransaction?>!
}

extension IStorageFile2 {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageFile2Wrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageFile2Wrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageFile2 = any IStorageFile2

// MARK: - IStorageFile2 Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageFile2Bridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageFile2
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageFile2
        public typealias SwiftProjection = AnyIStorageFile2
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageFile2Impl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageFile2VTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageFile2Impl: IStorageFile2, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageFile2Bridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile2.openasync)
        fileprivate func openAsync(_ accessMode: FileAccessMode, _ options: StorageOpenOptions) throws -> AnyIAsyncOperation<test_component.AnyIRandomAccessStream?>! {
            try _default.OpenWithOptionsAsync(accessMode, options)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefile2.opentransactedwriteasync)
        fileprivate func openTransactedWriteAsync(_ options: StorageOpenOptions) throws -> AnyIAsyncOperation<StorageStreamTransaction?>! {
            try _default.OpenTransactedWriteWithOptionsAsync(options)
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageFile2: test_component.IID = .init(
        Data1: 0x954E4BCF, Data2: 0x0A77, Data3: 0x42FB, Data4: ( 0xB7,0x77,0xC2,0xED,0x58,0xA5,0x2E,0x44 ) // 954E4BCF-0A77-42FB-B777-C2ED58A52E44
    ) 
    public class IStorageFile2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFile2 }

        open func OpenWithOptionsAsync(_ accessMode: test_component.FileAccessMode, _ options: test_component.StorageOpenOptions) throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenWithOptionsAsync(pThis, accessMode, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        open func OpenTransactedWriteWithOptionsAsync(_ options: test_component.StorageOpenOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteWithOptionsAsync(pThis, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFile2VTable: __x_ABI_CWindows_CStorage_CIStorageFile2Vtbl = .init(
        QueryInterface: { IStorageFile2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFile2Wrapper.addRef($0) },
        Release: { IStorageFile2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFile2Wrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFile2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenWithOptionsAsync: {
            do {
                guard let __unwrapped__instance = IStorageFile2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let accessMode: test_component.FileAccessMode = $1
                let options: test_component.StorageOpenOptions = $2
                let operation = try __unwrapped__instance.openAsync(accessMode, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        OpenTransactedWriteWithOptionsAsync: {
            do {
                guard let __unwrapped__instance = IStorageFile2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let options: test_component.StorageOpenOptions = $1
                let operation = try __unwrapped__instance.openTransactedWriteAsync(options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageFile2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFile2Bridge>
}
@_spi(WinRTInternal)
public class IStorageFile2Maker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageFile2
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageFile2 = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageFile2Bridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageFilePropertiesWithAvailability

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefilepropertieswithavailability)
public protocol IStorageFilePropertiesWithAvailability : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefilepropertieswithavailability.isavailable)
    var isAvailable: Bool { get }
}

extension IStorageFilePropertiesWithAvailability {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageFilePropertiesWithAvailabilityWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageFilePropertiesWithAvailabilityWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageFilePropertiesWithAvailability = any IStorageFilePropertiesWithAvailability

// MARK: - IStorageFilePropertiesWithAvailability Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageFilePropertiesWithAvailabilityBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageFilePropertiesWithAvailability
        public typealias SwiftProjection = AnyIStorageFilePropertiesWithAvailability
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageFilePropertiesWithAvailabilityImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageFilePropertiesWithAvailabilityVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageFilePropertiesWithAvailabilityImpl: IStorageFilePropertiesWithAvailability, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageFilePropertiesWithAvailabilityBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefilepropertieswithavailability.isavailable)
        fileprivate var isAvailable : Bool {
            get { try! _default.get_IsAvailable() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability: test_component.IID = .init(
        Data1: 0xAFCBBE9B, Data2: 0x582B, Data3: 0x4133, Data4: ( 0x96,0x48,0xE4,0x4C,0xA4,0x6E,0xE4,0x91 ) // AFCBBE9B-582B-4133-9648-E44CA46EE491
    ) 
    public class IStorageFilePropertiesWithAvailability: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability }

        open func get_IsAvailable() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_IsAvailable(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageFilePropertiesWithAvailabilityVTable: __x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailabilityVtbl = .init(
        QueryInterface: { IStorageFilePropertiesWithAvailabilityWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFilePropertiesWithAvailabilityWrapper.addRef($0) },
        Release: { IStorageFilePropertiesWithAvailabilityWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFilePropertiesWithAvailabilityWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFilePropertiesWithAvailability").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_IsAvailable: {
            guard let __unwrapped__instance = IStorageFilePropertiesWithAvailabilityWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.isAvailable
            $1?.initialize(to: .init(from: value))
            return S_OK
        }
    )

    public typealias IStorageFilePropertiesWithAvailabilityWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFilePropertiesWithAvailabilityBridge>
}
@_spi(WinRTInternal)
public class IStorageFilePropertiesWithAvailabilityMaker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageFilePropertiesWithAvailability
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageFilePropertiesWithAvailability = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageFilePropertiesWithAvailabilityBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageFolder

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder)
public protocol IStorageFolder : IStorageItem {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.createfileasync)
    func createFileAsync(_ desiredName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.createfileasync)
    func createFileAsync(_ desiredName: String, _ options: test_component.CreationCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.createfolderasync)
    func createFolderAsync(_ desiredName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.createfolderasync)
    func createFolderAsync(_ desiredName: String, _ options: test_component.CreationCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getfileasync)
    func getFileAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getfolderasync)
    func getFolderAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getitemasync)
    func getItemAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.AnyIStorageItem?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getfilesasync)
    func getFilesAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.StorageFile?>?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getfoldersasync)
    func getFoldersAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.StorageFolder?>?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getitemsasync)
    func getItemsAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.AnyIStorageItem?>?>!
}

extension IStorageFolder {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageFolderWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageFolderWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage.IStorageItemWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageFolder = any IStorageFolder

// MARK: - IStorageFolder Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageFolderBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageFolder
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageFolder
        public typealias SwiftProjection = AnyIStorageFolder
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageFolderImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageFolderVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageFolderImpl: IStorageFolder, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageFolderBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.createfileasync)
        fileprivate func createFileAsync(_ desiredName: String) throws -> AnyIAsyncOperation<StorageFile?>! {
            try _default.CreateFileAsyncOverloadDefaultOptions(desiredName)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.createfileasync)
        fileprivate func createFileAsync(_ desiredName: String, _ options: CreationCollisionOption) throws -> AnyIAsyncOperation<StorageFile?>! {
            try _default.CreateFileAsync(desiredName, options)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.createfolderasync)
        fileprivate func createFolderAsync(_ desiredName: String) throws -> AnyIAsyncOperation<StorageFolder?>! {
            try _default.CreateFolderAsyncOverloadDefaultOptions(desiredName)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.createfolderasync)
        fileprivate func createFolderAsync(_ desiredName: String, _ options: CreationCollisionOption) throws -> AnyIAsyncOperation<StorageFolder?>! {
            try _default.CreateFolderAsync(desiredName, options)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getfileasync)
        fileprivate func getFileAsync(_ name: String) throws -> AnyIAsyncOperation<StorageFile?>! {
            try _default.GetFileAsync(name)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getfolderasync)
        fileprivate func getFolderAsync(_ name: String) throws -> AnyIAsyncOperation<StorageFolder?>! {
            try _default.GetFolderAsync(name)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getitemasync)
        fileprivate func getItemAsync(_ name: String) throws -> AnyIAsyncOperation<AnyIStorageItem?>! {
            try _default.GetItemAsync(name)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getfilesasync)
        fileprivate func getFilesAsync() throws -> AnyIAsyncOperation<AnyIVectorView<StorageFile?>?>! {
            try _default.GetFilesAsyncOverloadDefaultOptionsStartAndCount()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getfoldersasync)
        fileprivate func getFoldersAsync() throws -> AnyIAsyncOperation<AnyIVectorView<StorageFolder?>?>! {
            try _default.GetFoldersAsyncOverloadDefaultOptionsStartAndCount()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getitemsasync)
        fileprivate func getItemsAsync() throws -> AnyIAsyncOperation<AnyIVectorView<AnyIStorageItem?>?>! {
            try _default.GetItemsAsyncOverloadDefaultStartAndCount()
        }

        private lazy var _IStorageItem: __ABI_Windows_Storage.IStorageItem! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.renameasync)
        fileprivate func renameAsync(_ desiredName: String) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.RenameAsyncOverloadDefaultOptions(desiredName)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.renameasync)
        fileprivate func renameAsync(_ desiredName: String, _ option: NameCollisionOption) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.RenameAsync(desiredName, option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.deleteasync)
        fileprivate func deleteAsync() throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.DeleteAsyncOverloadDefaultOptions()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.deleteasync)
        fileprivate func deleteAsync(_ option: StorageDeleteOption) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.DeleteAsync(option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.getbasicpropertiesasync)
        fileprivate func getBasicPropertiesAsync() throws -> AnyIAsyncOperation<test_component.BasicProperties?>! {
            try _IStorageItem.GetBasicPropertiesAsync()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.isoftype)
        fileprivate func isOfType(_ type: StorageItemTypes) throws -> Bool {
            try _IStorageItem.IsOfType(type)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.attributes)
        fileprivate var attributes : FileAttributes {
            get { try! _IStorageItem.get_Attributes() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.datecreated)
        fileprivate var dateCreated : test_component.DateTime {
            get { try! _IStorageItem.get_DateCreated() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.name)
        fileprivate var name : String {
            get { try! _IStorageItem.get_Name() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder.path)
        fileprivate var path : String {
            get { try! _IStorageItem.get_Path() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageFolder: test_component.IID = .init(
        Data1: 0x72D1CB78, Data2: 0xB3EF, Data3: 0x4F75, Data4: ( 0xA8,0x0B,0x6F,0xD9,0xDA,0xE2,0x94,0x4B ) // 72D1CB78-B3EF-4F75-A80B-6FD9DAE2944B
    ) 
    public class IStorageFolder: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolder }

        open func CreateFileAsyncOverloadDefaultOptions(_ desiredName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFileAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFileAsync(_ desiredName: String, _ options: test_component.CreationCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFileAsync(pThis, _desiredName.get(), options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFolderAsyncOverloadDefaultOptions(_ desiredName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFolderAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFolderAsync(_ desiredName: String, _ options: test_component.CreationCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFolderAsync(pThis, _desiredName.get(), options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetFileAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func GetFolderAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFolderAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetItemAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.AnyIStorageItem?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetItemAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

        open func GetFilesAsyncOverloadDefaultOptionsStartAndCount() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.StorageFile?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFilesAsyncOverloadDefaultOptionsStartAndCount(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func GetFoldersAsyncOverloadDefaultOptionsStartAndCount() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.StorageFolder?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFoldersAsyncOverloadDefaultOptionsStartAndCount(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetItemsAsyncOverloadDefaultStartAndCount() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.AnyIStorageItem?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetItemsAsyncOverloadDefaultStartAndCount(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFolderVTable: __x_ABI_CWindows_CStorage_CIStorageFolderVtbl = .init(
        QueryInterface: { IStorageFolderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFolderWrapper.addRef($0) },
        Release: { IStorageFolderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFolderWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFolder").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        CreateFileAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.createFileAsync(desiredName)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CreateFileAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let options: test_component.CreationCollisionOption = $2
                let operation = try __unwrapped__instance.createFileAsync(desiredName, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CreateFolderAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.createFolderAsync(desiredName)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CreateFolderAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let options: test_component.CreationCollisionOption = $2
                let operation = try __unwrapped__instance.createFolderAsync(desiredName, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetFileAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getFileAsync(name)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetFolderAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getFolderAsync(name)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetItemAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getItemAsync(name)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetFilesAsyncOverloadDefaultOptionsStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getFilesAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetFoldersAsyncOverloadDefaultOptionsStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getFoldersAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetItemsAsyncOverloadDefaultStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getItemsAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageFolderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFolderBridge>
}
@_spi(WinRTInternal)
public class IStorageFolderMaker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageFolder
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageFolder = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageFolderBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageFolder2

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder2)
public protocol IStorageFolder2 : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder2.trygetitemasync)
    func tryGetItemAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.AnyIStorageItem?>!
}

extension IStorageFolder2 {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageFolder2Wrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageFolder2Wrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageFolder2 = any IStorageFolder2

// MARK: - IStorageFolder2 Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageFolder2Bridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageFolder2
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageFolder2
        public typealias SwiftProjection = AnyIStorageFolder2
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageFolder2Impl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageFolder2VTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageFolder2Impl: IStorageFolder2, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageFolder2Bridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istoragefolder2.trygetitemasync)
        fileprivate func tryGetItemAsync(_ name: String) throws -> AnyIAsyncOperation<AnyIStorageItem?>! {
            try _default.TryGetItemAsync(name)
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageFolder2: test_component.IID = .init(
        Data1: 0xE827E8B9, Data2: 0x08D9, Data3: 0x4A8E, Data4: ( 0xA0,0xAC,0xFE,0x5E,0xD3,0xCB,0xBB,0xD3 ) // E827E8B9-08D9-4A8E-A0AC-FE5ED3CBBBD3
    ) 
    public class IStorageFolder2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolder2 }

        open func TryGetItemAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.AnyIStorageItem?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.TryGetItemAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFolder2VTable: __x_ABI_CWindows_CStorage_CIStorageFolder2Vtbl = .init(
        QueryInterface: { IStorageFolder2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFolder2Wrapper.addRef($0) },
        Release: { IStorageFolder2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFolder2Wrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFolder2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        TryGetItemAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolder2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.tryGetItemAsync(name)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageFolder2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFolder2Bridge>
}
@_spi(WinRTInternal)
public class IStorageFolder2Maker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageFolder2
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageFolder2 = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageFolder2Bridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageItem

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem)
public protocol IStorageItem : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.renameasync)
    func renameAsync(_ desiredName: String) throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.renameasync)
    func renameAsync(_ desiredName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.deleteasync)
    func deleteAsync() throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.deleteasync)
    func deleteAsync(_ option: test_component.StorageDeleteOption) throws -> test_component.AnyIAsyncAction!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.getbasicpropertiesasync)
    func getBasicPropertiesAsync() throws -> test_component.AnyIAsyncOperation<test_component.BasicProperties?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.isoftype)
    func isOfType(_ type: test_component.StorageItemTypes) throws -> Bool
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.attributes)
    var attributes: test_component.FileAttributes { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.datecreated)
    var dateCreated: test_component.DateTime { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.name)
    var name: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.path)
    var path: String { get }
}

extension IStorageItem {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageItemWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageItem = any IStorageItem

// MARK: - IStorageItem Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageItemBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageItem
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageItem
        public typealias SwiftProjection = AnyIStorageItem
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageItemImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageItemVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageItemImpl: IStorageItem, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageItemBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.renameasync)
        fileprivate func renameAsync(_ desiredName: String) throws -> test_component.AnyIAsyncAction! {
            try _default.RenameAsyncOverloadDefaultOptions(desiredName)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.renameasync)
        fileprivate func renameAsync(_ desiredName: String, _ option: NameCollisionOption) throws -> test_component.AnyIAsyncAction! {
            try _default.RenameAsync(desiredName, option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.deleteasync)
        fileprivate func deleteAsync() throws -> test_component.AnyIAsyncAction! {
            try _default.DeleteAsyncOverloadDefaultOptions()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.deleteasync)
        fileprivate func deleteAsync(_ option: StorageDeleteOption) throws -> test_component.AnyIAsyncAction! {
            try _default.DeleteAsync(option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.getbasicpropertiesasync)
        fileprivate func getBasicPropertiesAsync() throws -> AnyIAsyncOperation<test_component.BasicProperties?>! {
            try _default.GetBasicPropertiesAsync()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.isoftype)
        fileprivate func isOfType(_ type: StorageItemTypes) throws -> Bool {
            try _default.IsOfType(type)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.attributes)
        fileprivate var attributes : FileAttributes {
            get { try! _default.get_Attributes() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.datecreated)
        fileprivate var dateCreated : test_component.DateTime {
            get { try! _default.get_DateCreated() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.name)
        fileprivate var name : String {
            get { try! _default.get_Name() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem.path)
        fileprivate var path : String {
            get { try! _default.get_Path() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageItem: test_component.IID = .init(
        Data1: 0x4207A996, Data2: 0xCA2F, Data3: 0x42F7, Data4: ( 0xBD,0xE8,0x8B,0x10,0x45,0x7A,0x7F,0x30 ) // 4207A996-CA2F-42F7-BDE8-8B10457A7F30
    ) 
    public class IStorageItem: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItem }

        open func RenameAsyncOverloadDefaultOptions(_ desiredName: String) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.RenameAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func RenameAsync(_ desiredName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.RenameAsync(pThis, _desiredName.get(), option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func DeleteAsyncOverloadDefaultOptions() throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DeleteAsyncOverloadDefaultOptions(pThis, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func DeleteAsync(_ option: test_component.StorageDeleteOption) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DeleteAsync(pThis, option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func GetBasicPropertiesAsync() throws -> test_component.AnyIAsyncOperation<test_component.BasicProperties?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetBasicPropertiesAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.unwrapFrom(abi: operation)
        }

        open func get_Name() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Name(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_Path() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Path(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_Attributes() throws -> test_component.FileAttributes {
            var value: __x_ABI_CWindows_CStorage_CFileAttributes = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Attributes(pThis, &value))
            }
            return value
        }

        open func get_DateCreated() throws -> test_component.DateTime {
            var value: __x_ABI_CWindows_CFoundation_CDateTime = .init()
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DateCreated(pThis, &value))
            }
            return .from(abi: value)
        }

        open func IsOfType(_ type: test_component.StorageItemTypes) throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.IsOfType(pThis, type, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageItemVTable: __x_ABI_CWindows_CStorage_CIStorageItemVtbl = .init(
        QueryInterface: { IStorageItemWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemWrapper.addRef($0) },
        Release: { IStorageItemWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItem").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        RenameAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.renameAsync(desiredName)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        RenameAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let option: test_component.NameCollisionOption = $2
                let operation = try __unwrapped__instance.renameAsync(desiredName, option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        DeleteAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.deleteAsync()
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        DeleteAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let option: test_component.StorageDeleteOption = $1
                let operation = try __unwrapped__instance.deleteAsync(option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetBasicPropertiesAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getBasicPropertiesAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        get_Name: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.name
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Path: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.path
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Attributes: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.attributes
            $1?.initialize(to: value)
            return S_OK
        },

        get_DateCreated: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.dateCreated
            $1?.initialize(to: .from(swift: value))
            return S_OK
        },

        IsOfType: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let type: test_component.StorageItemTypes = $1
                let value = try __unwrapped__instance.isOfType(type)
                $2?.initialize(to: .init(from: value))
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageItemWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemBridge>
}
@_spi(WinRTInternal)
public class IStorageItemMaker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageItem
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageItem = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageItemBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageItem2

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2)
public protocol IStorageItem2 : IStorageItem {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.getparentasync)
    func getParentAsync() throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.isequal)
    func isEqual(_ item: test_component.AnyIStorageItem!) throws -> Bool
}

extension IStorageItem2 {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageItem2Wrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItem2Wrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage.IStorageItemWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageItem2 = any IStorageItem2

// MARK: - IStorageItem2 Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageItem2Bridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageItem2
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageItem2
        public typealias SwiftProjection = AnyIStorageItem2
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageItem2Impl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageItem2VTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageItem2Impl: IStorageItem2, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageItem2Bridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.getparentasync)
        fileprivate func getParentAsync() throws -> AnyIAsyncOperation<StorageFolder?>! {
            try _default.GetParentAsync()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.isequal)
        fileprivate func isEqual(_ item: AnyIStorageItem!) throws -> Bool {
            try _default.IsEqual(item)
        }

        private lazy var _IStorageItem: __ABI_Windows_Storage.IStorageItem! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.renameasync)
        fileprivate func renameAsync(_ desiredName: String) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.RenameAsyncOverloadDefaultOptions(desiredName)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.renameasync)
        fileprivate func renameAsync(_ desiredName: String, _ option: NameCollisionOption) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.RenameAsync(desiredName, option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.deleteasync)
        fileprivate func deleteAsync() throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.DeleteAsyncOverloadDefaultOptions()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.deleteasync)
        fileprivate func deleteAsync(_ option: StorageDeleteOption) throws -> test_component.AnyIAsyncAction! {
            try _IStorageItem.DeleteAsync(option)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.getbasicpropertiesasync)
        fileprivate func getBasicPropertiesAsync() throws -> AnyIAsyncOperation<test_component.BasicProperties?>! {
            try _IStorageItem.GetBasicPropertiesAsync()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.isoftype)
        fileprivate func isOfType(_ type: StorageItemTypes) throws -> Bool {
            try _IStorageItem.IsOfType(type)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.attributes)
        fileprivate var attributes : FileAttributes {
            get { try! _IStorageItem.get_Attributes() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.datecreated)
        fileprivate var dateCreated : test_component.DateTime {
            get { try! _IStorageItem.get_DateCreated() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.name)
        fileprivate var name : String {
            get { try! _IStorageItem.get_Name() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitem2.path)
        fileprivate var path : String {
            get { try! _IStorageItem.get_Path() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageItem2: test_component.IID = .init(
        Data1: 0x53F926D2, Data2: 0x083C, Data3: 0x4283, Data4: ( 0xB4,0x5B,0x81,0xC0,0x07,0x23,0x7E,0x44 ) // 53F926D2-083C-4283-B45B-81C007237E44
    ) 
    public class IStorageItem2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItem2 }

        open func GetParentAsync() throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetParentAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func IsEqual(_ item: test_component.AnyIStorageItem?) throws -> Bool {
            var value: boolean = 0
            let itemWrapper = __ABI_Windows_Storage.IStorageItemWrapper(item)
            let _item = try! itemWrapper?.toABI { $0 }
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem2.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.IsEqual(pThis, _item, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageItem2VTable: __x_ABI_CWindows_CStorage_CIStorageItem2Vtbl = .init(
        QueryInterface: { IStorageItem2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItem2Wrapper.addRef($0) },
        Release: { IStorageItem2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItem2Wrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItem2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetParentAsync: {
            do {
                guard let __unwrapped__instance = IStorageItem2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getParentAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        IsEqual: {
            do {
                guard let __unwrapped__instance = IStorageItem2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let item: test_component.AnyIStorageItem? = __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: ComPtr($1))
                let value = try __unwrapped__instance.isEqual(item)
                $2?.initialize(to: .init(from: value))
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageItem2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItem2Bridge>
}
@_spi(WinRTInternal)
public class IStorageItem2Maker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageItem2
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageItem2 = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageItem2Bridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageItemProperties

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties)
public protocol IStorageItemProperties : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.getthumbnailasync)
    func getThumbnailAsync(_ mode: test_component.ThumbnailMode) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.getthumbnailasync)
    func getThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.getthumbnailasync)
    func getThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.displayname)
    var displayName: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.displaytype)
    var displayType: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.folderrelativeid)
    var folderRelativeId: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.properties)
    var properties: test_component.StorageItemContentProperties! { get }
}

extension IStorageItemProperties {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemPropertiesWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageItemProperties = any IStorageItemProperties

// MARK: - IStorageItemProperties Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageItemPropertiesBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageItemProperties
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageItemProperties
        public typealias SwiftProjection = AnyIStorageItemProperties
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageItemPropertiesImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageItemPropertiesVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageItemPropertiesImpl: IStorageItemProperties, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageItemPropertiesBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _default.GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(mode)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _default.GetThumbnailAsyncOverloadDefaultOptions(mode, requestedSize)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _default.GetThumbnailAsync(mode, requestedSize, options)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.displayname)
        fileprivate var displayName : String {
            get { try! _default.get_DisplayName() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.displaytype)
        fileprivate var displayType : String {
            get { try! _default.get_DisplayType() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.folderrelativeid)
        fileprivate var folderRelativeId : String {
            get { try! _default.get_FolderRelativeId() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties.properties)
        fileprivate var properties : test_component.StorageItemContentProperties! {
            get { try! _default.get_Properties() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageItemProperties: test_component.IID = .init(
        Data1: 0x86664478, Data2: 0x8029, Data3: 0x46FE, Data4: ( 0xA7,0x89,0x1C,0x2F,0x3E,0x2F,0xFB,0x5C ) // 86664478-8029-46FE-A789-1C2F3E2FFB5C
    ) 
    public class IStorageItemProperties: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemProperties }

        open func GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(_ mode: test_component.ThumbnailMode) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(pThis, mode, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetThumbnailAsyncOverloadDefaultOptions(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsyncOverloadDefaultOptions(pThis, mode, requestedSize, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsync(pThis, mode, requestedSize, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func get_DisplayName() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DisplayName(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_DisplayType() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DisplayType(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_FolderRelativeId() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_FolderRelativeId(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_Properties() throws -> test_component.StorageItemContentProperties? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.get_Properties(pThis, &valueAbi))
                }
            }
            return __IMPL_Windows_Storage_FileProperties.StorageItemContentPropertiesBridge.from(abi: value)
        }

    }

    internal static var IStorageItemPropertiesVTable: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesVtbl = .init(
        QueryInterface: { IStorageItemPropertiesWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemPropertiesWrapper.addRef($0) },
        Release: { IStorageItemPropertiesWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemProperties").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetThumbnailAsyncOverloadDefaultSizeDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let operation = try __unwrapped__instance.getThumbnailAsync(mode)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetThumbnailAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let operation = try __unwrapped__instance.getThumbnailAsync(mode, requestedSize)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetThumbnailAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let options: test_component.ThumbnailOptions = $3
                let operation = try __unwrapped__instance.getThumbnailAsync(mode, requestedSize, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        },

        get_DisplayName: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.displayName
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_DisplayType: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.displayType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_FolderRelativeId: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.folderRelativeId
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Properties: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.properties
            value?.copyTo($1)
            return S_OK
        }
    )

    public typealias IStorageItemPropertiesWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemPropertiesBridge>
}
@_spi(WinRTInternal)
public class IStorageItemPropertiesMaker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageItemProperties
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageItemProperties = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageItemPropertiesBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageItemProperties2

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2)
public protocol IStorageItemProperties2 : IStorageItemProperties {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getscaledimageasthumbnailasync)
    func getScaledImageAsThumbnailAsync(_ mode: test_component.ThumbnailMode) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getscaledimageasthumbnailasync)
    func getScaledImageAsThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getscaledimageasthumbnailasync)
    func getScaledImageAsThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>!
}

extension IStorageItemProperties2 {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageItemProperties2Wrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemProperties2Wrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemPropertiesWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageItemProperties2 = any IStorageItemProperties2

// MARK: - IStorageItemProperties2 Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageItemProperties2Bridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageItemProperties2
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageItemProperties2
        public typealias SwiftProjection = AnyIStorageItemProperties2
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageItemProperties2Impl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageItemProperties2VTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageItemProperties2Impl: IStorageItemProperties2, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageItemProperties2Bridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getscaledimageasthumbnailasync)
        fileprivate func getScaledImageAsThumbnailAsync(_ mode: test_component.ThumbnailMode) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _default.GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(mode)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getscaledimageasthumbnailasync)
        fileprivate func getScaledImageAsThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _default.GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(mode, requestedSize)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getscaledimageasthumbnailasync)
        fileprivate func getScaledImageAsThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _default.GetScaledImageAsThumbnailAsync(mode, requestedSize, options)
        }

        private lazy var _IStorageItemProperties: __ABI_Windows_Storage.IStorageItemProperties! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _IStorageItemProperties.GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(mode)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _IStorageItemProperties.GetThumbnailAsyncOverloadDefaultOptions(mode, requestedSize)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _IStorageItemProperties.GetThumbnailAsync(mode, requestedSize, options)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.displayname)
        fileprivate var displayName : String {
            get { try! _IStorageItemProperties.get_DisplayName() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.displaytype)
        fileprivate var displayType : String {
            get { try! _IStorageItemProperties.get_DisplayType() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.folderrelativeid)
        fileprivate var folderRelativeId : String {
            get { try! _IStorageItemProperties.get_FolderRelativeId() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitemproperties2.properties)
        fileprivate var properties : test_component.StorageItemContentProperties! {
            get { try! _IStorageItemProperties.get_Properties() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageItemProperties2: test_component.IID = .init(
        Data1: 0x8E86A951, Data2: 0x04B9, Data3: 0x4BD2, Data4: ( 0x92,0x9D,0xFE,0xF3,0xF7,0x16,0x21,0xD0 ) // 8E86A951-04B9-4BD2-929D-FEF3F71621D0
    ) 
    public class IStorageItemProperties2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemProperties2 }

        open func GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(_ mode: test_component.ThumbnailMode) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(pThis, mode, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(pThis, mode, requestedSize, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetScaledImageAsThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsync(pThis, mode, requestedSize, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageItemProperties2VTable: __x_ABI_CWindows_CStorage_CIStorageItemProperties2Vtbl = .init(
        QueryInterface: { IStorageItemProperties2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemProperties2Wrapper.addRef($0) },
        Release: { IStorageItemProperties2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemProperties2Wrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemProperties2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetScaledImageAsThumbnailAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode, requestedSize)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetScaledImageAsThumbnailAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let options: test_component.ThumbnailOptions = $3
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode, requestedSize, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageItemProperties2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemProperties2Bridge>
}
@_spi(WinRTInternal)
public class IStorageItemProperties2Maker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageItemProperties2
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageItemProperties2 = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageItemProperties2Bridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStorageItemPropertiesWithProvider

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider)
public protocol IStorageItemPropertiesWithProvider : IStorageItemProperties {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.provider)
    var provider: test_component.StorageProvider! { get }
}

extension IStorageItemPropertiesWithProvider {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStorageItemPropertiesWithProviderWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemPropertiesWithProviderWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStorageItemPropertiesWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStorageItemPropertiesWithProvider = any IStorageItemPropertiesWithProvider

// MARK: - IStorageItemPropertiesWithProvider Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStorageItemPropertiesWithProviderBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider
        public typealias SwiftABI = __ABI_Windows_Storage.IStorageItemPropertiesWithProvider
        public typealias SwiftProjection = AnyIStorageItemPropertiesWithProvider
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStorageItemPropertiesWithProviderImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStorageItemPropertiesWithProviderVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStorageItemPropertiesWithProviderImpl: IStorageItemPropertiesWithProvider, WinRTAbiImpl {
        fileprivate typealias Bridge = IStorageItemPropertiesWithProviderBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.provider)
        fileprivate var provider : StorageProvider! {
            get { try! _default.get_Provider() }
        }

        private lazy var _IStorageItemProperties: __ABI_Windows_Storage.IStorageItemProperties! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _IStorageItemProperties.GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(mode)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _IStorageItemProperties.GetThumbnailAsyncOverloadDefaultOptions(mode, requestedSize)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.getthumbnailasync)
        fileprivate func getThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> AnyIAsyncOperation<test_component.StorageItemThumbnail?>! {
            try _IStorageItemProperties.GetThumbnailAsync(mode, requestedSize, options)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.displayname)
        fileprivate var displayName : String {
            get { try! _IStorageItemProperties.get_DisplayName() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.displaytype)
        fileprivate var displayType : String {
            get { try! _IStorageItemProperties.get_DisplayType() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.folderrelativeid)
        fileprivate var folderRelativeId : String {
            get { try! _IStorageItemProperties.get_FolderRelativeId() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istorageitempropertieswithprovider.properties)
        fileprivate var properties : test_component.StorageItemContentProperties! {
            get { try! _IStorageItemProperties.get_Properties() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider: test_component.IID = .init(
        Data1: 0x861BF39B, Data2: 0x6368, Data3: 0x4DEE, Data4: ( 0xB4,0x0E,0x74,0x68,0x4A,0x5C,0xE7,0x14 ) // 861BF39B-6368-4DEE-B40E-74684A5CE714
    ) 
    public class IStorageItemPropertiesWithProvider: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider }

        open func get_Provider() throws -> test_component.StorageProvider? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.get_Provider(pThis, &valueAbi))
                }
            }
            return __IMPL_Windows_Storage.StorageProviderBridge.from(abi: value)
        }

    }

    internal static var IStorageItemPropertiesWithProviderVTable: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProviderVtbl = .init(
        QueryInterface: { IStorageItemPropertiesWithProviderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemPropertiesWithProviderWrapper.addRef($0) },
        Release: { IStorageItemPropertiesWithProviderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemPropertiesWithProviderWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemPropertiesWithProvider").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Provider: {
            guard let __unwrapped__instance = IStorageItemPropertiesWithProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.provider
            value?.copyTo($1)
            return S_OK
        }
    )

    public typealias IStorageItemPropertiesWithProviderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemPropertiesWithProviderBridge>
}
@_spi(WinRTInternal)
public class IStorageItemPropertiesWithProviderMaker: MakeFromAbi {
    public typealias SwiftType = AnyIStorageItemPropertiesWithProvider
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStorageItemPropertiesWithProvider = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStorageItemPropertiesWithProviderBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IStreamedFileDataRequest

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istreamedfiledatarequest)
public protocol IStreamedFileDataRequest : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istreamedfiledatarequest.failandclose)
    func failAndClose(_ failureMode: test_component.StreamedFileFailureMode) throws
}

extension IStreamedFileDataRequest {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage.IStreamedFileDataRequestWrapper.IID:
                let wrapper = __ABI_Windows_Storage.IStreamedFileDataRequestWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIStreamedFileDataRequest = any IStreamedFileDataRequest

// MARK: - IStreamedFileDataRequest Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage {
    public enum IStreamedFileDataRequestBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CIStreamedFileDataRequest
        public typealias SwiftABI = __ABI_Windows_Storage.IStreamedFileDataRequest
        public typealias SwiftProjection = AnyIStreamedFileDataRequest
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IStreamedFileDataRequestImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.IStreamedFileDataRequestVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IStreamedFileDataRequestImpl: IStreamedFileDataRequest, WinRTAbiImpl {
        fileprivate typealias Bridge = IStreamedFileDataRequestBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.istreamedfiledatarequest.failandclose)
        fileprivate func failAndClose(_ failureMode: StreamedFileFailureMode) throws {
            try _default.FailAndClose(failureMode)
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage {
    private static let IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequest: test_component.IID = .init(
        Data1: 0x1673FCCE, Data2: 0xDABD, Data3: 0x4D50, Data4: ( 0xBE,0xEE,0x18,0x0B,0x8A,0x81,0x91,0xB6 ) // 1673FCCE-DABD-4D50-BEEE-180B8A8191B6
    ) 
    public class IStreamedFileDataRequest: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequest }

        open func FailAndClose(_ failureMode: test_component.StreamedFileFailureMode) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequest.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.FailAndClose(pThis, failureMode))
            }
        }

    }

    internal static var IStreamedFileDataRequestVTable: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestVtbl = .init(
        QueryInterface: { IStreamedFileDataRequestWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStreamedFileDataRequestWrapper.addRef($0) },
        Release: { IStreamedFileDataRequestWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStreamedFileDataRequestWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStreamedFileDataRequest").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        FailAndClose: {
            do {
                guard let __unwrapped__instance = IStreamedFileDataRequestWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let failureMode: test_component.StreamedFileFailureMode = $1
                try __unwrapped__instance.failAndClose(failureMode)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStreamedFileDataRequestWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStreamedFileDataRequestBridge>
}
@_spi(WinRTInternal)
public class IStreamedFileDataRequestMaker: MakeFromAbi {
    public typealias SwiftType = AnyIStreamedFileDataRequest
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage.IStreamedFileDataRequest = try! abi.QueryInterface()
        return __IMPL_Windows_Storage.IStreamedFileDataRequestBridge.from(abi: RawPointer(swiftAbi))!
    }
}
