// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
import Ctest_component

private var IID___x_ABI_CWindows_CStorage_CIPathIOStatics: test_component.IID {
    .init(Data1: 0x0F2F3758, Data2: 0x8EC7, Data3: 0x4381, Data4: ( 0x92,0x2B,0x8F,0x6C,0x07,0xD2,0x88,0xF3 ))// 0F2F3758-8EC7-4381-922B-8F6C07D288F3
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFile: test_component.IID {
    .init(Data1: 0xFA3F6186, Data2: 0x4214, Data3: 0x428C, Data4: ( 0xA6,0x4C,0x14,0xC9,0xAC,0x73,0x15,0xEA ))// FA3F6186-4214-428C-A64C-14C9AC7315EA
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFile2: test_component.IID {
    .init(Data1: 0x954E4BCF, Data2: 0x0A77, Data3: 0x42FB, Data4: ( 0xB7,0x77,0xC2,0xED,0x58,0xA5,0x2E,0x44 ))// 954E4BCF-0A77-42FB-B777-C2ED58A52E44
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability: test_component.IID {
    .init(Data1: 0xAFCBBE9B, Data2: 0x582B, Data3: 0x4133, Data4: ( 0x96,0x48,0xE4,0x4C,0xA4,0x6E,0xE4,0x91 ))// AFCBBE9B-582B-4133-9648-E44CA46EE491
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFileStatics: test_component.IID {
    .init(Data1: 0x5984C710, Data2: 0xDAF2, Data3: 0x43C8, Data4: ( 0x8B,0xB4,0xA4,0xD3,0xEA,0xCF,0xD0,0x3F ))// 5984C710-DAF2-43C8-8BB4-A4D3EACFD03F
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFolder: test_component.IID {
    .init(Data1: 0x72D1CB78, Data2: 0xB3EF, Data3: 0x4F75, Data4: ( 0xA8,0x0B,0x6F,0xD9,0xDA,0xE2,0x94,0x4B ))// 72D1CB78-B3EF-4F75-A80B-6FD9DAE2944B
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFolder2: test_component.IID {
    .init(Data1: 0xE827E8B9, Data2: 0x08D9, Data3: 0x4A8E, Data4: ( 0xA0,0xAC,0xFE,0x5E,0xD3,0xCB,0xBB,0xD3 ))// E827E8B9-08D9-4A8E-A0AC-FE5ED3CBBBD3
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFolder3: test_component.IID {
    .init(Data1: 0x9F617899, Data2: 0xBDE1, Data3: 0x4124, Data4: ( 0xAE,0xB3,0xB0,0x6A,0xD9,0x6F,0x98,0xD4 ))// 9F617899-BDE1-4124-AEB3-B06AD96F98D4
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFolderStatics: test_component.IID {
    .init(Data1: 0x08F327FF, Data2: 0x85D5, Data3: 0x48B9, Data4: ( 0xAE,0xE9,0x28,0x51,0x1E,0x33,0x9F,0x9F ))// 08F327FF-85D5-48B9-AEE9-28511E339F9F
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItem: test_component.IID {
    .init(Data1: 0x4207A996, Data2: 0xCA2F, Data3: 0x42F7, Data4: ( 0xBD,0xE8,0x8B,0x10,0x45,0x7A,0x7F,0x30 ))// 4207A996-CA2F-42F7-BDE8-8B10457A7F30
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItem2: test_component.IID {
    .init(Data1: 0x53F926D2, Data2: 0x083C, Data3: 0x4283, Data4: ( 0xB4,0x5B,0x81,0xC0,0x07,0x23,0x7E,0x44 ))// 53F926D2-083C-4283-B45B-81C007237E44
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItemProperties: test_component.IID {
    .init(Data1: 0x86664478, Data2: 0x8029, Data3: 0x46FE, Data4: ( 0xA7,0x89,0x1C,0x2F,0x3E,0x2F,0xFB,0x5C ))// 86664478-8029-46FE-A789-1C2F3E2FFB5C
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItemProperties2: test_component.IID {
    .init(Data1: 0x8E86A951, Data2: 0x04B9, Data3: 0x4BD2, Data4: ( 0x92,0x9D,0xFE,0xF3,0xF7,0x16,0x21,0xD0 ))// 8E86A951-04B9-4BD2-929D-FEF3F71621D0
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider: test_component.IID {
    .init(Data1: 0x861BF39B, Data2: 0x6368, Data3: 0x4DEE, Data4: ( 0xB4,0x0E,0x74,0x68,0x4A,0x5C,0xE7,0x14 ))// 861BF39B-6368-4DEE-B40E-74684A5CE714
}

private var IID___x_ABI_CWindows_CStorage_CIStorageLibraryChange: test_component.IID {
    .init(Data1: 0x00980B23, Data2: 0x2BE2, Data3: 0x4909, Data4: ( 0xAA,0x48,0x15,0x9F,0x52,0x03,0xA5,0x1E ))// 00980B23-2BE2-4909-AA48-159F5203A51E
}

private var IID___x_ABI_CWindows_CStorage_CIStorageLibraryChangeReader: test_component.IID {
    .init(Data1: 0xF205BC83, Data2: 0xFCA2, Data3: 0x41F9, Data4: ( 0x89,0x54,0xEE,0x2E,0x99,0x1E,0xB9,0x6F ))// F205BC83-FCA2-41F9-8954-EE2E991EB96F
}

private var IID___x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker: test_component.IID {
    .init(Data1: 0x9E157316, Data2: 0x6073, Data3: 0x44F6, Data4: ( 0x96,0x81,0x74,0x92,0xD1,0x28,0x6C,0x90 ))// 9E157316-6073-44F6-9681-7492D1286C90
}

private var IID___x_ABI_CWindows_CStorage_CIStorageProvider: test_component.IID {
    .init(Data1: 0xE705EED4, Data2: 0xD478, Data3: 0x47D6, Data4: ( 0xBA,0x46,0x1A,0x8E,0xBE,0x11,0x4A,0x20 ))// E705EED4-D478-47D6-BA46-1A8EBE114A20
}

private var IID___x_ABI_CWindows_CStorage_CIStorageProvider2: test_component.IID {
    .init(Data1: 0x010D1917, Data2: 0x3404, Data3: 0x414B, Data4: ( 0x9F,0xD7,0xCD,0x44,0x47,0x2E,0xAA,0x39 ))// 010D1917-3404-414B-9FD7-CD44472EAA39
}

private var IID___x_ABI_CWindows_CStorage_CIStorageStreamTransaction: test_component.IID {
    .init(Data1: 0xF67CF363, Data2: 0xA53D, Data3: 0x4D94, Data4: ( 0xAE,0x2C,0x67,0x23,0x2D,0x93,0xAC,0xDD ))// F67CF363-A53D-4D94-AE2C-67232D93ACDD
}

private var IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequest: test_component.IID {
    .init(Data1: 0x1673FCCE, Data2: 0xDABD, Data3: 0x4D50, Data4: ( 0xBE,0xEE,0x18,0x0B,0x8A,0x81,0x91,0xB6 ))// 1673FCCE-DABD-4D50-BEEE-180B8A8191B6
}

private var IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandler: test_component.IID {
    .init(Data1: 0xFEF6A824, Data2: 0x2FE1, Data3: 0x4D07, Data4: ( 0xA3,0x5B,0xB7,0x7C,0x50,0xB5,0xF4,0xCC ))// FEF6A824-2FE1-4D07-A35B-B77C50B5F4CC
}

@_spi(WinRTInternal)
public enum __ABI_Windows_Storage {
    public class IPathIOStatics: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIPathIOStatics }

        public func ReadTextAsync(_ absolutePath: String) throws -> test_component.AnyIAsyncOperation<String>? {
            let (textOperation) = try ComPtrs.initialize { textOperationAbi in
                let _absolutePath = try! HString(absolutePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadTextAsync(pThis, _absolutePath.get(), &textOperationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.unwrapFrom(abi: textOperation)
        }

        public func ReadTextWithEncodingAsync(_ absolutePath: String, _ encoding: test_component.UnicodeEncoding) throws -> test_component.AnyIAsyncOperation<String>? {
            let (textOperation) = try ComPtrs.initialize { textOperationAbi in
                let _absolutePath = try! HString(absolutePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadTextWithEncodingAsync(pThis, _absolutePath.get(), encoding, &textOperationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.unwrapFrom(abi: textOperation)
        }

        public func WriteTextAsync(_ absolutePath: String, _ contents: String) throws -> test_component.AnyIAsyncAction? {
            let (textOperation) = try ComPtrs.initialize { textOperationAbi in
                let _absolutePath = try! HString(absolutePath)
                let _contents = try! HString(contents)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.WriteTextAsync(pThis, _absolutePath.get(), _contents.get(), &textOperationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: textOperation)
        }

        public func WriteTextWithEncodingAsync(_ absolutePath: String, _ contents: String, _ encoding: test_component.UnicodeEncoding) throws -> test_component.AnyIAsyncAction? {
            let (textOperation) = try ComPtrs.initialize { textOperationAbi in
                let _absolutePath = try! HString(absolutePath)
                let _contents = try! HString(contents)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.WriteTextWithEncodingAsync(pThis, _absolutePath.get(), _contents.get(), encoding, &textOperationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: textOperation)
        }

        public func AppendTextAsync(_ absolutePath: String, _ contents: String) throws -> test_component.AnyIAsyncAction? {
            let (textOperation) = try ComPtrs.initialize { textOperationAbi in
                let _absolutePath = try! HString(absolutePath)
                let _contents = try! HString(contents)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.AppendTextAsync(pThis, _absolutePath.get(), _contents.get(), &textOperationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: textOperation)
        }

        public func AppendTextWithEncodingAsync(_ absolutePath: String, _ contents: String, _ encoding: test_component.UnicodeEncoding) throws -> test_component.AnyIAsyncAction? {
            let (textOperation) = try ComPtrs.initialize { textOperationAbi in
                let _absolutePath = try! HString(absolutePath)
                let _contents = try! HString(contents)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.AppendTextWithEncodingAsync(pThis, _absolutePath.get(), _contents.get(), encoding, &textOperationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: textOperation)
        }

        public func ReadLinesAsync(_ absolutePath: String) throws -> test_component.AnyIAsyncOperation<test_component.AnyIVector<String>?>? {
            let (linesOperation) = try ComPtrs.initialize { linesOperationAbi in
                let _absolutePath = try! HString(absolutePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadLinesAsync(pThis, _absolutePath.get(), &linesOperationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: linesOperation)
        }

        public func ReadLinesWithEncodingAsync(_ absolutePath: String, _ encoding: test_component.UnicodeEncoding) throws -> test_component.AnyIAsyncOperation<test_component.AnyIVector<String>?>? {
            let (linesOperation) = try ComPtrs.initialize { linesOperationAbi in
                let _absolutePath = try! HString(absolutePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadLinesWithEncodingAsync(pThis, _absolutePath.get(), encoding, &linesOperationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: linesOperation)
        }

        public func WriteLinesAsync(_ absolutePath: String, _ lines: test_component.AnyIIterable<String>?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _absolutePath = try! HString(absolutePath)
                let linesWrapper = test_component.__x_ABI_C__FIIterable_1_HSTRINGWrapper(lines)
                let _lines = try! linesWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.WriteLinesAsync(pThis, _absolutePath.get(), _lines, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        public func WriteLinesWithEncodingAsync(_ absolutePath: String, _ lines: test_component.AnyIIterable<String>?, _ encoding: test_component.UnicodeEncoding) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _absolutePath = try! HString(absolutePath)
                let linesWrapper = test_component.__x_ABI_C__FIIterable_1_HSTRINGWrapper(lines)
                let _lines = try! linesWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.WriteLinesWithEncodingAsync(pThis, _absolutePath.get(), _lines, encoding, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        public func AppendLinesAsync(_ absolutePath: String, _ lines: test_component.AnyIIterable<String>?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _absolutePath = try! HString(absolutePath)
                let linesWrapper = test_component.__x_ABI_C__FIIterable_1_HSTRINGWrapper(lines)
                let _lines = try! linesWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.AppendLinesAsync(pThis, _absolutePath.get(), _lines, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        public func AppendLinesWithEncodingAsync(_ absolutePath: String, _ lines: test_component.AnyIIterable<String>?, _ encoding: test_component.UnicodeEncoding) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _absolutePath = try! HString(absolutePath)
                let linesWrapper = test_component.__x_ABI_C__FIIterable_1_HSTRINGWrapper(lines)
                let _lines = try! linesWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.AppendLinesWithEncodingAsync(pThis, _absolutePath.get(), _lines, encoding, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        public func ReadBufferAsync(_ absolutePath: String) throws -> test_component.AnyIAsyncOperation<test_component.AnyIBuffer?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _absolutePath = try! HString(absolutePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadBufferAsync(pThis, _absolutePath.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.unwrapFrom(abi: operation)
        }

        public func WriteBufferAsync(_ absolutePath: String, _ buffer: test_component.AnyIBuffer?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _absolutePath = try! HString(absolutePath)
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                let _buffer = try! bufferWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.WriteBufferAsync(pThis, _absolutePath.get(), _buffer, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        public func WriteBytesAsync(_ absolutePath: String, _ buffer: [UInt8]) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _absolutePath = try! HString(absolutePath)
                try buffer.toABI { _buffer in
                    _ = try perform(as: __x_ABI_CWindows_CStorage_CIPathIOStatics.self) { pThis in
                        try CHECKED(pThis.pointee.lpVtbl.pointee.WriteBytesAsync(pThis, _absolutePath.get(), _buffer.count, _buffer.start, &operationAbi))
                    }
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageFile: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFile }

        open func get_FileType() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_FileType(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_ContentType() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ContentType(pThis, &value))
            }
            return .init(from: value)
        }

        open func OpenAsync(_ accessMode: test_component.FileAccessMode) throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenAsync(pThis, accessMode, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        open func OpenTransactedWriteAsync() throws -> test_component.AnyIAsyncOperation<test_component.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverloadDefaultNameAndOptions(_ destinationFolder: test_component.AnyIStorageFolder?) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverloadDefaultNameAndOptions(pThis, _destinationFolder, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverloadDefaultOptions(_ destinationFolder: test_component.AnyIStorageFolder?, _ desiredNewName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverloadDefaultOptions(pThis, _destinationFolder, _desiredNewName.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverload(_ destinationFolder: test_component.AnyIStorageFolder?, _ desiredNewName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverload(pThis, _destinationFolder, _desiredNewName.get(), option, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyAndReplaceAsync(_ fileToReplace: test_component.AnyIStorageFile?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyAndReplaceAsync(pThis, _fileToReplace, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverloadDefaultNameAndOptions(_ destinationFolder: test_component.AnyIStorageFolder?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverloadDefaultNameAndOptions(pThis, _destinationFolder, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverloadDefaultOptions(_ destinationFolder: test_component.AnyIStorageFolder?, _ desiredNewName: String) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverloadDefaultOptions(pThis, _destinationFolder, _desiredNewName.get(), &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverload(_ destinationFolder: test_component.AnyIStorageFolder?, _ desiredNewName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverload(pThis, _destinationFolder, _desiredNewName.get(), option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveAndReplaceAsync(_ fileToReplace: test_component.AnyIStorageFile?) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveAndReplaceAsync(pThis, _fileToReplace, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFileVTable: __x_ABI_CWindows_CStorage_CIStorageFileVtbl = .init(
        QueryInterface: { IStorageFileWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFileWrapper.addRef($0) },
        Release: { IStorageFileWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 6).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFileWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper.IID
            $1!.pointee = 6
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFile").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_FileType: {
            guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.fileType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_ContentType: {
            guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.contentType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        OpenAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let accessMode: test_component.FileAccessMode = $1
                let operation = try __unwrapped__instance.openAsync(accessMode)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        OpenTransactedWriteAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openTransactedWriteAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CopyOverloadDefaultNameAndOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.copyAsync(destinationFolder)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CopyOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let operation = try __unwrapped__instance.copyAsync(destinationFolder, desiredNewName)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CopyOverload: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let option: test_component.NameCollisionOption = $3
                let operation = try __unwrapped__instance.copyAsync(destinationFolder, desiredNewName, option)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CopyAndReplaceAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let fileToReplace: test_component.AnyIStorageFile? = __ABI_Windows_Storage.IStorageFileWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.copyAndReplaceAsync(fileToReplace)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        MoveOverloadDefaultNameAndOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.moveAsync(destinationFolder)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        MoveOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let operation = try __unwrapped__instance.moveAsync(destinationFolder, desiredNewName)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        MoveOverload: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: test_component.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let option: test_component.NameCollisionOption = $3
                let operation = try __unwrapped__instance.moveAsync(destinationFolder, desiredNewName, option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        },

        MoveAndReplaceAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let fileToReplace: test_component.AnyIStorageFile? = __ABI_Windows_Storage.IStorageFileWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.moveAndReplaceAsync(fileToReplace)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageFileWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFileBridge>
    public class IStorageFile2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFile2 }

        open func OpenWithOptionsAsync(_ accessMode: test_component.FileAccessMode, _ options: test_component.StorageOpenOptions) throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenWithOptionsAsync(pThis, accessMode, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        open func OpenTransactedWriteWithOptionsAsync(_ options: test_component.StorageOpenOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteWithOptionsAsync(pThis, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFile2VTable: __x_ABI_CWindows_CStorage_CIStorageFile2Vtbl = .init(
        QueryInterface: { IStorageFile2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFile2Wrapper.addRef($0) },
        Release: { IStorageFile2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFile2Wrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFile2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenWithOptionsAsync: {
            do {
                guard let __unwrapped__instance = IStorageFile2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let accessMode: test_component.FileAccessMode = $1
                let options: test_component.StorageOpenOptions = $2
                let operation = try __unwrapped__instance.openAsync(accessMode, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        OpenTransactedWriteWithOptionsAsync: {
            do {
                guard let __unwrapped__instance = IStorageFile2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let options: test_component.StorageOpenOptions = $1
                let operation = try __unwrapped__instance.openTransactedWriteAsync(options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageFile2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFile2Bridge>
    public class IStorageFilePropertiesWithAvailability: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability }

        open func get_IsAvailable() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_IsAvailable(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageFilePropertiesWithAvailabilityVTable: __x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailabilityVtbl = .init(
        QueryInterface: { IStorageFilePropertiesWithAvailabilityWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFilePropertiesWithAvailabilityWrapper.addRef($0) },
        Release: { IStorageFilePropertiesWithAvailabilityWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFilePropertiesWithAvailabilityWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFilePropertiesWithAvailability").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_IsAvailable: {
            guard let __unwrapped__instance = IStorageFilePropertiesWithAvailabilityWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.isAvailable
            $1?.initialize(to: .init(from: value))
            return S_OK
        }
    )

    public typealias IStorageFilePropertiesWithAvailabilityWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFilePropertiesWithAvailabilityBridge>
    public class IStorageFileStatics: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFileStatics }

        public func GetFileFromPathAsync(_ path: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _path = try! HString(path)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileFromPathAsync(pThis, _path.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        public func GetFileFromApplicationUriAsync(_ uri: test_component.Uri?) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileFromApplicationUriAsync(pThis, RawPointer(uri), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        public func CreateStreamedFileAsync(_ displayNameWithExtension: String, _ dataRequested: test_component.StreamedFileDataRequestedHandler?, _ thumbnail: test_component.AnyIRandomAccessStreamReference?) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _displayNameWithExtension = try! HString(displayNameWithExtension)
                let dataRequestedWrapper = __ABI_Windows_Storage.StreamedFileDataRequestedHandlerWrapper(dataRequested)
                let _dataRequested = try! dataRequestedWrapper?.toABI { $0 }
                let thumbnailWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(thumbnail)
                let _thumbnail = try! thumbnailWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateStreamedFileAsync(pThis, _displayNameWithExtension.get(), _dataRequested, _thumbnail, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        public func ReplaceWithStreamedFileAsync(_ fileToReplace: test_component.AnyIStorageFile?, _ dataRequested: test_component.StreamedFileDataRequestedHandler?, _ thumbnail: test_component.AnyIRandomAccessStreamReference?) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                let dataRequestedWrapper = __ABI_Windows_Storage.StreamedFileDataRequestedHandlerWrapper(dataRequested)
                let _dataRequested = try! dataRequestedWrapper?.toABI { $0 }
                let thumbnailWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(thumbnail)
                let _thumbnail = try! thumbnailWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReplaceWithStreamedFileAsync(pThis, _fileToReplace, _dataRequested, _thumbnail, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        public func CreateStreamedFileFromUriAsync(_ displayNameWithExtension: String, _ uri: test_component.Uri?, _ thumbnail: test_component.AnyIRandomAccessStreamReference?) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _displayNameWithExtension = try! HString(displayNameWithExtension)
                let thumbnailWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(thumbnail)
                let _thumbnail = try! thumbnailWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateStreamedFileFromUriAsync(pThis, _displayNameWithExtension.get(), RawPointer(uri), _thumbnail, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        public func ReplaceWithStreamedFileFromUriAsync(_ fileToReplace: test_component.AnyIStorageFile?, _ uri: test_component.Uri?, _ thumbnail: test_component.AnyIRandomAccessStreamReference?) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                let thumbnailWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(thumbnail)
                let _thumbnail = try! thumbnailWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReplaceWithStreamedFileFromUriAsync(pThis, _fileToReplace, RawPointer(uri), _thumbnail, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageFolder: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolder }

        open func CreateFileAsyncOverloadDefaultOptions(_ desiredName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFileAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFileAsync(_ desiredName: String, _ options: test_component.CreationCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFileAsync(pThis, _desiredName.get(), options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFolderAsyncOverloadDefaultOptions(_ desiredName: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFolderAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFolderAsync(_ desiredName: String, _ options: test_component.CreationCollisionOption) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFolderAsync(pThis, _desiredName.get(), options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetFileAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func GetFolderAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFolderAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetItemAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.AnyIStorageItem?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetItemAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

        open func GetFilesAsyncOverloadDefaultOptionsStartAndCount() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.StorageFile?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFilesAsyncOverloadDefaultOptionsStartAndCount(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func GetFoldersAsyncOverloadDefaultOptionsStartAndCount() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.StorageFolder?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFoldersAsyncOverloadDefaultOptionsStartAndCount(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetItemsAsyncOverloadDefaultStartAndCount() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.AnyIStorageItem?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetItemsAsyncOverloadDefaultStartAndCount(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFolderVTable: __x_ABI_CWindows_CStorage_CIStorageFolderVtbl = .init(
        QueryInterface: { IStorageFolderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFolderWrapper.addRef($0) },
        Release: { IStorageFolderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFolderWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFolder").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        CreateFileAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.createFileAsync(desiredName)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CreateFileAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let options: test_component.CreationCollisionOption = $2
                let operation = try __unwrapped__instance.createFileAsync(desiredName, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CreateFolderAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.createFolderAsync(desiredName)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CreateFolderAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let options: test_component.CreationCollisionOption = $2
                let operation = try __unwrapped__instance.createFolderAsync(desiredName, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetFileAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getFileAsync(name)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetFolderAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getFolderAsync(name)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetItemAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getItemAsync(name)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetFilesAsyncOverloadDefaultOptionsStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getFilesAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetFoldersAsyncOverloadDefaultOptionsStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getFoldersAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetItemsAsyncOverloadDefaultStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getItemsAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageFolderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFolderBridge>
    public class IStorageFolder2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolder2 }

        open func TryGetItemAsync(_ name: String) throws -> test_component.AnyIAsyncOperation<test_component.AnyIStorageItem?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.TryGetItemAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFolder2VTable: __x_ABI_CWindows_CStorage_CIStorageFolder2Vtbl = .init(
        QueryInterface: { IStorageFolder2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFolder2Wrapper.addRef($0) },
        Release: { IStorageFolder2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFolder2Wrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFolder2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        TryGetItemAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolder2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.tryGetItemAsync(name)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageFolder2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFolder2Bridge>
    public class IStorageFolder3: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolder3 }

        public func TryGetChangeTracker() throws -> test_component.StorageLibraryChangeTracker? {
            let (result) = try ComPtrs.initialize { resultAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder3.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.TryGetChangeTracker(pThis, &resultAbi))
                }
            }
            return __IMPL_Windows_Storage.StorageLibraryChangeTrackerBridge.from(abi: result)
        }

    }

    public class IStorageFolderStatics: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolderStatics }

        public func GetFolderFromPathAsync(_ path: String) throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _path = try! HString(path)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolderStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFolderFromPathAsync(pThis, _path.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageItem: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItem }

        open func RenameAsyncOverloadDefaultOptions(_ desiredName: String) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.RenameAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func RenameAsync(_ desiredName: String, _ option: test_component.NameCollisionOption) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.RenameAsync(pThis, _desiredName.get(), option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func DeleteAsyncOverloadDefaultOptions() throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DeleteAsyncOverloadDefaultOptions(pThis, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func DeleteAsync(_ option: test_component.StorageDeleteOption) throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DeleteAsync(pThis, option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func GetBasicPropertiesAsync() throws -> test_component.AnyIAsyncOperation<test_component.BasicProperties?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetBasicPropertiesAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.unwrapFrom(abi: operation)
        }

        open func get_Name() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Name(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_Path() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Path(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_Attributes() throws -> test_component.FileAttributes {
            var value: __x_ABI_CWindows_CStorage_CFileAttributes = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Attributes(pThis, &value))
            }
            return value
        }

        open func get_DateCreated() throws -> test_component.DateTime {
            var value: __x_ABI_CWindows_CFoundation_CDateTime = .init()
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DateCreated(pThis, &value))
            }
            return .from(abi: value)
        }

        open func IsOfType(_ type: test_component.StorageItemTypes) throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.IsOfType(pThis, type, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageItemVTable: __x_ABI_CWindows_CStorage_CIStorageItemVtbl = .init(
        QueryInterface: { IStorageItemWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemWrapper.addRef($0) },
        Release: { IStorageItemWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItem").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        RenameAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.renameAsync(desiredName)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        RenameAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let option: test_component.NameCollisionOption = $2
                let operation = try __unwrapped__instance.renameAsync(desiredName, option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        DeleteAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.deleteAsync()
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        DeleteAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let option: test_component.StorageDeleteOption = $1
                let operation = try __unwrapped__instance.deleteAsync(option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetBasicPropertiesAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getBasicPropertiesAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        get_Name: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.name
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Path: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.path
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Attributes: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.attributes
            $1?.initialize(to: value)
            return S_OK
        },

        get_DateCreated: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.dateCreated
            $1?.initialize(to: .from(swift: value))
            return S_OK
        },

        IsOfType: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let type: test_component.StorageItemTypes = $1
                let value = try __unwrapped__instance.isOfType(type)
                $2?.initialize(to: .init(from: value))
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageItemWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemBridge>
    public class IStorageItem2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItem2 }

        open func GetParentAsync() throws -> test_component.AnyIAsyncOperation<test_component.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetParentAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func IsEqual(_ item: test_component.AnyIStorageItem?) throws -> Bool {
            var value: boolean = 0
            let itemWrapper = __ABI_Windows_Storage.IStorageItemWrapper(item)
            let _item = try! itemWrapper?.toABI { $0 }
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem2.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.IsEqual(pThis, _item, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageItem2VTable: __x_ABI_CWindows_CStorage_CIStorageItem2Vtbl = .init(
        QueryInterface: { IStorageItem2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItem2Wrapper.addRef($0) },
        Release: { IStorageItem2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItem2Wrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItem2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetParentAsync: {
            do {
                guard let __unwrapped__instance = IStorageItem2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getParentAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        IsEqual: {
            do {
                guard let __unwrapped__instance = IStorageItem2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let item: test_component.AnyIStorageItem? = __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: ComPtr($1))
                let value = try __unwrapped__instance.isEqual(item)
                $2?.initialize(to: .init(from: value))
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageItem2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItem2Bridge>
    public class IStorageItemProperties: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemProperties }

        open func GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(_ mode: test_component.ThumbnailMode) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(pThis, mode, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetThumbnailAsyncOverloadDefaultOptions(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsyncOverloadDefaultOptions(pThis, mode, requestedSize, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsync(pThis, mode, requestedSize, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func get_DisplayName() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DisplayName(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_DisplayType() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DisplayType(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_FolderRelativeId() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_FolderRelativeId(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_Properties() throws -> test_component.StorageItemContentProperties? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.get_Properties(pThis, &valueAbi))
                }
            }
            return __IMPL_Windows_Storage_FileProperties.StorageItemContentPropertiesBridge.from(abi: value)
        }

    }

    internal static var IStorageItemPropertiesVTable: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesVtbl = .init(
        QueryInterface: { IStorageItemPropertiesWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemPropertiesWrapper.addRef($0) },
        Release: { IStorageItemPropertiesWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemProperties").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetThumbnailAsyncOverloadDefaultSizeDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let operation = try __unwrapped__instance.getThumbnailAsync(mode)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetThumbnailAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let operation = try __unwrapped__instance.getThumbnailAsync(mode, requestedSize)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetThumbnailAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let options: test_component.ThumbnailOptions = $3
                let operation = try __unwrapped__instance.getThumbnailAsync(mode, requestedSize, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        },

        get_DisplayName: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.displayName
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_DisplayType: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.displayType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_FolderRelativeId: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.folderRelativeId
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Properties: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.properties
            value?.copyTo($1)
            return S_OK
        }
    )

    public typealias IStorageItemPropertiesWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemPropertiesBridge>
    public class IStorageItemProperties2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemProperties2 }

        open func GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(_ mode: test_component.ThumbnailMode) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(pThis, mode, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(pThis, mode, requestedSize, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetScaledImageAsThumbnailAsync(_ mode: test_component.ThumbnailMode, _ requestedSize: UInt32, _ options: test_component.ThumbnailOptions) throws -> test_component.AnyIAsyncOperation<test_component.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsync(pThis, mode, requestedSize, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageItemProperties2VTable: __x_ABI_CWindows_CStorage_CIStorageItemProperties2Vtbl = .init(
        QueryInterface: { IStorageItemProperties2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemProperties2Wrapper.addRef($0) },
        Release: { IStorageItemProperties2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemProperties2Wrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemProperties2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetScaledImageAsThumbnailAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode, requestedSize)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetScaledImageAsThumbnailAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: test_component.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let options: test_component.ThumbnailOptions = $3
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode, requestedSize, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStorageItemProperties2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemProperties2Bridge>
    public class IStorageItemPropertiesWithProvider: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider }

        open func get_Provider() throws -> test_component.StorageProvider? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.get_Provider(pThis, &valueAbi))
                }
            }
            return __IMPL_Windows_Storage.StorageProviderBridge.from(abi: value)
        }

    }

    internal static var IStorageItemPropertiesWithProviderVTable: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProviderVtbl = .init(
        QueryInterface: { IStorageItemPropertiesWithProviderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemPropertiesWithProviderWrapper.addRef($0) },
        Release: { IStorageItemPropertiesWithProviderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemPropertiesWithProviderWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemPropertiesWithProvider").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Provider: {
            guard let __unwrapped__instance = IStorageItemPropertiesWithProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.provider
            value?.copyTo($1)
            return S_OK
        }
    )

    public typealias IStorageItemPropertiesWithProviderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemPropertiesWithProviderBridge>
    public class IStorageLibraryChange: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageLibraryChange }

        public func get_ChangeType() throws -> test_component.StorageLibraryChangeType {
            var value: __x_ABI_CWindows_CStorage_CStorageLibraryChangeType = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ChangeType(pThis, &value))
            }
            return value
        }

        public func get_Path() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Path(pThis, &value))
            }
            return .init(from: value)
        }

        public func get_PreviousPath() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_PreviousPath(pThis, &value))
            }
            return .init(from: value)
        }

        public func IsOfType(_ type: test_component.StorageItemTypes) throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.IsOfType(pThis, type, &value))
            }
            return .init(from: value)
        }

        public func GetStorageItemAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIStorageItem?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetStorageItemAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageLibraryChangeReader: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageLibraryChangeReader }

        public func ReadBatchAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIVectorView<test_component.StorageLibraryChange?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeReader.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadBatchAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.unwrapFrom(abi: operation)
        }

        public func AcceptChangesAsync() throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeReader.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.AcceptChangesAsync(pThis, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageLibraryChangeTracker: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker }

        public func GetChangeReader() throws -> test_component.StorageLibraryChangeReader? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetChangeReader(pThis, &valueAbi))
                }
            }
            return __IMPL_Windows_Storage.StorageLibraryChangeReaderBridge.from(abi: value)
        }

        public func Enable() throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Enable(pThis))
            }
        }

        public func Reset() throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Reset(pThis))
            }
        }

    }

    public class IStorageProvider: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageProvider }

        public func get_Id() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Id(pThis, &value))
            }
            return .init(from: value)
        }

        public func get_DisplayName() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DisplayName(pThis, &value))
            }
            return .init(from: value)
        }

    }

    public class IStorageProvider2: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageProvider2 }

        public func IsPropertySupportedForPartialFileAsync(_ propertyCanonicalName: String) throws -> test_component.AnyIAsyncOperation<Bool>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _propertyCanonicalName = try! HString(propertyCanonicalName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageProvider2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.IsPropertySupportedForPartialFileAsync(pThis, _propertyCanonicalName.get(), &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageStreamTransaction: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStorageStreamTransaction }

        public func get_Stream() throws -> test_component.AnyIRandomAccessStream? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageStreamTransaction.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.get_Stream(pThis, &valueAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.unwrapFrom(abi: value)
        }

        public func CommitAsync() throws -> test_component.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageStreamTransaction.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CommitAsync(pThis, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStreamedFileDataRequest: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequest }

        open func FailAndClose(_ failureMode: test_component.StreamedFileFailureMode) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequest.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.FailAndClose(pThis, failureMode))
            }
        }

    }

    internal static var IStreamedFileDataRequestVTable: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestVtbl = .init(
        QueryInterface: { IStreamedFileDataRequestWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStreamedFileDataRequestWrapper.addRef($0) },
        Release: { IStreamedFileDataRequestWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStreamedFileDataRequestWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStreamedFileDataRequest").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        FailAndClose: {
            do {
                guard let __unwrapped__instance = IStreamedFileDataRequestWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let failureMode: test_component.StreamedFileFailureMode = $1
                try __unwrapped__instance.failAndClose(failureMode)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IStreamedFileDataRequestWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStreamedFileDataRequestBridge>
}
// MARK - StreamedFileDataRequestedHandler
extension __ABI_Windows_Storage {
    public class StreamedFileDataRequestedHandler: test_component.IUnknown {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandler }

        open func Invoke(_ stream: test_component.StreamedFileDataRequest?) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandler.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(stream)))
            }
        }

    }


    typealias StreamedFileDataRequestedHandlerWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.StreamedFileDataRequestedHandlerBridge>
    internal static var StreamedFileDataRequestedHandlerVTable: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandlerVtbl = .init(
        QueryInterface: { StreamedFileDataRequestedHandlerWrapper.queryInterface($0, $1, $2) },
        AddRef: { StreamedFileDataRequestedHandlerWrapper.addRef($0) },
        Release: { StreamedFileDataRequestedHandlerWrapper.release($0) },
        Invoke: {
            do {
                guard let __unwrapped__instance = StreamedFileDataRequestedHandlerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let stream: test_component.StreamedFileDataRequest? = __IMPL_Windows_Storage.StreamedFileDataRequestBridge.from(abi: ComPtr($1))
                try __unwrapped__instance(stream)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )
}
public extension WinRTDelegateBridge where CABI == __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandler {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.StreamedFileDataRequestedHandlerVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

