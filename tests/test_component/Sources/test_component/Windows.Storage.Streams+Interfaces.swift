// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
import Ctest_component

// MARK: - IBuffer

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ibuffer)
public protocol IBuffer : IBufferByteAccess {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ibuffer.capacity)
    var capacity: UInt32 { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ibuffer.length)
    var length: UInt32 { get set }
}

extension IBuffer {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage_Streams.IBufferWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_.IBufferByteAccessWrapper.IID:
                let wrapper = __ABI_.IBufferByteAccessWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
extension IBuffer {
    public var data: Data {
        guard let buffer = try? buffer else { return Data() }
        return Data(bytesNoCopy: buffer, count: Int(length), deallocator: .none)
    }
}
public typealias AnyIBuffer = any IBuffer

// MARK: - IBuffer Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage_Streams {
    public enum IBufferBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIBuffer
        public typealias SwiftABI = __ABI_Windows_Storage_Streams.IBuffer
        public typealias SwiftProjection = AnyIBuffer
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IBufferImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage_Streams.IBufferVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IBufferImpl: IBuffer, WinRTAbiImpl {
        fileprivate typealias Bridge = IBufferBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ibuffer.capacity)
        fileprivate var capacity : UInt32 {
            get { try! _default.get_Capacity() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ibuffer.length)
        fileprivate var length : UInt32 {
            get { try! _default.get_Length() }
            set { try! _default.put_Length(newValue) }
        }

        private lazy var _IBufferByteAccess: __ABI_.IBufferByteAccess! = getInterfaceForCaching()
        fileprivate var buffer: UnsafeMutablePointer<UInt8>? {
            get throws {
                let bufferByteAccess: test_component.__ABI_.IBufferByteAccess = try _IBufferByteAccess.QueryInterface()
                return try bufferByteAccess.Buffer()
            }
        }
    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage_Streams {
    private static let IID___x_ABI_CWindows_CStorage_CStreams_CIBuffer: test_component.IID = .init(
        Data1: 0x905A0FE0, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ) // 905A0FE0-BC53-11DF-8C49-001E4FC686DA
    ) 

    public class IBuffer: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIBuffer }

        open func get_Capacity() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Capacity(pThis, &value))
            }
            return value
        }

        open func get_Length() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Length(pThis, &value))
            }
            return value
        }

        open func put_Length(_ value: UInt32) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_Length(pThis, value))
            }
        }

    }

    internal static var IBufferVTable: __x_ABI_CWindows_CStorage_CStreams_CIBufferVtbl = .init(
        QueryInterface: { IBufferWrapper.queryInterface($0, $1, $2) },
        AddRef: { IBufferWrapper.addRef($0) },
        Release: { IBufferWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IBufferWrapper.IID
            iids[3] = __ABI_.IBufferByteAccessWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IBuffer").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Capacity: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.capacity
            $1?.initialize(to: value)
            return S_OK
        },

        get_Length: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.length
            $1?.initialize(to: value)
            return S_OK
        },

        put_Length: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UInt32 = $1
            __unwrapped__instance.length = value
            return S_OK
        }
    )

    public typealias IBufferWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IBufferBridge>
}
@_spi(WinRTInternal)
public class IBufferMaker: MakeFromAbi {
    public typealias SwiftType = AnyIBuffer
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage_Streams.IBuffer = try! abi.QueryInterface()
        return __IMPL_Windows_Storage_Streams.IBufferBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IContentTypeProvider

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.icontenttypeprovider)
public protocol IContentTypeProvider : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.icontenttypeprovider.contenttype)
    var contentType: String { get }
}

extension IContentTypeProvider {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIContentTypeProvider = any IContentTypeProvider

// MARK: - IContentTypeProvider Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage_Streams {
    public enum IContentTypeProviderBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider
        public typealias SwiftABI = __ABI_Windows_Storage_Streams.IContentTypeProvider
        public typealias SwiftProjection = AnyIContentTypeProvider
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IContentTypeProviderImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage_Streams.IContentTypeProviderVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IContentTypeProviderImpl: IContentTypeProvider, WinRTAbiImpl {
        fileprivate typealias Bridge = IContentTypeProviderBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.icontenttypeprovider.contenttype)
        fileprivate var contentType : String {
            get { try! _default.get_ContentType() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage_Streams {
    private static let IID___x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider: test_component.IID = .init(
        Data1: 0x97D098A5, Data2: 0x3B99, Data3: 0x4DE9, Data4: ( 0x88,0xA5,0xE1,0x1D,0x2F,0x50,0xC7,0x95 ) // 97D098A5-3B99-4DE9-88A5-E11D2F50C795
    ) 

    public class IContentTypeProvider: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider }

        open func get_ContentType() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ContentType(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IContentTypeProviderVTable: __x_ABI_CWindows_CStorage_CStreams_CIContentTypeProviderVtbl = .init(
        QueryInterface: { IContentTypeProviderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IContentTypeProviderWrapper.addRef($0) },
        Release: { IContentTypeProviderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IContentTypeProvider").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_ContentType: {
            guard let __unwrapped__instance = IContentTypeProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.contentType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        }
    )

    public typealias IContentTypeProviderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IContentTypeProviderBridge>
}
@_spi(WinRTInternal)
public class IContentTypeProviderMaker: MakeFromAbi {
    public typealias SwiftType = AnyIContentTypeProvider
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage_Streams.IContentTypeProvider = try! abi.QueryInterface()
        return __IMPL_Windows_Storage_Streams.IContentTypeProviderBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IInputStream

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.iinputstream)
public protocol IInputStream : test_component.IClosable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.iinputstream.readasync)
    func readAsync(_ buffer: test_component.AnyIBuffer!, _ count: UInt32, _ options: test_component.InputStreamOptions) throws -> test_component.AnyIAsyncOperationWithProgress<test_component.AnyIBuffer?, UInt32>!
}

extension IInputStream {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Foundation.IClosableWrapper.IID:
                let wrapper = __ABI_Windows_Foundation.IClosableWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIInputStream = any IInputStream

// MARK: - IInputStream Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage_Streams {
    public enum IInputStreamBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIInputStream
        public typealias SwiftABI = __ABI_Windows_Storage_Streams.IInputStream
        public typealias SwiftProjection = AnyIInputStream
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IInputStreamImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage_Streams.IInputStreamVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IInputStreamImpl: IInputStream, WinRTAbiImpl {
        fileprivate typealias Bridge = IInputStreamBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.iinputstream.readasync)
        fileprivate func readAsync(_ buffer: AnyIBuffer!, _ count: UInt32, _ options: InputStreamOptions) throws -> AnyIAsyncOperationWithProgress<AnyIBuffer?, UInt32>! {
            try _default.ReadAsync(buffer, count, options)
        }

        private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.iinputstream.close)
        fileprivate func close() throws {
            try _IClosable.Close()
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage_Streams {
    private static let IID___x_ABI_CWindows_CStorage_CStreams_CIInputStream: test_component.IID = .init(
        Data1: 0x905A0FE2, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ) // 905A0FE2-BC53-11DF-8C49-001E4FC686DA
    ) 

    public class IInputStream: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIInputStream }

        open func ReadAsync(_ buffer: test_component.AnyIBuffer?, _ count: UInt32, _ options: test_component.InputStreamOptions) throws -> test_component.AnyIAsyncOperationWithProgress<test_component.AnyIBuffer?, UInt32>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                let _buffer = try! bufferWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIInputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadAsync(pThis, _buffer, count, options, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IInputStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamVtbl = .init(
        QueryInterface: { IInputStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IInputStreamWrapper.addRef($0) },
        Release: { IInputStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IInputStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        ReadAsync: {
            do {
                guard let __unwrapped__instance = IInputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer: test_component.AnyIBuffer? = __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: ComPtr($1))
                let count: UInt32 = $2
                let options: test_component.InputStreamOptions = $3
                let operation = try __unwrapped__instance.readAsync(buffer, count, options)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IInputStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IInputStreamBridge>
}
@_spi(WinRTInternal)
public class IInputStreamMaker: MakeFromAbi {
    public typealias SwiftType = AnyIInputStream
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage_Streams.IInputStream = try! abi.QueryInterface()
        return __IMPL_Windows_Storage_Streams.IInputStreamBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IInputStreamReference

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.iinputstreamreference)
public protocol IInputStreamReference : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.iinputstreamreference.opensequentialreadasync)
    func openSequentialReadAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIInputStream?>!
}

extension IInputStreamReference {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIInputStreamReference = any IInputStreamReference

// MARK: - IInputStreamReference Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage_Streams {
    public enum IInputStreamReferenceBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference
        public typealias SwiftABI = __ABI_Windows_Storage_Streams.IInputStreamReference
        public typealias SwiftProjection = AnyIInputStreamReference
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IInputStreamReferenceImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage_Streams.IInputStreamReferenceVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IInputStreamReferenceImpl: IInputStreamReference, WinRTAbiImpl {
        fileprivate typealias Bridge = IInputStreamReferenceBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.iinputstreamreference.opensequentialreadasync)
        fileprivate func openSequentialReadAsync() throws -> AnyIAsyncOperation<AnyIInputStream?>! {
            try _default.OpenSequentialReadAsync()
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage_Streams {
    private static let IID___x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference: test_component.IID = .init(
        Data1: 0x43929D18, Data2: 0x5EC9, Data3: 0x4B5A, Data4: ( 0x91,0x9C,0x42,0x05,0xB0,0xC8,0x04,0xB6 ) // 43929D18-5EC9-4B5A-919C-4205B0C804B6
    ) 

    public class IInputStreamReference: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference }

        open func OpenSequentialReadAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIInputStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenSequentialReadAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IInputStreamReferenceVTable: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamReferenceVtbl = .init(
        QueryInterface: { IInputStreamReferenceWrapper.queryInterface($0, $1, $2) },
        AddRef: { IInputStreamReferenceWrapper.addRef($0) },
        Release: { IInputStreamReferenceWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IInputStreamReference").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenSequentialReadAsync: {
            do {
                guard let __unwrapped__instance = IInputStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openSequentialReadAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IInputStreamReferenceWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IInputStreamReferenceBridge>
}
@_spi(WinRTInternal)
public class IInputStreamReferenceMaker: MakeFromAbi {
    public typealias SwiftType = AnyIInputStreamReference
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage_Streams.IInputStreamReference = try! abi.QueryInterface()
        return __IMPL_Windows_Storage_Streams.IInputStreamReferenceBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IOutputStream

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ioutputstream)
public protocol IOutputStream : test_component.IClosable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ioutputstream.writeasync)
    func writeAsync(_ buffer: test_component.AnyIBuffer!) throws -> test_component.AnyIAsyncOperationWithProgress<UInt32, UInt32>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ioutputstream.flushasync)
    func flushAsync() throws -> test_component.AnyIAsyncOperation<Bool>!
}

extension IOutputStream {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Foundation.IClosableWrapper.IID:
                let wrapper = __ABI_Windows_Foundation.IClosableWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIOutputStream = any IOutputStream

// MARK: - IOutputStream Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage_Streams {
    public enum IOutputStreamBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIOutputStream
        public typealias SwiftABI = __ABI_Windows_Storage_Streams.IOutputStream
        public typealias SwiftProjection = AnyIOutputStream
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IOutputStreamImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage_Streams.IOutputStreamVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IOutputStreamImpl: IOutputStream, WinRTAbiImpl {
        fileprivate typealias Bridge = IOutputStreamBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ioutputstream.writeasync)
        fileprivate func writeAsync(_ buffer: AnyIBuffer!) throws -> AnyIAsyncOperationWithProgress<UInt32, UInt32>! {
            try _default.WriteAsync(buffer)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ioutputstream.flushasync)
        fileprivate func flushAsync() throws -> AnyIAsyncOperation<Bool>! {
            try _default.FlushAsync()
        }

        private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.ioutputstream.close)
        fileprivate func close() throws {
            try _IClosable.Close()
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage_Streams {
    private static let IID___x_ABI_CWindows_CStorage_CStreams_CIOutputStream: test_component.IID = .init(
        Data1: 0x905A0FE6, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ) // 905A0FE6-BC53-11DF-8C49-001E4FC686DA
    ) 

    public class IOutputStream: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIOutputStream }

        open func WriteAsync(_ buffer: test_component.AnyIBuffer?) throws -> test_component.AnyIAsyncOperationWithProgress<UInt32, UInt32>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                let _buffer = try! bufferWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIOutputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.WriteAsync(pThis, _buffer, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.unwrapFrom(abi: operation)
        }

        open func FlushAsync() throws -> test_component.AnyIAsyncOperation<Bool>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIOutputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.FlushAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IOutputStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIOutputStreamVtbl = .init(
        QueryInterface: { IOutputStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IOutputStreamWrapper.addRef($0) },
        Release: { IOutputStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IOutputStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        WriteAsync: {
            do {
                guard let __unwrapped__instance = IOutputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer: test_component.AnyIBuffer? = __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.writeAsync(buffer)
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        FlushAsync: {
            do {
                guard let __unwrapped__instance = IOutputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.flushAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1_booleanWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IOutputStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IOutputStreamBridge>
}
@_spi(WinRTInternal)
public class IOutputStreamMaker: MakeFromAbi {
    public typealias SwiftType = AnyIOutputStream
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage_Streams.IOutputStream = try! abi.QueryInterface()
        return __IMPL_Windows_Storage_Streams.IOutputStreamBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IRandomAccessStream

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream)
public protocol IRandomAccessStream : test_component.IClosable, IInputStream, IOutputStream {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.getinputstreamat)
    func getInputStreamAt(_ position: UInt64) throws -> test_component.AnyIInputStream!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.getoutputstreamat)
    func getOutputStreamAt(_ position: UInt64) throws -> test_component.AnyIOutputStream!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.seek)
    func seek(_ position: UInt64) throws
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.clonestream)
    func cloneStream() throws -> test_component.AnyIRandomAccessStream!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.canread)
    var canRead: Bool { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.canwrite)
    var canWrite: Bool { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.position)
    var position: UInt64 { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.size)
    var size: UInt64 { get set }
}

extension IRandomAccessStream {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Foundation.IClosableWrapper.IID:
                let wrapper = __ABI_Windows_Foundation.IClosableWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIRandomAccessStream = any IRandomAccessStream

// MARK: - IRandomAccessStream Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage_Streams {
    public enum IRandomAccessStreamBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream
        public typealias SwiftABI = __ABI_Windows_Storage_Streams.IRandomAccessStream
        public typealias SwiftProjection = AnyIRandomAccessStream
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IRandomAccessStreamImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage_Streams.IRandomAccessStreamVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IRandomAccessStreamImpl: IRandomAccessStream, WinRTAbiImpl {
        fileprivate typealias Bridge = IRandomAccessStreamBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.getinputstreamat)
        fileprivate func getInputStreamAt(_ position: UInt64) throws -> AnyIInputStream! {
            try _default.GetInputStreamAt(position)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.getoutputstreamat)
        fileprivate func getOutputStreamAt(_ position: UInt64) throws -> AnyIOutputStream! {
            try _default.GetOutputStreamAt(position)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.seek)
        fileprivate func seek(_ position: UInt64) throws {
            try _default.Seek(position)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.clonestream)
        fileprivate func cloneStream() throws -> AnyIRandomAccessStream! {
            try _default.CloneStream()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.canread)
        fileprivate var canRead : Bool {
            get { try! _default.get_CanRead() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.canwrite)
        fileprivate var canWrite : Bool {
            get { try! _default.get_CanWrite() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.position)
        fileprivate var position : UInt64 {
            get { try! _default.get_Position() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.size)
        fileprivate var size : UInt64 {
            get { try! _default.get_Size() }
            set { try! _default.put_Size(newValue) }
        }

        private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.close)
        fileprivate func close() throws {
            try _IClosable.Close()
        }

        private lazy var _IInputStream: __ABI_Windows_Storage_Streams.IInputStream! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.readasync)
        fileprivate func readAsync(_ buffer: AnyIBuffer!, _ count: UInt32, _ options: InputStreamOptions) throws -> AnyIAsyncOperationWithProgress<AnyIBuffer?, UInt32>! {
            try _IInputStream.ReadAsync(buffer, count, options)
        }

        private lazy var _IOutputStream: __ABI_Windows_Storage_Streams.IOutputStream! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.writeasync)
        fileprivate func writeAsync(_ buffer: AnyIBuffer!) throws -> AnyIAsyncOperationWithProgress<UInt32, UInt32>! {
            try _IOutputStream.WriteAsync(buffer)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.flushasync)
        fileprivate func flushAsync() throws -> AnyIAsyncOperation<Bool>! {
            try _IOutputStream.FlushAsync()
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage_Streams {
    private static let IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream: test_component.IID = .init(
        Data1: 0x905A0FE1, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ) // 905A0FE1-BC53-11DF-8C49-001E4FC686DA
    ) 

    public class IRandomAccessStream: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream }

        open func get_Size() throws -> UInt64 {
            var value: UINT64 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &value))
            }
            return value
        }

        open func put_Size(_ value: UInt64) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_Size(pThis, value))
            }
        }

        open func GetInputStreamAt(_ position: UInt64) throws -> test_component.AnyIInputStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetInputStreamAt(pThis, position, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IInputStreamWrapper.unwrapFrom(abi: stream)
        }

        open func GetOutputStreamAt(_ position: UInt64) throws -> test_component.AnyIOutputStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetOutputStreamAt(pThis, position, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IOutputStreamWrapper.unwrapFrom(abi: stream)
        }

        open func get_Position() throws -> UInt64 {
            var value: UINT64 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Position(pThis, &value))
            }
            return value
        }

        open func Seek(_ position: UInt64) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Seek(pThis, position))
            }
        }

        open func CloneStream() throws -> test_component.AnyIRandomAccessStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CloneStream(pThis, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.unwrapFrom(abi: stream)
        }

        open func get_CanRead() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_CanRead(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_CanWrite() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_CanWrite(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IRandomAccessStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamVtbl = .init(
        QueryInterface: { IRandomAccessStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamWrapper.addRef($0) },
        Release: { IRandomAccessStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 6).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            $1!.pointee = 6
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Size: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.size
            $1?.initialize(to: value)
            return S_OK
        },

        put_Size: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UInt64 = $1
            __unwrapped__instance.size = value
            return S_OK
        },

        GetInputStreamAt: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                let stream = try __unwrapped__instance.getInputStreamAt(position)
                let streamWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(stream)
                streamWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        GetOutputStreamAt: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                let stream = try __unwrapped__instance.getOutputStreamAt(position)
                let streamWrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(stream)
                streamWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(error: error) }
        },

        get_Position: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.position
            $1?.initialize(to: value)
            return S_OK
        },

        Seek: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                try __unwrapped__instance.seek(position)
                return S_OK
            } catch { return failWith(error: error) }
        },

        CloneStream: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let stream = try __unwrapped__instance.cloneStream()
                let streamWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper(stream)
                streamWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        },

        get_CanRead: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.canRead
            $1?.initialize(to: .init(from: value))
            return S_OK
        },

        get_CanWrite: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.canWrite
            $1?.initialize(to: .init(from: value))
            return S_OK
        }
    )

    public typealias IRandomAccessStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamBridge>
}
@_spi(WinRTInternal)
public class IRandomAccessStreamMaker: MakeFromAbi {
    public typealias SwiftType = AnyIRandomAccessStream
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage_Streams.IRandomAccessStream = try! abi.QueryInterface()
        return __IMPL_Windows_Storage_Streams.IRandomAccessStreamBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IRandomAccessStreamReference

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamreference)
public protocol IRandomAccessStreamReference : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamreference.openreadasync)
    func openReadAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStreamWithContentType?>!
}

extension IRandomAccessStreamReference {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIRandomAccessStreamReference = any IRandomAccessStreamReference

// MARK: - IRandomAccessStreamReference Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage_Streams {
    public enum IRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference
        public typealias SwiftABI = __ABI_Windows_Storage_Streams.IRandomAccessStreamReference
        public typealias SwiftProjection = AnyIRandomAccessStreamReference
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IRandomAccessStreamReferenceImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IRandomAccessStreamReferenceImpl: IRandomAccessStreamReference, WinRTAbiImpl {
        fileprivate typealias Bridge = IRandomAccessStreamReferenceBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamreference.openreadasync)
        fileprivate func openReadAsync() throws -> AnyIAsyncOperation<AnyIRandomAccessStreamWithContentType?>! {
            try _default.OpenReadAsync()
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage_Streams {
    private static let IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference: test_component.IID = .init(
        Data1: 0x33EE3134, Data2: 0x1DD6, Data3: 0x4E3A, Data4: ( 0x80,0x67,0xD1,0xC1,0x62,0xE8,0x64,0x2B ) // 33EE3134-1DD6-4E3A-8067-D1C162E8642B
    ) 

    public class IRandomAccessStreamReference: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference }

        open func OpenReadAsync() throws -> test_component.AnyIAsyncOperation<test_component.AnyIRandomAccessStreamWithContentType?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenReadAsync(pThis, &operationAbi))
                }
            }
            return test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IRandomAccessStreamReferenceVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReferenceVtbl = .init(
        QueryInterface: { IRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamReferenceWrapper.addRef($0) },
        Release: { IRandomAccessStreamReferenceWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStreamReference").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenReadAsync: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openReadAsync()
                let operationWrapper = test_component.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(error: error) }
        }
    )

    public typealias IRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamReferenceBridge>
}
@_spi(WinRTInternal)
public class IRandomAccessStreamReferenceMaker: MakeFromAbi {
    public typealias SwiftType = AnyIRandomAccessStreamReference
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage_Streams.IRandomAccessStreamReference = try! abi.QueryInterface()
        return __IMPL_Windows_Storage_Streams.IRandomAccessStreamReferenceBridge.from(abi: RawPointer(swiftAbi))!
    }
}
// MARK: - IRandomAccessStreamWithContentType

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype)
public protocol IRandomAccessStreamWithContentType : test_component.IClosable, IInputStream, IOutputStream, IRandomAccessStream, IContentTypeProvider {
}

extension IRandomAccessStreamWithContentType {
    public func queryInterface(_ iid: test_component.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Foundation.IClosableWrapper.IID:
                let wrapper = __ABI_Windows_Foundation.IClosableWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper(self)
                return wrapper!.queryInterface(iid)
            case __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper.IID:
                let wrapper = __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIRandomAccessStreamWithContentType = any IRandomAccessStreamWithContentType

// MARK: - IRandomAccessStreamWithContentType Internals

@_spi(WinRTInternal)
extension __IMPL_Windows_Storage_Streams {
    public enum IRandomAccessStreamWithContentTypeBridge : AbiInterfaceBridge {
        public typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType
        public typealias SwiftABI = __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentType
        public typealias SwiftProjection = AnyIRandomAccessStreamWithContentType
        public static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
            guard let abi = abi else { return nil }
            return IRandomAccessStreamWithContentTypeImpl(abi)
        }

        public static func makeAbi() -> CABI {
            let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeVTable) { $0 }
            return .init(lpVtbl: vtblPtr)
        }
    }

    fileprivate class IRandomAccessStreamWithContentTypeImpl: IRandomAccessStreamWithContentType, WinRTAbiImpl {
        fileprivate typealias Bridge = IRandomAccessStreamWithContentTypeBridge
        fileprivate let _default: Bridge.SwiftABI
        fileprivate var thisPtr: test_component.IInspectable { _default }
        fileprivate init(_ fromAbi: ComPtr<Bridge.CABI>) {
            _default = Bridge.SwiftABI(fromAbi)
        }

        private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.close)
        fileprivate func close() throws {
            try _IClosable.Close()
        }

        private lazy var _IInputStream: __ABI_Windows_Storage_Streams.IInputStream! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.readasync)
        fileprivate func readAsync(_ buffer: AnyIBuffer!, _ count: UInt32, _ options: InputStreamOptions) throws -> AnyIAsyncOperationWithProgress<AnyIBuffer?, UInt32>! {
            try _IInputStream.ReadAsync(buffer, count, options)
        }

        private lazy var _IOutputStream: __ABI_Windows_Storage_Streams.IOutputStream! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.writeasync)
        fileprivate func writeAsync(_ buffer: AnyIBuffer!) throws -> AnyIAsyncOperationWithProgress<UInt32, UInt32>! {
            try _IOutputStream.WriteAsync(buffer)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.flushasync)
        fileprivate func flushAsync() throws -> AnyIAsyncOperation<Bool>! {
            try _IOutputStream.FlushAsync()
        }

        private lazy var _IRandomAccessStream: __ABI_Windows_Storage_Streams.IRandomAccessStream! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.getinputstreamat)
        fileprivate func getInputStreamAt(_ position: UInt64) throws -> AnyIInputStream! {
            try _IRandomAccessStream.GetInputStreamAt(position)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.getoutputstreamat)
        fileprivate func getOutputStreamAt(_ position: UInt64) throws -> AnyIOutputStream! {
            try _IRandomAccessStream.GetOutputStreamAt(position)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.seek)
        fileprivate func seek(_ position: UInt64) throws {
            try _IRandomAccessStream.Seek(position)
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.clonestream)
        fileprivate func cloneStream() throws -> AnyIRandomAccessStream! {
            try _IRandomAccessStream.CloneStream()
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.canread)
        fileprivate var canRead : Bool {
            get { try! _IRandomAccessStream.get_CanRead() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.canwrite)
        fileprivate var canWrite : Bool {
            get { try! _IRandomAccessStream.get_CanWrite() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.position)
        fileprivate var position : UInt64 {
            get { try! _IRandomAccessStream.get_Position() }
        }

        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.size)
        fileprivate var size : UInt64 {
            get { try! _IRandomAccessStream.get_Size() }
            set { try! _IRandomAccessStream.put_Size(newValue) }
        }

        private lazy var _IContentTypeProvider: __ABI_Windows_Storage_Streams.IContentTypeProvider! = getInterfaceForCaching()
        /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstreamwithcontenttype.contenttype)
        fileprivate var contentType : String {
            get { try! _IContentTypeProvider.get_ContentType() }
        }

    }

}
@_spi(WinRTInternal)
extension __ABI_Windows_Storage_Streams {
    private static let IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType: test_component.IID = .init(
        Data1: 0xCC254827, Data2: 0x4B3D, Data3: 0x438F, Data4: ( 0x92,0x32,0x10,0xC7,0x6B,0xC7,0xE0,0x38 ) // CC254827-4B3D-438F-9232-10C76BC7E038
    ) 

    public class IRandomAccessStreamWithContentType: test_component.IInspectable {
        override public class var IID: test_component.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType }

    }

    internal static var IRandomAccessStreamWithContentTypeVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentTypeVtbl = .init(
        QueryInterface: { IRandomAccessStreamWithContentTypeWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamWithContentTypeWrapper.addRef($0) },
        Release: { IRandomAccessStreamWithContentTypeWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<test_component.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 8).assumingMemoryBound(to: test_component.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            iids[6] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.IID
            iids[7] = __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper.IID
            $1!.pointee = 8
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStreamWithContentType").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        }
    )

    public typealias IRandomAccessStreamWithContentTypeWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeBridge>
}
@_spi(WinRTInternal)
public class IRandomAccessStreamWithContentTypeMaker: MakeFromAbi {
    public typealias SwiftType = AnyIRandomAccessStreamWithContentType
    public static func from(abi: test_component.IInspectable) -> SwiftType {
        let swiftAbi: __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentType = try! abi.QueryInterface()
        return __IMPL_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeBridge.from(abi: RawPointer(swiftAbi))!
    }
}
