import Ctest_component
import test_component

// Handwritten VTable for the BindableVEctor class, which incorporates both interfaces it implements.
// In the future this could be generated by an SPM build plugin
fileprivate class BindableVectorWrapper : WinRTWrapperBase<Ctest_component.IInspectable, BindableVectorBase> {
    init(_ vector: BindableVectorBase) {
        let abi = withUnsafeMutablePointer(to: &BindableVectorAsIInspectableVTable) {
            Ctest_component.IInspectable(lpVtbl:$0)
        }
        super.init(abi, vector)
    }
}

public extension BindableVector {
  func makeAbi() -> test_component.IInspectable { 
    let wrapper = BindableVectorWrapper(self)
    return try! wrapper.toABI { .init($0) }
  }
}

fileprivate var BindableVectorAsIInspectableVTable: Ctest_component.IInspectableVtbl = .init(
    QueryInterface: {
        guard let pUnk = $0, let riid = $1, let ppvObject = $2 else { return E_INVALIDARG }
        if riid.pointee == __ABI_Microsoft_UI_Xaml_Interop.IBindableVector.IID {
            guard let instance = BindableVectorWrapper.tryUnwrapFrom(raw: $0) else { fatalError("unable to unwrap from abi") }
            let iBindableWrapper = IBindableVectorWrapper(instance)
            let thisAsiBindable = try! iBindableWrapper.toABI { $0 }
            return thisAsiBindable.pointee.lpVtbl.pointee.QueryInterface(thisAsiBindable, riid, ppvObject)
        } else if riid.pointee == __ABI_Microsoft_UI_Xaml_Interop.INotifyCollectionChanged.IID {
            guard let instance = BindableVectorWrapper.tryUnwrapFrom(raw: $0) else { fatalError("unable to unwrap from abi")}
            let iNotifyCollectionChangedWrapper = INotifyCollectionChangedWrapper(instance)
            let thisAsiNotifyCollectionChanged = try! iNotifyCollectionChangedWrapper.toABI { $0 }
            return thisAsiNotifyCollectionChanged.pointee.lpVtbl.pointee.QueryInterface(thisAsiNotifyCollectionChanged, riid, ppvObject)
        } else if riid.pointee == IUnknown.IID ||
                riid.pointee == IInspectable.IID || 
                riid.pointee == IAgileObject.IID || 
                riid.pointee == ISwiftImplemented.IID {
            _ = pUnk.pointee.lpVtbl.pointee.AddRef(pUnk)
            ppvObject.pointee = UnsafeMutableRawPointer(pUnk)
            return S_OK
        }
       
        return E_NOINTERFACE
    },

    AddRef: {
            guard let wrapper = BindableVectorWrapper.fromRaw($0) else { return 1 }
            _ = wrapper.retain()
            return ULONG(_getRetainCount(wrapper.takeUnretainedValue()))
    },

    Release: {
        guard let wrapper  = BindableVectorWrapper.fromRaw($0) else { return 1 }
        return ULONG(_getRetainCount(wrapper.takeRetainedValue()))
    },

    GetIids: {
        let size = MemoryLayout<IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 2).assumingMemoryBound(to: IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID

        $1!.pointee = 2
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("BindableVector<T>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    }
)

// We have to handwrite all of the other interface VTables as well since we need to make sure the QueryInterface calls
// respond to all of the interfaces we care about

 fileprivate var IBindableVectorVTable: __x_ABI_CMicrosoft_CUI_CXaml_CInterop_CIBindableVectorVtbl = .init(
    QueryInterface: {
        guard let pUnk = $0, let riid = $1, let ppvObject = $2 else { return E_INVALIDARG }
        if riid.pointee == __ABI_Microsoft_UI_Xaml_Interop.INotifyCollectionChanged.IID {
            guard let instance = IBindableVectorWrapper.tryUnwrapFrom(raw: pUnk) as? BindableVectorBase else { fatalError("unable to unwrap from abi")}
            let iNotifyCollectionChangedWrapper = INotifyCollectionChangedWrapper(instance)
            let thisAsiNotifyCollectionChanged = try! iNotifyCollectionChangedWrapper.toABI { $0 }
            return thisAsiNotifyCollectionChanged.pointee.lpVtbl.pointee.QueryInterface(thisAsiNotifyCollectionChanged, riid, ppvObject)
        }
        guard riid.pointee == IUnknown.IID ||
                riid.pointee == IInspectable.IID || 
                riid.pointee == ISwiftImplemented.IID ||
                riid.pointee == IAgileObject.IID ||
                riid.pointee == __ABI_Microsoft_UI_Xaml_Interop.IBindableVectorWrapper.IID else { 
                return E_NOINTERFACE

        }
        _ = pUnk.pointee.lpVtbl.pointee.AddRef(pUnk)
        ppvObject.pointee = UnsafeMutableRawPointer(pUnk)
        return S_OK
    },

    AddRef: {
            guard let wrapper = IBindableVectorWrapper.fromRaw($0) else { return 1 }
            _ = wrapper.retain()
            return ULONG(_getRetainCount(wrapper.takeUnretainedValue()))
    },

    Release: {
        guard let wrapper = IBindableVectorWrapper.fromRaw($0) else { return 1 }
        return ULONG(_getRetainCount(wrapper.takeRetainedValue()))
    },

    GetIids: {
        let size = MemoryLayout<IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = __ABI_Microsoft_UI_Xaml_Interop.IBindableVectorWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.UI.Xaml.Interop.IBindableVector").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        do {
            guard let __unwrapped__instance = IBindableVectorWrapper.tryUnwrapFrom(raw: $0) as? IBindableVector else { return E_INVALIDARG }
            let index: UInt32 = $1
            let result = try __unwrapped__instance.getAt(index)
            let resultWrapper = __ABI_.AnyWrapper(result)
            resultWrapper?.copyTo($2)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    },

    get_Size: {
        guard let __unwrapped__instance = IBindableVectorWrapper.tryUnwrapFrom(raw: $0) as? IBindableVector else { return E_INVALIDARG }
        let value = __unwrapped__instance.size
        $1?.initialize(to: value)
        return S_OK
    }
)

// For some reason this wrapper type has to specify AnyObject, otherwise we get a crash at runtime. It's not exactly why, but seems
// like a bug in swift
fileprivate class IBindableVectorWrapper : WinRTWrapperBase<__x_ABI_CMicrosoft_CUI_CXaml_CInterop_CIBindableVector, AnyObject> {
    init(_ vector: BindableVectorBase) {
        let abi = withUnsafeMutablePointer(to: &IBindableVectorVTable) {
            __x_ABI_CMicrosoft_CUI_CXaml_CInterop_CIBindableVector(lpVtbl:$0)
        }
        super.init(abi, vector)
    }
}
typealias NotifyCollectionChangedEventHandlerWrapper = InterfaceWrapperBase<__IMPL_Microsoft_UI_Xaml_Interop.NotifyCollectionChangedEventHandlerImpl>

 fileprivate var INotifyCollectionChangedVTable: __x_ABI_CMicrosoft_CUI_CXaml_CInterop_CINotifyCollectionChangedVtbl = .init(
    QueryInterface: {
        guard let pUnk = $0, let riid = $1, let ppvObject = $2 else { return E_INVALIDARG }
        if riid.pointee == __ABI_Microsoft_UI_Xaml_Interop.IBindableVector.IID {
            guard let instance = INotifyCollectionChangedWrapper.tryUnwrapFrom(raw: $0) else { fatalError("unable to unwrap from abi") }
            let iBindableWrapper = IBindableVectorWrapper(instance)
            let thisAsiBindable = try! iBindableWrapper.toABI { $0 }
            return thisAsiBindable.pointee.lpVtbl.pointee.QueryInterface(thisAsiBindable, riid, ppvObject)
        }
        guard riid.pointee == IUnknown.IID ||
                riid.pointee == IInspectable.IID || 
                riid.pointee == ISwiftImplemented.IID ||
                riid.pointee == IAgileObject.IID ||
                riid.pointee == __ABI_Microsoft_UI_Xaml_Interop.INotifyCollectionChangedWrapper.IID else { 
            return E_NOINTERFACE
        }
        _ = pUnk.pointee.lpVtbl.pointee.AddRef(pUnk)
        ppvObject.pointee = UnsafeMutableRawPointer(pUnk)
        return S_OK
    },

    AddRef: {
            guard let wrapper = INotifyCollectionChangedWrapper.fromRaw($0) else { return 1 }
            _ = wrapper.retain()
            return ULONG(_getRetainCount(wrapper.takeUnretainedValue()))
    },

    Release: {
        guard let wrapper = INotifyCollectionChangedWrapper.fromRaw($0) else { return 1 }
        return ULONG(_getRetainCount(wrapper.takeRetainedValue()))
    },

    GetIids: {
        let size = MemoryLayout<IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = __ABI_Microsoft_UI_Xaml_Interop.INotifyCollectionChangedWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.UI.Xaml.Interop.INotifyCollectionChanged").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    add_CollectionChanged: {
        guard let __unwrapped__instance = INotifyCollectionChangedWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = NotifyCollectionChangedEventHandlerWrapper.unwrapFrom(abi: $1) else { return E_INVALIDARG }
        let token = __unwrapped__instance.collectionChanged.addHandler(handler)
        $2?.initialize(to: .from(swift: token))
        return S_OK
    },

    remove_CollectionChanged: {
        guard let __unwrapped__instance = INotifyCollectionChangedWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let token: EventRegistrationToken = $1
        __unwrapped__instance.collectionChanged.removeHandler(token)
        return S_OK
    }
)

fileprivate class INotifyCollectionChangedWrapper : WinRTWrapperBase<__x_ABI_CMicrosoft_CUI_CXaml_CInterop_CINotifyCollectionChanged, BindableVectorBase> {
    init(_ vector: BindableVectorBase) {
        let abi = withUnsafeMutablePointer(to: &INotifyCollectionChangedVTable) {
            __x_ABI_CMicrosoft_CUI_CXaml_CInterop_CINotifyCollectionChanged(lpVtbl:$0)
        }
        super.init(abi, vector)
    }
}
