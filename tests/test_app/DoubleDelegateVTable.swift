import Ctest_component
import test_component
import Foundation

// Handwritten VTable for the DoubleDelegate class, which incorporates both interfaces it implements.
// In the future this could be generated by an SPM build plugin
fileprivate class DoubleDelegateAsIInspectableWrapper : WinRTWrapperBase<Ctest_component.IInspectable, DoubleDelegate> {
    init(_ doubleDelegate: DoubleDelegate) {
        let abi = withUnsafeMutablePointer(to: &DoubleDelegateVTable) {
            Ctest_component.IInspectable(lpVtbl:$0)
        }
        super.init(abi, doubleDelegate)
    }
}

extension DoubleDelegate {
  func makeAbi() -> test_component.IInspectable { 
    let wrapper = DoubleDelegateAsIInspectableWrapper(self)
    let abi = try! wrapper.toABI { $0 }
    return .init(abi)
  }
}

fileprivate var DoubleDelegateVTable: Ctest_component.IInspectableVtbl = .init(
    QueryInterface: {
        guard let pUnk = $0, let riid = $1, let ppvObject = $2 else { return E_INVALIDARG }
        if riid.pointee == __ABI_test_component.IBasic.IID {
            guard let instance = DoubleDelegateAsIInspectableWrapper.tryUnwrapFrom(raw: $0) else { fatalError("unable to unwrap from abi") }
            guard let iBasicWrapper = __ABI_test_component.IBasicWrapper(instance) else { fatalError("failed to create wrapper") }
            let thisAsIBasic = try! iBasicWrapper.toABI { $0 }
            return thisAsIBasic.pointee.lpVtbl.pointee.QueryInterface(thisAsIBasic, riid, ppvObject)
        } else if riid.pointee == __ABI_test_component.ISimpleDelegate.IID {
            guard let instance = DoubleDelegateAsIInspectableWrapper.tryUnwrapFrom(raw: $0) else { fatalError("unable to unwrap from abi")}
            guard let iSimpleDelegateWrapper = __ABI_test_component.ISimpleDelegateWrapper(instance) else { fatalError("failed to create wrapper") }
            let thisAsISimpleDelegate = try! iSimpleDelegateWrapper.toABI { $0 }
            return thisAsISimpleDelegate.pointee.lpVtbl.pointee.QueryInterface(thisAsISimpleDelegate, riid, ppvObject)
        } else if riid.pointee == IUnknown.IID ||
                riid.pointee == IInspectable.IID || 
                riid.pointee == IAgileObject.IID || 
                riid.pointee == ISwiftImplemented.IID {
            _ = pUnk.pointee.lpVtbl.pointee.AddRef(pUnk)
            ppvObject.pointee = UnsafeMutableRawPointer(pUnk)
            return S_OK
        }
       
        return E_NOINTERFACE
    },

    AddRef: {
            guard let wrapper = DoubleDelegateAsIInspectableWrapper.fromRaw($0) else { return 1 }
            _ = wrapper.retain()
            return ULONG(_getRetainCount(wrapper.takeUnretainedValue().swiftObj))
    },

    Release: {
        guard let wrapper = DoubleDelegateAsIInspectableWrapper.fromRaw($0) else { return 1 }
        return ULONG(_getRetainCount(wrapper.takeRetainedValue().swiftObj))
    },

    GetIids: {
        let size = MemoryLayout<IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 2).assumingMemoryBound(to: IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID

        $1!.pointee = 2
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("DoubleDelegate").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    }
)