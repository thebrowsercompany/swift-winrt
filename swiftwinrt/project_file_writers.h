#pragma once

namespace swiftwinrt
{
    static void write_root_cmake(std::map<std::string, std::vector<std::string_view>>& namespaces)
    {
        writer w;
        auto path = w.root_directory() / "CMakeLists.txt";
        if (!settings.has_project_type(project_type::cmake))
        {
            std::filesystem::remove(path);
            return;
        }
        w.write("add_subdirectory(CWinRT)\n");
        for (auto&& [module, _] : namespaces)
        {
            w.write("add_subdirectory(%)\n", module);
        }   

        w.flush_to_file(path);
    }

    static void write_cmake_lists(std::string_view const& module, std::set<std::string> const& depends, std::vector<std::string_view> const& namespaces)
    {
        writer w;
        w.type_namespace = module;
        auto path = w.project_directory() / "CMakeLists.txt";

        if (!settings.has_project_type(project_type::cmake))
        {
            std::filesystem::remove(path);
            return;
        }

        w.write("set(GENERATED_FILES_DIR ${CMAKE_CURRENT_SOURCE_DIR})\n");

        w.write("set(SWIFTWINRT_GENERATED_FILES");
        {
            auto indent = w.push_indent({ 1 });
            for (const auto& ns : namespaces)
            {
                w.write("\n%.swift", ns);
                w.write("\n%+ABI.swift", ns);
                w.write("\n%+Impl.swift", ns);
            }
        }
        w.write(")\n");

        if (module == settings.support)
            w.write("file(GLOB SUPPORT_FILES ${GENERATED_FILES_DIR}/Support/*)\n");

        w.write("\n");

        w.write("add_library(% SHARED ${SWIFTWINRT_GENERATED_FILES} %)\n",
            module, module == settings.support ? "${SUPPORT_FILES}" : "");

        w.write("\n");

        w.write("install(TARGETS %\n", module);
        {
            auto indent = w.push_indent({ 1 });
            w.write("ARCHIVE DESTINATION lib\n");
            w.write("LIBRARY DESTINATION lib\n");
            w.write("RUNTIME DESTINATION bin\n");
            w.write("COMPONENT lib)\n");
        }

        w.write("\n");

        w.write("target_link_libraries(% PRIVATE", module);
        {
            auto indent = w.push_indent({ 1 });
            w.write("\n%", settings.get_c_module_name());
            for (const auto& dep : depends)
                w.write("\n%", dep);
        }
        w.write(")\n");

        w.write("target_include_directories(%\n", module);
        {
            auto indent = w.push_indent({ 1 });
            w.write("INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n");
            w.write("PRIVATE ${CMAKE_CURRENT_BINARY_DIR})\n");
        }

        w.write("target_include_directories(%\n", module);
        {
            auto indent = w.push_indent({ 1 });
            w.write("INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n");
            w.write("PRIVATE ${GENERATED_FILES_DIR})\n");
        }

        w.save_cmake();
    }

    // Write a package.swift file which includes the full enclosure of Swift modules being generated (including CWinRT) which are generated
    // by the project. This is useful for our test project, which just creates a single module.
    static void write_multimodule_package_swift(std::map<std::string, std::set<std::string>>& module_dependencies)
    {
        writer w;
        auto path = w.root_directory() / "Package.swift";
        if (!settings.has_project_type(project_type::spm))
        {
            std::filesystem::remove(path);
            return;
        }

        auto exclude_cmake = settings.has_project_type(project_type::cmake) ? R"(,
      exclude: [ "CMakeLists.txt" ])" : "";
        auto package = R"(// swift-tools-version: 5.7

// WARNING: Generated by a tool. Do not hand-edit!

import PackageDescription

let package = Package(
  name: "WinRT",
  products: [
%
  ],
  targets: [
    .target(
       name: "CWinRT"%
    ),
%
  ]
)
)";


        w.write(package,
            bind([&](writer& w) {
                separator s{ w, "\n" };
        for (auto&& [module, _] : module_dependencies)
        {
            s();
            w.write(R"(    .library(name: "%", type: .dynamic, targets: ["%"]),)", module, module);
        }}),
            exclude_cmake,
            bind([&](writer& w) {
            for (auto [module, dependencies] : module_dependencies)
            {
                w.write(R"(    .target(
      name: "%",
      dependencies: [
        "CWinRT",
%
      ],
      path: "swift/%"%
    ),
)", module, bind([&](writer& w) {
                        separator s{ w, "\n" };
                for (auto&& ns : dependencies)
                {
                    s();
                    w.write(R"(      "%",)", ns);

                }}),
                    module);
            }}
        ), exclude_cmake);

        w.flush_to_file(path);
    }

    static void write_singlemodule_package_swift(std::string_view const& module, std::set<std::string> const& depends)
    {
        writer w;
        w.type_namespace = module;
        auto path = w.project_directory() / "Package.swift";
        if (!settings.has_project_type(project_type::spm))
        {
            std::filesystem::remove(path);
            return;
        }

        auto exclude_cmake = settings.has_project_type(project_type::cmake) ? R"(,
      exclude: [ "CMakeLists.txt" ])" : "";
        auto package = R"(// swift-tools-version: 5.7

// WARNING: Generated by a tool. Do not hand-edit!

import PackageDescription

let package = Package(
  name: "%",
  products: [ 
    .library(name: "%", type: .dynamic, targets: ["%"])
  ],
  dependencies: [
    .package(path: "../CWinRT"),%
  ],
  targets: [
    .target(
       name: "%",
       dependencies: [
         "CWinRT",%
       ],
       path: "."%
    )
  ]
)
)";


        w.write(package,
            module,
            module, module,
            bind([&](writer& w) {
        for (auto&& module : depends)
        {
            w.write(R"(
    .package(path: "../%"),)", module);
        }}),
            module,
            bind([&](writer& w) {
            for (auto module : depends)
            {
                w.write(R"(
         "%",)", module);
            }}
        ), exclude_cmake);
      
        w.flush_to_file(path);
    }
}
