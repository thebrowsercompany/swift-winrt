// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferbehavior)
public typealias BackgroundTransferBehavior = __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferBehavior
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransfercostpolicy)
public typealias BackgroundTransferCostPolicy = __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferCostPolicy
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferpriority)
public typealias BackgroundTransferPriority = __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferPriority
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferstatus)
public typealias BackgroundTransferStatus = __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransfergroup)
public final class BackgroundTransferGroup : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferGroup
    private typealias CABI = __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CIBackgroundTransferGroup
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CNetworking_CBackgroundTransfer_CIBackgroundTransferGroup>?) -> BackgroundTransferGroup? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static let _IBackgroundTransferGroupStatics: __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferGroupStatics = try! RoGetActivationFactory(HString("Windows.Networking.BackgroundTransfer.BackgroundTransferGroup"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransfergroup.creategroup)
    public static func createGroup(_ name: String) -> BackgroundTransferGroup! {
        return try! _IBackgroundTransferGroupStatics.CreateGroupImpl(name)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransfergroup.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransfergroup.transferbehavior)
    public var transferBehavior : BackgroundTransferBehavior {
        get { try! _default.get_TransferBehaviorImpl() }
        set { try! _default.put_TransferBehaviorImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferrangesdownloadedeventargs)
public final class BackgroundTransferRangesDownloadedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferRangesDownloadedEventArgs
    private typealias CABI = __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CIBackgroundTransferRangesDownloadedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CNetworking_CBackgroundTransfer_CIBackgroundTransferRangesDownloadedEventArgs>?) -> BackgroundTransferRangesDownloadedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferrangesdownloadedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferrangesdownloadedeventargs.addedranges)
    public var addedRanges : WindowsFoundation.AnyIVector<BackgroundTransferFileRange>! {
        get { try! _default.get_AddedRangesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferrangesdownloadedeventargs.wasdownloadrestarted)
    public var wasDownloadRestarted : Bool {
        get { try! _default.get_WasDownloadRestartedImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation)
public final class DownloadOperation : WinRTClass, IBackgroundTransferOperation, IBackgroundTransferOperationPriority {
    private typealias SwiftABI = __ABI_Windows_Networking_BackgroundTransfer.IDownloadOperation
    private typealias CABI = __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CIDownloadOperation
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CNetworking_CBackgroundTransfer_CIDownloadOperation>?) -> DownloadOperation? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IBackgroundTransferOperation: __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperation! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.getresultstreamat)
    public func getResultStreamAt(_ position: UInt64) throws -> UWP.AnyIInputStream! {
        try _IBackgroundTransferOperation.GetResultStreamAtImpl(position)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.getresponseinformation)
    public func getResponseInformation() throws -> ResponseInformation! {
        try _IBackgroundTransferOperation.GetResponseInformationImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.costpolicy)
    public var costPolicy : BackgroundTransferCostPolicy {
        get { try! _IBackgroundTransferOperation.get_CostPolicyImpl() }
        set { try! _IBackgroundTransferOperation.put_CostPolicyImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.group)
    public var group : String {
        get { try! _IBackgroundTransferOperation.get_GroupImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.guid)
    public var guid : Foundation.UUID {
        get { try! _IBackgroundTransferOperation.get_GuidImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.method)
    public var method : String {
        get { try! _IBackgroundTransferOperation.get_MethodImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.requesteduri)
    public var requestedUri : WindowsFoundation.Uri! {
        get { try! _IBackgroundTransferOperation.get_RequestedUriImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.startasync)
    public func startAsync() throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<DownloadOperation?, DownloadOperation?>! {
        try _default.StartAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.attachasync)
    public func attachAsync() throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<DownloadOperation?, DownloadOperation?>! {
        try _default.AttachAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.pause)
    public func pause() throws {
        try _default.PauseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.resume)
    public func resume() throws {
        try _default.ResumeImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.progress)
    public var progress : BackgroundDownloadProgress {
        get { try! _default.get_ProgressImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.resultfile)
    public var resultFile : UWP.AnyIStorageFile! {
        get { try! _default.get_ResultFileImpl() }
    }

    private lazy var _IBackgroundTransferOperationPriority: __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperationPriority! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.priority)
    public var priority : BackgroundTransferPriority {
        get { try! _IBackgroundTransferOperationPriority.get_PriorityImpl() }
        set { try! _IBackgroundTransferOperationPriority.put_PriorityImpl(newValue) }
    }

    private lazy var _IDownloadOperation2: __ABI_Windows_Networking_BackgroundTransfer.IDownloadOperation2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.transfergroup)
    public var transferGroup : BackgroundTransferGroup! {
        get { try! _IDownloadOperation2.get_TransferGroupImpl() }
    }

    private lazy var _IDownloadOperation3: __ABI_Windows_Networking_BackgroundTransfer.IDownloadOperation3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.getresultrandomaccessstreamreference)
    public func getResultRandomAccessStreamReference() throws -> UWP.AnyIRandomAccessStreamReference! {
        try _IDownloadOperation3.GetResultRandomAccessStreamReferenceImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.getdownloadedranges)
    public func getDownloadedRanges() throws -> WindowsFoundation.AnyIVector<BackgroundTransferFileRange>! {
        try _IDownloadOperation3.GetDownloadedRangesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.currentweberrorstatus)
    public var currentWebErrorStatus : UWP.WebErrorStatus? {
        get { try! _IDownloadOperation3.get_CurrentWebErrorStatusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.israndomaccessrequired)
    public var isRandomAccessRequired : Bool {
        get { try! _IDownloadOperation3.get_IsRandomAccessRequiredImpl() }
        set { try! _IDownloadOperation3.put_IsRandomAccessRequiredImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.recoverableweberrorstatuses)
    public var recoverableWebErrorStatuses : WindowsFoundation.AnyIVector<UWP.WebErrorStatus>! {
        get { try! _IDownloadOperation3.get_RecoverableWebErrorStatusesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.requesteduri)
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.rangesdownloaded)
    public lazy var rangesDownloaded : Event<TypedEventHandler<DownloadOperation?, BackgroundTransferRangesDownloadedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IDownloadOperation3 else { return .init() }
          return try! this.add_RangesDownloadedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IDownloadOperation3.remove_RangesDownloadedImpl($0)
       }
      )
    }()

    private lazy var _IDownloadOperation4: __ABI_Windows_Networking_BackgroundTransfer.IDownloadOperation4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.downloadoperation.makecurrentintransfergroup)
    public func makeCurrentInTransferGroup() throws {
        try _IDownloadOperation4.MakeCurrentInTransferGroupImpl()
    }

    deinit {
        _IBackgroundTransferOperation = nil
        _default = nil
        _IBackgroundTransferOperationPriority = nil
        _IDownloadOperation2 = nil
        _IDownloadOperation3 = nil
        _IDownloadOperation4 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.responseinformation)
public final class ResponseInformation : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Networking_BackgroundTransfer.IResponseInformation
    private typealias CABI = __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CIResponseInformation
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CNetworking_CBackgroundTransfer_CIResponseInformation>?) -> ResponseInformation? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.responseinformation.actualuri)
    public var actualUri : WindowsFoundation.Uri! {
        get { try! _default.get_ActualUriImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.responseinformation.headers)
    public var headers : WindowsFoundation.AnyIMapView<String, String>! {
        get { try! _default.get_HeadersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.responseinformation.isresumable)
    public var isResumable : Bool {
        get { try! _default.get_IsResumableImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.responseinformation.statuscode)
    public var statusCode : UInt32 {
        get { try! _default.get_StatusCodeImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgrounddownloadprogress)
public struct BackgroundDownloadProgress: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgrounddownloadprogress.bytesreceived)
    public var bytesReceived: UInt64 = 0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgrounddownloadprogress.totalbytestoreceive)
    public var totalBytesToReceive: UInt64 = 0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgrounddownloadprogress.status)
    public var status: BackgroundTransferStatus = .init(0)
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgrounddownloadprogress.hasresponsechanged)
    public var hasResponseChanged: Bool = false
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgrounddownloadprogress.hasrestarted)
    public var hasRestarted: Bool = false
    public init() {}
    public init(bytesReceived: UInt64, totalBytesToReceive: UInt64, status: BackgroundTransferStatus, hasResponseChanged: Bool, hasRestarted: Bool) {
        self.bytesReceived = bytesReceived
        self.totalBytesToReceive = totalBytesToReceive
        self.status = status
        self.hasResponseChanged = hasResponseChanged
        self.hasRestarted = hasRestarted
    }
    public static func from(abi: __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundDownloadProgress) -> BackgroundDownloadProgress {
        .init(bytesReceived: abi.BytesReceived, totalBytesToReceive: abi.TotalBytesToReceive, status: abi.Status, hasResponseChanged: .init(from: abi.HasResponseChanged), hasRestarted: .init(from: abi.HasRestarted))
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferfilerange)
public struct BackgroundTransferFileRange: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferfilerange.offset)
    public var offset: UInt64 = 0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.backgroundtransferfilerange.length)
    public var length: UInt64 = 0
    public init() {}
    public init(offset: UInt64, length: UInt64) {
        self.offset = offset
        self.length = length
    }
    public static func from(abi: __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferFileRange) -> BackgroundTransferFileRange {
        .init(offset: abi.Offset, length: abi.Length)
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperation)
public protocol IBackgroundTransferOperation : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperation.getresultstreamat)
    func getResultStreamAt(_ position: UInt64) throws -> UWP.AnyIInputStream!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperation.getresponseinformation)
    func getResponseInformation() throws -> UWP.ResponseInformation!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperation.costpolicy)
    var costPolicy: UWP.BackgroundTransferCostPolicy { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperation.group)
    var group: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperation.guid)
    var guid: Foundation.UUID { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperation.method)
    var method: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperation.requesteduri)
    var requestedUri: WindowsFoundation.Uri! { get }
}

extension IBackgroundTransferOperation {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperationWrapper.IID:
                let wrapper = __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperationWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIBackgroundTransferOperation = any IBackgroundTransferOperation

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperationpriority)
public protocol IBackgroundTransferOperationPriority : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.networking.backgroundtransfer.ibackgroundtransferoperationpriority.priority)
    var priority: UWP.BackgroundTransferPriority { get set }
}

extension IBackgroundTransferOperationPriority {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperationPriorityWrapper.IID:
                let wrapper = __ABI_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperationPriorityWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIBackgroundTransferOperationPriority = any IBackgroundTransferOperationPriority

extension UWP.BackgroundTransferBehavior {
    public static var parallel : UWP.BackgroundTransferBehavior {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferBehavior_Parallel
    }
    public static var serialized : UWP.BackgroundTransferBehavior {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferBehavior_Serialized
    }
}
extension UWP.BackgroundTransferBehavior: @retroactive Hashable, @retroactive Codable {}

extension UWP.BackgroundTransferCostPolicy {
    public static var `default` : UWP.BackgroundTransferCostPolicy {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferCostPolicy_Default
    }
    public static var unrestrictedOnly : UWP.BackgroundTransferCostPolicy {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferCostPolicy_UnrestrictedOnly
    }
    public static var always : UWP.BackgroundTransferCostPolicy {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferCostPolicy_Always
    }
}
extension UWP.BackgroundTransferCostPolicy: @retroactive Hashable, @retroactive Codable {}

extension UWP.BackgroundTransferPriority {
    public static var `default` : UWP.BackgroundTransferPriority {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferPriority_Default
    }
    public static var high : UWP.BackgroundTransferPriority {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferPriority_High
    }
    public static var low : UWP.BackgroundTransferPriority {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferPriority_Low
    }
}
extension UWP.BackgroundTransferPriority: @retroactive Hashable, @retroactive Codable {}

extension UWP.BackgroundTransferStatus {
    public static var idle : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_Idle
    }
    public static var running : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_Running
    }
    public static var pausedByApplication : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_PausedByApplication
    }
    public static var pausedCostedNetwork : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_PausedCostedNetwork
    }
    public static var pausedNoNetwork : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_PausedNoNetwork
    }
    public static var completed : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_Completed
    }
    public static var canceled : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_Canceled
    }
    public static var error : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_Error
    }
    public static var pausedRecoverableWebErrorStatus : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_PausedRecoverableWebErrorStatus
    }
    public static var pausedSystemPolicy : UWP.BackgroundTransferStatus {
        __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferStatus_PausedSystemPolicy
    }
}
extension UWP.BackgroundTransferStatus: @retroactive Hashable, @retroactive Codable {}

