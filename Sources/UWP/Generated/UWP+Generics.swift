// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x3f08262e, Data2: 0xa2e1, Data3: 0x5134, Data4: ( 0x92,0x97,0xe9,0x21,0x1f,0x48,0x1a,0x2d ))// 3f08262e-a2e1-5134-9297-e9211f481a2d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<Any?>? = UWP.__x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableBridge>
internal class AsyncOperationCompletedHandlerAny: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<Any?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1_IInspectableWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<Any?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerAny

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean: WindowsFoundation.IID {
    .init(Data1: 0xc1d3d1a2, Data2: 0xae17, Data3: 0x5a5f, Data4: ( 0xb5,0xa2,0xbd,0xcc,0x88,0x44,0x88,0x9a ))// c1d3d1a2-ae17-5a5f-b5a2-bdcc8844889a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<Bool>? = UWP.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanBridge>
internal class AsyncOperationCompletedHandlerBool: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<Bool>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1_booleanWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<Bool>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerBool

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xb79a741f, Data2: 0x7fb5, Data3: 0x50ae, Data4: ( 0x9e,0x99,0x91,0x12,0x01,0xec,0x3d,0x41 ))// b79a741f-7fb5-50ae-9e99-911201ec3d41
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<String>? = UWP.__x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGBridge>
internal class AsyncOperationCompletedHandlerString: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<String>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<String>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerString

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32: WindowsFoundation.IID {
    .init(Data1: 0x9343b6e7, Data2: 0xe3d2, Data3: 0x5e4a, Data4: ( 0xab,0x2d,0x2b,0xce,0x49,0x19,0xa6,0xa4 ))// 9343b6e7-e3d2-5e4a-ab2d-2bce4919a6a4
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32VTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UInt32>? = UWP.__x_ABI_C__FIAsyncOperation_1_UINT32Wrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Bridge>
internal class AsyncOperationCompletedHandlerUInt32: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UInt32>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1_UINT32Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UInt32>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerUInt32

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xee8aeb02, Data2: 0xfb00, Data3: 0x51fa, Data4: ( 0x8f,0x57,0x32,0x58,0x3e,0xa2,0x41,0xf9 ))// ee8aeb02-fb00-51fa-8f57-32583ea241f9
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64VTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UInt64>? = UWP.__x_ABI_C__FIAsyncOperation_1_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Bridge>
internal class AsyncOperationCompletedHandlerUInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UInt64>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerUInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult: WindowsFoundation.IID {
    .init(Data1: 0x841da82d, Data2: 0xa32c, Data3: 0x5997, Data4: ( 0x84,0x50,0xf5,0x4a,0xf1,0xd5,0x47,0x7e ))// 841da82d-a32c-5997-8450-f54af1d5477e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ClipboardHistoryItemsResult?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultBridge>
internal class AsyncOperationCompletedHandlerClipboardHistoryItemsResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ClipboardHistoryItemsResult?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.ClipboardHistoryItemsResult?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerClipboardHistoryItemsResult

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation: WindowsFoundation.IID {
    .init(Data1: 0xadd21d46, Data2: 0x17df, Data3: 0x5a43, Data4: ( 0xa6,0x85,0x32,0x62,0xfc,0xe8,0x46,0x43 ))// add21d46-17df-5a43-a685-3262fce84643
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DataPackageOperation>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge>
internal class AsyncOperationCompletedHandlerDataPackageOperation: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DataPackageOperation>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.DataPackageOperation>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerDataPackageOperation

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup: WindowsFoundation.IID {
    .init(Data1: 0x2253dc38, Data2: 0x9a1a, Data3: 0x5364, Data4: ( 0x9a,0x3b,0x03,0xa7,0xda,0x61,0x54,0x99 ))// 2253dc38-9a1a-5364-9a3b-03a7da615499
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.PackageContentGroup?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge>
internal class AsyncOperationCompletedHandlerPackageContentGroup: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.PackageContentGroup?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.PackageContentGroup?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerPackageContentGroup

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult: WindowsFoundation.IID {
    .init(Data1: 0x4020c034, Data2: 0xc762, Data3: 0x5152, Data4: ( 0xbe,0xef,0xf0,0x34,0x71,0xe8,0x85,0xb9 ))// 4020c034-c762-5152-beef-f03471e885b9
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.PackageUpdateAvailabilityResult?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultBridge>
internal class AsyncOperationCompletedHandlerPackageUpdateAvailabilityResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.PackageUpdateAvailabilityResult?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.PackageUpdateAvailabilityResult?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerPackageUpdateAvailabilityResult

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation: WindowsFoundation.IID {
    .init(Data1: 0xbb483df2, Data2: 0x7bb6, Data3: 0x5923, Data4: ( 0xa2,0x8d,0x83,0x42,0xec,0x30,0x04,0x6b ))// bb483df2-7bb6-5923-a28d-8342ec30046b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DeviceInformation?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge>
internal class AsyncOperationCompletedHandlerDeviceInformation: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DeviceInformation?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.DeviceInformation?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerDeviceInformation

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection: WindowsFoundation.IID {
    .init(Data1: 0x4a458732, Data2: 0x527e, Data3: 0x5c73, Data4: ( 0x9a,0x68,0xa7,0x3d,0xa3,0x70,0xf7,0x82 ))// 4a458732-527e-5c73-9a68-a73da370f782
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DeviceInformationCollection?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionBridge>
internal class AsyncOperationCompletedHandlerDeviceInformationCollection: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DeviceInformationCollection?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.DeviceInformationCollection?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerDeviceInformationCollection

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult: WindowsFoundation.IID {
    .init(Data1: 0x7ee0247f, Data2: 0x5f57, Data3: 0x5cb2, Data4: ( 0xb4,0x0e,0x18,0xb5,0xa2,0x11,0xd6,0xc3 ))// 7ee0247f-5f57-5cb2-b40e-18b5a211d6c3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DevicePairingResult?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultBridge>
internal class AsyncOperationCompletedHandlerDevicePairingResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DevicePairingResult?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.DevicePairingResult?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerDevicePairingResult

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail: WindowsFoundation.IID {
    .init(Data1: 0x86d455b2, Data2: 0xd795, Data3: 0x554c, Data4: ( 0x9c,0x31,0xbf,0x65,0x39,0x34,0x9c,0x19 ))// 86d455b2-d795-554c-9c31-bf6539349c19
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DeviceThumbnail?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailBridge>
internal class AsyncOperationCompletedHandlerDeviceThumbnail: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DeviceThumbnail?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.DeviceThumbnail?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerDeviceThumbnail

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult: WindowsFoundation.IID {
    .init(Data1: 0x9bbe6eb9, Data2: 0xdb2d, Data3: 0x5160, Data4: ( 0xa2,0x0c,0xf0,0xc2,0x65,0xf2,0x0d,0x8e ))// 9bbe6eb9-db2d-5160-a20c-f0c265f20d8e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DeviceUnpairingResult?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultBridge>
internal class AsyncOperationCompletedHandlerDeviceUnpairingResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DeviceUnpairingResult?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.DeviceUnpairingResult?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerDeviceUnpairingResult

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0xd4cb6b80, Data2: 0x821a, Data3: 0x5a7b, Data4: ( 0x89,0x8d,0xd5,0x89,0x17,0xb3,0x1a,0x36 ))// d4cb6b80-821a-5a7b-898d-d58917b31a36
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class AsyncOperationCompletedHandlerIMapViewString_RandomAccessStreamReference: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIMapViewString_RandomAccessStreamReference

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x7344f356, Data2: 0x8399, Data3: 0x5756, Data4: ( 0xa2,0xf8,0xab,0xd5,0x0c,0x41,0x46,0xff ))// 7344f356-8399-5756-a2f8-abd50c4146ff
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIMap<String, Any?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableBridge>
internal class AsyncOperationCompletedHandlerIMapString_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectable }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIMap<String, Any?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIMap<String, Any?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectable
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIMapString_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySet: WindowsFoundation.IID {
    .init(Data1: 0x5075a55f, Data2: 0x68ba, Data3: 0x56f2, Data4: ( 0x97,0xe6,0x9b,0x1c,0xbf,0xa2,0xc5,0xf2 ))// 5075a55f-68ba-56f2-97e6-9b1cbfa2c5f2
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySet {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIPropertySet?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetBridge>
internal class AsyncOperationCompletedHandlerIPropertySet: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySet }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIPropertySet?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySet.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIPropertySet?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySet
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIPropertySet

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x7c7899be, Data2: 0x5f2e, Data3: 0x5bf3, Data4: ( 0xad,0xe5,0xad,0x98,0xb7,0x72,0xc7,0xcd ))// 7c7899be-5f2e-5bf3-ade5-ad98b772c7cd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<String>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGBridge>
internal class AsyncOperationCompletedHandlerIVectorViewString: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<String>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<String>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewString

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo: WindowsFoundation.IID {
    .init(Data1: 0x07f25b6f, Data2: 0xf054, Data3: 0x5649, Data4: ( 0xa5,0xce,0xb3,0x48,0xdd,0xc6,0x18,0xb6 ))// 07f25b6f-f054-5649-a5ce-b348ddc618b6
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AppInfo?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge>
internal class AsyncOperationCompletedHandlerIVectorViewAppInfo: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AppInfo?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AppInfo?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewAppInfo

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry: WindowsFoundation.IID {
    .init(Data1: 0x51c74372, Data2: 0x9452, Data3: 0x57ce, Data4: ( 0x92,0x70,0x76,0x20,0x09,0xfb,0xfe,0x4d ))// 51c74372-9452-57ce-9270-762009fbfe4d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge>
internal class AsyncOperationCompletedHandlerIVectorViewAppListEntry: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewAppListEntry

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume: WindowsFoundation.IID {
    .init(Data1: 0x721241c2, Data2: 0x0b83, Data3: 0x594a, Data4: ( 0x9b,0x61,0xce,0x7f,0x14,0x92,0xc4,0x15 ))// 721241c2-0b83-594a-9b61-ce7f1492c415
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge>
internal class AsyncOperationCompletedHandlerIVectorViewPackageVolume: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewPackageVolume

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup: WindowsFoundation.IID {
    .init(Data1: 0xcff78a64, Data2: 0xbd44, Data3: 0x5638, Data4: ( 0xaf,0x2f,0x54,0x0c,0x23,0xb3,0x22,0xe7 ))// cff78a64-bd44-5638-af2f-540c23b322e7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge>
internal class AsyncOperationCompletedHandlerIVectorViewMediaFrameSourceGroup: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewMediaFrameSourceGroup

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0x96af15cc, Data2: 0xf060, Data3: 0x5667, Data4: ( 0x92,0x23,0xe0,0x54,0xd1,0x42,0x39,0xec ))// 96af15cc-f060-5667-9223-e054d14239ec
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge>
internal class AsyncOperationCompletedHandlerIVectorViewAttributedNetworkUsage: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewAttributedNetworkUsage

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval: WindowsFoundation.IID {
    .init(Data1: 0xb475014c, Data2: 0x95f1, Data3: 0x5310, Data4: ( 0xb5,0xd1,0xc2,0x30,0x9d,0x94,0x44,0x40 ))// b475014c-95f1-5310-b5d1-c2309d944440
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge>
internal class AsyncOperationCompletedHandlerIVectorViewConnectivityInterval: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewConnectivityInterval

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0xe31d7e7e, Data2: 0x4173, Data3: 0x5c71, Data4: ( 0xb0,0x4b,0xa0,0x96,0x58,0x00,0x25,0x90 ))// e31d7e7e-4173-5c71-b04b-a09658002590
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge>
internal class AsyncOperationCompletedHandlerIVectorViewNetworkUsage: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewNetworkUsage

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0xc310276b, Data2: 0x3932, Data3: 0x5da9, Data4: ( 0x9a,0x3b,0xc5,0xc4,0x23,0x58,0x6b,0x42 ))// c310276b-3932-5da9-9a3b-c5c423586b42
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge>
internal class AsyncOperationCompletedHandlerIVectorViewProviderNetworkUsage: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewProviderNetworkUsage

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0x51436e75, Data2: 0xace1, Data3: 0x5a68, Data4: ( 0xb2,0x60,0xf8,0x43,0xb8,0x46,0xf0,0xdb ))// 51436e75-ace1-5a68-b260-f843b846f0db
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemBridge>
internal class AsyncOperationCompletedHandlerIVectorViewIStorageItem: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewIStorageItem

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile: WindowsFoundation.IID {
    .init(Data1: 0xcb4206c5, Data2: 0x0988, Data3: 0x5104, Data4: ( 0xaf,0xa9,0x25,0x3c,0x29,0x8f,0x86,0xfd ))// cb4206c5-0988-5104-afa9-253c298f86fd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileBridge>
internal class AsyncOperationCompletedHandlerIVectorViewStorageFile: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewStorageFile

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder: WindowsFoundation.IID {
    .init(Data1: 0xed2d1d9b, Data2: 0x26ec, Data3: 0x5be7, Data4: ( 0xa8,0xa3,0x56,0x45,0x89,0x33,0xd2,0x5f ))// ed2d1d9b-26ec-5be7-a8a3-56458933d25f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderBridge>
internal class AsyncOperationCompletedHandlerIVectorViewStorageFolder: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewStorageFolder

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange: WindowsFoundation.IID {
    .init(Data1: 0xab9cea41, Data2: 0x6df8, Data3: 0x535d, Data4: ( 0x81,0x71,0x46,0xaf,0xf1,0x87,0x15,0x8f ))// ab9cea41-6df8-535d-8171-46aff187158f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge>
internal class AsyncOperationCompletedHandlerIVectorViewStorageLibraryChange: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewStorageLibraryChange

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser: WindowsFoundation.IID {
    .init(Data1: 0x09870533, Data2: 0xf7cb, Data3: 0x569c, Data4: ( 0xb7,0x97,0xdc,0xb4,0x8d,0xeb,0xd7,0x09 ))// 09870533-f7cb-569c-b797-dcb48debd709
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.User?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserBridge>
internal class AsyncOperationCompletedHandlerIVectorViewUser: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.User?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.User?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorViewUser

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup: WindowsFoundation.IID {
    .init(Data1: 0x52465bf3, Data2: 0x3ca6, Data3: 0x5681, Data4: ( 0xa7,0xb4,0x91,0x84,0x77,0x57,0xb5,0xfd ))// 52465bf3-3ca6-5681-a7b4-91847757b5fd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge>
internal class AsyncOperationCompletedHandlerIVectorPackageContentGroup: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIVectorPackageContentGroup

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUri: WindowsFoundation.IID {
    .init(Data1: 0xad46f1cc, Data2: 0x2bb0, Data3: 0x585c, Data4: ( 0x98,0x85,0x03,0xc2,0x78,0x0d,0x4d,0x58 ))// ad46f1cc-2bb0-585c-9885-03c2780d4d58
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUri {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.Uri?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriBridge>
internal class AsyncOperationCompletedHandlerUri: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUri }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.Uri?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUri.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.Uri?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUri
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerUri

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder: WindowsFoundation.IID {
    .init(Data1: 0xbb6514f2, Data2: 0x3cfb, Data3: 0x566f, Data4: ( 0x82,0xbc,0x60,0xaa,0xbd,0x30,0x2d,0x53 ))// bb6514f2-3cfb-566f-82bc-60aabd302d53
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BitmapDecoder?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderBridge>
internal class AsyncOperationCompletedHandlerBitmapDecoder: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BitmapDecoder?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.BitmapDecoder?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerBitmapDecoder

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder: WindowsFoundation.IID {
    .init(Data1: 0x5df1afc5, Data2: 0x478d, Data3: 0x55dd, Data4: ( 0xb3,0x17,0x02,0x42,0x74,0x06,0x2a,0x0d ))// 5df1afc5-478d-55dd-b317-024274062a0d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BitmapEncoder?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderBridge>
internal class AsyncOperationCompletedHandlerBitmapEncoder: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BitmapEncoder?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.BitmapEncoder?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerBitmapEncoder

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame: WindowsFoundation.IID {
    .init(Data1: 0x2817455a, Data2: 0x983f, Data3: 0x5a06, Data4: ( 0x9f,0xe4,0xfb,0x96,0x37,0x68,0x43,0x20 ))// 2817455a-983f-5a06-9fe4-fb9637684320
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BitmapFrame?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameBridge>
internal class AsyncOperationCompletedHandlerBitmapFrame: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BitmapFrame?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.BitmapFrame?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerBitmapFrame

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet: WindowsFoundation.IID {
    .init(Data1: 0xa8325bd7, Data2: 0xa3be, Data3: 0x5881, Data4: ( 0x9f,0xa7,0x04,0xce,0xef,0xb9,0xdc,0x2f ))// a8325bd7-a3be-5881-9fa7-04ceefb9dc2f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BitmapPropertySet?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetBridge>
internal class AsyncOperationCompletedHandlerBitmapPropertySet: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BitmapPropertySet?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.BitmapPropertySet?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerBitmapPropertySet

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream: WindowsFoundation.IID {
    .init(Data1: 0x29bb8288, Data2: 0x4462, Data3: 0x516e, Data4: ( 0xa6,0x75,0x8c,0x92,0x35,0xc4,0x29,0x94 ))// 29bb8288-4462-516e-a675-8c9235c42994
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ImageStream?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamBridge>
internal class AsyncOperationCompletedHandlerImageStream: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ImageStream?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.ImageStream?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerImageStream

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider: WindowsFoundation.IID {
    .init(Data1: 0x37bdf4be, Data2: 0x2f39, Data3: 0x592c, Data4: ( 0xa4,0xf7,0xd1,0x6a,0x09,0xd2,0xb2,0xdb ))// 37bdf4be-2f39-592c-a4f7-d16a09d2b2db
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.PixelDataProvider?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderBridge>
internal class AsyncOperationCompletedHandlerPixelDataProvider: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.PixelDataProvider?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.PixelDataProvider?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerPixelDataProvider

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap: WindowsFoundation.IID {
    .init(Data1: 0xb699b653, Data2: 0x33ed, Data3: 0x5e2d, Data4: ( 0xa7,0x5f,0x02,0xbf,0x90,0xe3,0x26,0x19 ))// b699b653-33ed-5e2d-a75f-02bf90e32619
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.SoftwareBitmap?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapBridge>
internal class AsyncOperationCompletedHandlerSoftwareBitmap: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.SoftwareBitmap?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.SoftwareBitmap?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerSoftwareBitmap

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume: WindowsFoundation.IID {
    .init(Data1: 0x35fee361, Data2: 0x6cea, Data3: 0x5e5c, Data4: ( 0x8e,0xda,0x34,0xb3,0xf2,0x2d,0xf4,0xe7 ))// 35fee361-6cea-5e5c-8eda-34b3f22df4e7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.PackageVolume?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge>
internal class AsyncOperationCompletedHandlerPackageVolume: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.PackageVolume?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.PackageVolume?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerPackageVolume

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult: WindowsFoundation.IID {
    .init(Data1: 0xd0577f0d, Data2: 0xce46, Data3: 0x5c47, Data4: ( 0x8f,0x7c,0x4a,0xe5,0x62,0x6c,0xc7,0x6d ))// d0577f0d-ce46-5c47-8f7c-4ae5626cc76d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceGetPropertyResult?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultBridge>
internal class AsyncOperationCompletedHandlerMediaFrameSourceGetPropertyResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceGetPropertyResult?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.MediaFrameSourceGetPropertyResult?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerMediaFrameSourceGetPropertyResult

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup: WindowsFoundation.IID {
    .init(Data1: 0xadf10eeb, Data2: 0x9fc5, Data3: 0x553b, Data4: ( 0x91,0x64,0x29,0x42,0x46,0x99,0x2a,0x2a ))// adf10eeb-9fc5-553b-9164-294246992a2a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceGroup?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge>
internal class AsyncOperationCompletedHandlerMediaFrameSourceGroup: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceGroup?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.MediaFrameSourceGroup?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerMediaFrameSourceGroup

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus: WindowsFoundation.IID {
    .init(Data1: 0xf613663a, Data2: 0xc685, Data3: 0x5dc0, Data4: ( 0xb1,0x33,0x60,0xd9,0x43,0x03,0xa6,0xe3 ))// f613663a-c685-5dc0-b133-60d94303a6e3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceSetPropertyStatus>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusBridge>
internal class AsyncOperationCompletedHandlerMediaFrameSourceSetPropertyStatus: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceSetPropertyStatus>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.MediaFrameSourceSetPropertyStatus>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerMediaFrameSourceSetPropertyStatus

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample: WindowsFoundation.IID {
    .init(Data1: 0xdf7aacc9, Data2: 0xa86c, Data3: 0x5c7d, Data4: ( 0xbf,0x98,0xcc,0x37,0x1c,0x97,0xc6,0x7b ))// df7aacc9-a86c-5c7d-bf98-cc371c97c67b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MediaStreamSample?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleBridge>
internal class AsyncOperationCompletedHandlerMediaStreamSample: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MediaStreamSample?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.MediaStreamSample?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerMediaStreamSample

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult: WindowsFoundation.IID {
    .init(Data1: 0xbd68cc00, Data2: 0x724c, Data3: 0x5a76, Data4: ( 0xa4,0x37,0x14,0x64,0xeb,0xdd,0xa4,0xac ))// bd68cc00-724c-5a76-a437-1464ebdda4ac
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AdaptiveMediaSourceCreationResult?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultBridge>
internal class AsyncOperationCompletedHandlerAdaptiveMediaSourceCreationResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AdaptiveMediaSourceCreationResult?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.AdaptiveMediaSourceCreationResult?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerAdaptiveMediaSourceCreationResult

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile: WindowsFoundation.IID {
    .init(Data1: 0xe4f0c96a, Data2: 0x0571, Data3: 0x59f4, Data4: ( 0xa9,0xa9,0xaf,0xac,0x3e,0x61,0xca,0xa0 ))// e4f0c96a-0571-59f4-a9a9-afac3e61caa0
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ConnectionProfile?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileBridge>
internal class AsyncOperationCompletedHandlerConnectionProfile: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ConnectionProfile?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.ConnectionProfile?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerConnectionProfile

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus: WindowsFoundation.IID {
    .init(Data1: 0x3a0fb210, Data2: 0x36c4, Data3: 0x5df2, Data4: ( 0x97,0x07,0x5f,0x32,0x53,0x69,0xa9,0xb0 ))// 3a0fb210-36c4-5df2-9707-5f325369a9b0
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ConnectionProfileDeleteStatus>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusBridge>
internal class AsyncOperationCompletedHandlerConnectionProfileDeleteStatus: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ConnectionProfileDeleteStatus>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.ConnectionProfileDeleteStatus>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerConnectionProfileDeleteStatus

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain: WindowsFoundation.IID {
    .init(Data1: 0x4c3f50e9, Data2: 0x90e3, Data3: 0x5a30, Data4: ( 0x90,0x15,0x4a,0xa0,0x37,0x69,0x04,0xf3 ))// 4c3f50e9-90e3-5a30-9015-4aa0376904f3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.CertificateChain?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainBridge>
internal class AsyncOperationCompletedHandlerCertificateChain: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.CertificateChain?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.CertificateChain?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerCertificateChain

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult: WindowsFoundation.IID {
    .init(Data1: 0x2833ba54, Data2: 0xa4e1, Data3: 0x5c2d, Data4: ( 0x8a,0x7a,0x13,0x6e,0x85,0x10,0xc7,0x8b ))// 2833ba54-a4e1-5c2d-8a7a-136e8510c78b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ProtectionPolicyEvaluationResult>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultBridge>
internal class AsyncOperationCompletedHandlerProtectionPolicyEvaluationResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ProtectionPolicyEvaluationResult>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.ProtectionPolicyEvaluationResult>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerProtectionPolicyEvaluationResult

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties: WindowsFoundation.IID {
    .init(Data1: 0xc8659aae, Data2: 0x4926, Data3: 0x52ad, Data4: ( 0x8f,0x60,0xd8,0x9f,0xe5,0xa8,0xdf,0x5f ))// c8659aae-4926-52ad-8f60-d89fe5a8df5f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BasicProperties?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesBridge>
internal class AsyncOperationCompletedHandlerBasicProperties: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.BasicProperties?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.BasicProperties?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerBasicProperties

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties: WindowsFoundation.IID {
    .init(Data1: 0x4452ed4c, Data2: 0x642b, Data3: 0x501b, Data4: ( 0x96,0x17,0x7d,0x68,0xb4,0xac,0x3c,0x66 ))// 4452ed4c-642b-501b-9617-7d68b4ac3c66
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DocumentProperties?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesBridge>
internal class AsyncOperationCompletedHandlerDocumentProperties: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DocumentProperties?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.DocumentProperties?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerDocumentProperties

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties: WindowsFoundation.IID {
    .init(Data1: 0xc63729bc, Data2: 0xe4c3, Data3: 0x564c, Data4: ( 0xb1,0x37,0x2c,0xb4,0xf5,0x96,0x6a,0x83 ))// c63729bc-e4c3-564c-b137-2cb4f5966a83
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ImageProperties?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesBridge>
internal class AsyncOperationCompletedHandlerImageProperties: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.ImageProperties?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.ImageProperties?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerImageProperties

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties: WindowsFoundation.IID {
    .init(Data1: 0xd84e1312, Data2: 0xd661, Data3: 0x5b7f, Data4: ( 0x95,0x66,0x74,0x21,0xbd,0xed,0xc1,0xea ))// d84e1312-d661-5b7f-9566-7421bdedc1ea
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MusicProperties?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesBridge>
internal class AsyncOperationCompletedHandlerMusicProperties: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.MusicProperties?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.MusicProperties?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerMusicProperties

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail: WindowsFoundation.IID {
    .init(Data1: 0x6d0036f2, Data2: 0xa8a8, Data3: 0x505d, Data4: ( 0xb0,0x42,0xd0,0x87,0xdc,0x1f,0xc1,0xb7 ))// 6d0036f2-a8a8-505d-b042-d087dc1fc1b7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailBridge>
internal class AsyncOperationCompletedHandlerStorageItemThumbnail: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.StorageItemThumbnail?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerStorageItemThumbnail

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties: WindowsFoundation.IID {
    .init(Data1: 0x43401d34, Data2: 0x61ab, Data3: 0x5cf2, Data4: ( 0x92,0x1f,0x55,0xb6,0x16,0x63,0x1d,0x1d ))// 43401d34-61ab-5cf2-921f-55b616631d1d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.VideoProperties?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesBridge>
internal class AsyncOperationCompletedHandlerVideoProperties: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.VideoProperties?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.VideoProperties?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerVideoProperties

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0x92c3102f, Data2: 0xa327, Data3: 0x5318, Data4: ( 0xa6,0xc1,0x76,0xf6,0xb2,0xa0,0xab,0xfb ))// 92c3102f-a327-5318-a6c1-76f6b2a0abfb
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItem {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIStorageItem?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemBridge>
internal class AsyncOperationCompletedHandlerIStorageItem: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItem }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIStorageItem?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.AnyIStorageItem?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItem
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIStorageItem

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState: WindowsFoundation.IID {
    .init(Data1: 0xb67a3cba, Data2: 0xf5f7, Data3: 0x5e51, Data4: ( 0x96,0x8a,0x38,0x51,0x26,0xd1,0xf9,0x18 ))// b67a3cba-f5f7-5e51-968a-385126d1f918
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.IndexedState>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateBridge>
internal class AsyncOperationCompletedHandlerIndexedState: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.IndexedState>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.IndexedState>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIndexedState

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFile: WindowsFoundation.IID {
    .init(Data1: 0xe521c894, Data2: 0x2c26, Data3: 0x5946, Data4: ( 0x9e,0x61,0x2b,0x5e,0x18,0x8d,0x01,0xed ))// e521c894-2c26-5946-9e61-2b5e188d01ed
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFile {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileBridge>
internal class AsyncOperationCompletedHandlerStorageFile: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFile }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.StorageFile?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFile
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerStorageFile

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolder: WindowsFoundation.IID {
    .init(Data1: 0xc211026e, Data2: 0x9e63, Data3: 0x5452, Data4: ( 0xba,0x54,0x3a,0x07,0xd6,0xa9,0x68,0x74 ))// c211026e-9e63-5452-ba54-3a07d6a96874
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolder {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderBridge>
internal class AsyncOperationCompletedHandlerStorageFolder: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolder }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.StorageFolder?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolder
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerStorageFolder

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction: WindowsFoundation.IID {
    .init(Data1: 0xd11739e6, Data2: 0x2995, Data3: 0x5d33, Data4: ( 0xbf,0xff,0x51,0xb6,0x04,0x1f,0x68,0xc1 ))// d11739e6-2995-5d33-bfff-51b6041f68c1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionBridge>
internal class AsyncOperationCompletedHandlerStorageStreamTransaction: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.StorageStreamTransaction?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerStorageStreamTransaction

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer: WindowsFoundation.IID {
    .init(Data1: 0x51c3d2fd, Data2: 0xb8a1, Data3: 0x5620, Data4: ( 0xb7,0x46,0x7e,0xe6,0xd5,0x33,0xac,0xa3 ))// 51c3d2fd-b8a1-5620-b746-7ee6d533aca3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIBuffer?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge>
internal class AsyncOperationCompletedHandlerIBuffer: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIBuffer?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.AnyIBuffer?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIBuffer

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream: WindowsFoundation.IID {
    .init(Data1: 0xd0bd0125, Data2: 0x9049, Data3: 0x57a3, Data4: ( 0xbd,0x66,0xe2,0x52,0x5d,0x98,0xc8,0x14 ))// d0bd0125-9049-57a3-bd66-e2525d98c814
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIInputStream?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamBridge>
internal class AsyncOperationCompletedHandlerIInputStream: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIInputStream?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.AnyIInputStream?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIInputStream

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream: WindowsFoundation.IID {
    .init(Data1: 0x398c4183, Data2: 0x793d, Data3: 0x5b00, Data4: ( 0x81,0x9b,0x4a,0xef,0x92,0x48,0x5e,0x94 ))// 398c4183-793d-5b00-819b-4aef92485e94
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamBridge>
internal class AsyncOperationCompletedHandlerIRandomAccessStream: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStream?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIRandomAccessStream

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0x60847289, Data2: 0xea0b, Data3: 0x5df6, Data4: ( 0x89,0xdf,0xf2,0xc6,0x2c,0xba,0x96,0x93 ))// 60847289-ea0b-5df6-89df-f2c62cba9693
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStreamReference?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceBridge>
internal class AsyncOperationCompletedHandlerIRandomAccessStreamReference: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStreamReference?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStreamReference?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIRandomAccessStreamReference

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType: WindowsFoundation.IID {
    .init(Data1: 0x3dddecf4, Data2: 0x1d39, Data3: 0x58e8, Data4: ( 0x83,0xb1,0xdb,0xed,0x54,0x1c,0x7f,0x35 ))// 3dddecf4-1d39-58e8-83b1-dbed541c7f35
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStreamWithContentType?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeBridge>
internal class AsyncOperationCompletedHandlerIRandomAccessStreamWithContentType: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStreamWithContentType?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStreamWithContentType?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerIRandomAccessStreamWithContentType

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0x3d203732, Data2: 0xded7, Data3: 0x5d32, Data4: ( 0x87,0xe6,0xc1,0x79,0x78,0x1f,0x79,0x1f ))// 3d203732-ded7-5d32-87e6-c179781f791f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.RandomAccessStreamReference?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class AsyncOperationCompletedHandlerRandomAccessStreamReference: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.RandomAccessStreamReference?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.RandomAccessStreamReference?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerRandomAccessStreamReference

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus: WindowsFoundation.IID {
    .init(Data1: 0x198cac52, Data2: 0xabcd, Data3: 0x5529, Data4: ( 0x93,0x3f,0x07,0x1c,0xc9,0x3f,0xd6,0x35 ))// 198cac52-abcd-5529-933f-071cc93fd635
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.LaunchQuerySupportStatus>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusBridge>
internal class AsyncOperationCompletedHandlerLaunchQuerySupportStatus: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.LaunchQuerySupportStatus>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.LaunchQuerySupportStatus>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerLaunchQuerySupportStatus

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResult: WindowsFoundation.IID {
    .init(Data1: 0x70a97bf8, Data2: 0xe0a5, Data3: 0x59bb, Data4: ( 0x91,0x74,0x81,0x2a,0x13,0x1d,0x85,0xa0 ))// 70a97bf8-e0a5-59bb-9174-812a131d85a0
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResult {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.LaunchUriResult?>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultBridge>
internal class AsyncOperationCompletedHandlerLaunchUriResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResult }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.LaunchUriResult?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.LaunchUriResult?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResult
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerLaunchUriResult

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatus: WindowsFoundation.IID {
    .init(Data1: 0x520aa58e, Data2: 0x40d6, Data3: 0x5a57, Data4: ( 0xa6,0xdc,0xcb,0x5f,0xae,0xa5,0xcc,0xa5 ))// 520aa58e-40d6-5a57-a6dc-cb5faea5cca5
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatus {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.LaunchUriStatus>? = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusBridge>
internal class AsyncOperationCompletedHandlerLaunchUriStatus: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatus }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.LaunchUriStatus>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.LaunchUriStatus>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatus
    internal typealias SwiftABI = UWP.AsyncOperationCompletedHandlerLaunchUriStatus

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64: WindowsFoundation.IID {
    .init(Data1: 0x14da7de7, Data2: 0x40df, Data3: 0x5d4c, Data4: ( 0x82,0x3f,0xcf,0x31,0x06,0x25,0xad,0x39 ))// 14da7de7-40df-5d4c-823f-cf310625ad39
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64VTable: __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<String, UInt64>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UInt64 = $2
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Bridge>
internal class AsyncOperationProgressHandlerString_UInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<String, UInt64>?, _ progressInfo: UInt64) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, progressInfo))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<String, UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerString_UInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0xcf0a03f6, Data2: 0xa80a, Data3: 0x5b46, Data4: ( 0x9c,0x80,0xf4,0xad,0x9e,0xd6,0xe2,0xd6 ))// cf0a03f6-a80a-5b46-9c80-f4ad9ed6e2d6
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<String, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.HttpProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationProgressHandlerString_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<String, UWP.HttpProgress>?, _ progressInfo: UWP.HttpProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        let _progressInfo = __ABI_Windows_Web_Http._ABI_HttpProgress(from: progressInfo)
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, _progressInfo.val))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<String, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerString_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32: WindowsFoundation.IID {
    .init(Data1: 0xea0fe405, Data2: 0xd432, Data3: 0x5ac7, Data4: ( 0x9e,0xf8,0x5a,0x65,0xe1,0xf9,0x7d,0x7e ))// ea0fe405-d432-5ac7-9ef8-5a65e1f97d7e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32VTable: __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UInt32, UInt32>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UInt32 = $2
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Bridge>
internal class AsyncOperationProgressHandlerUInt32_UInt32: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UInt32, UInt32>?, _ progressInfo: UInt32) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, progressInfo))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UInt32, UInt32>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerUInt32_UInt32

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xffb2b65d, Data2: 0x4120, Data3: 0x5d13, Data4: ( 0x82,0x6d,0x10,0x78,0x51,0xe6,0xbb,0x1c ))// ffb2b65d-4120-5d13-826d-107851e6bb1c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64VTable: __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UInt64, UInt64>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UInt64 = $2
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Bridge>
internal class AsyncOperationProgressHandlerUInt64_UInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UInt64, UInt64>?, _ progressInfo: UInt64) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, progressInfo))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UInt64, UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerUInt64_UInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress: WindowsFoundation.IID {
    .init(Data1: 0xf1b926d1, Data2: 0x1796, Data3: 0x597a, Data4: ( 0x9b,0xea,0x6c,0x64,0x49,0xd0,0x3e,0xef ))// f1b926d1-1796-597a-9bea-6c6449d03eef
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DeploymentResult?, UWP.DeploymentProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.DeploymentProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressBridge>
internal class AsyncOperationProgressHandlerDeploymentResult_DeploymentProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DeploymentResult?, UWP.DeploymentProgress>?, _ progressInfo: UWP.DeploymentProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, .from(swift: progressInfo)))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.DeploymentResult?, UWP.DeploymentProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerDeploymentResult_DeploymentProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation: WindowsFoundation.IID {
    .init(Data1: 0xb2ff13f1, Data2: 0xc743, Data3: 0x54f4, Data4: ( 0xbc,0xcc,0xf0,0x8e,0x16,0xa8,0x78,0x90 ))// b2ff13f1-c743-54f4-bccc-f08e16a87890
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DownloadOperation?, UWP.DownloadOperation?>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.DownloadOperation? = .from(abi: ComPtr($2))
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationBridge>
internal class AsyncOperationProgressHandlerDownloadOperation_DownloadOperation: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DownloadOperation?, UWP.DownloadOperation?>?, _ progressInfo: UWP.DownloadOperation?) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, RawPointer(progressInfo)))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.DownloadOperation?, UWP.DownloadOperation?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerDownloadOperation_DownloadOperation

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32: WindowsFoundation.IID {
    .init(Data1: 0xbf666554, Data2: 0x7605, Data3: 0x5d9a, Data4: ( 0xb1,0x4e,0x18,0xd8,0xc8,0x47,0x2a,0xfe ))// bf666554-7605-5d9a-b14e-18d8c8472afe
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32VTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt32>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UInt32 = $2
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Bridge>
internal class AsyncOperationProgressHandlerIBuffer_UInt32: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt32>?, _ progressInfo: UInt32) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, progressInfo))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.AnyIBuffer?, UInt32>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerIBuffer_UInt32

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xd17f5eb6, Data2: 0xb422, Data3: 0x5e26, Data4: ( 0xa8,0x17,0x7e,0x0f,0xd0,0x8f,0x75,0xd5 ))// d17f5eb6-b422-5e26-a817-7e0fd08f75d5
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64VTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt64>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UInt64 = $2
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Bridge>
internal class AsyncOperationProgressHandlerIBuffer_UInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt64>?, _ progressInfo: UInt64) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, progressInfo))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.AnyIBuffer?, UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerIBuffer_UInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x9eb2b852, Data2: 0xe019, Data3: 0x5440, Data4: ( 0x8f,0x88,0x0d,0xd7,0xd5,0x6f,0xea,0x47 ))// 9eb2b852-e019-5440-8f88-0dd7d56fea47
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.HttpProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationProgressHandlerIBuffer_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UWP.HttpProgress>?, _ progressInfo: UWP.HttpProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        let _progressInfo = __ABI_Windows_Web_Http._ABI_HttpProgress(from: progressInfo)
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, _progressInfo.val))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.AnyIBuffer?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerIBuffer_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xf9b2e7f6, Data2: 0x762f, Data3: 0x50db, Data4: ( 0x95,0xdd,0x7f,0x6c,0x6e,0xc4,0x70,0x90 ))// f9b2e7f6-762f-50db-95dd-7f6c6ec47090
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64VTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UInt64>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UInt64 = $2
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Bridge>
internal class AsyncOperationProgressHandlerIInputStream_UInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UInt64>?, _ progressInfo: UInt64) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, progressInfo))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.AnyIInputStream?, UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerIInputStream_UInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x04682e89, Data2: 0x6e8b, Data3: 0x54b1, Data4: ( 0xa4,0x66,0x43,0x2e,0x13,0x0c,0xf9,0xa6 ))// 04682e89-6e8b-54b1-a466-432e130cf9a6
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.HttpProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationProgressHandlerIInputStream_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UWP.HttpProgress>?, _ progressInfo: UWP.HttpProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        let _progressInfo = __ABI_Windows_Web_Http._ABI_HttpProgress(from: progressInfo)
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, _progressInfo.val))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.AnyIInputStream?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerIInputStream_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x43624279, Data2: 0x9a68, Data3: 0x5052, Data4: ( 0xa9,0xde,0x19,0x56,0x9b,0x54,0x81,0x8a ))// 43624279-9a68-5052-a9de-19569b54818a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetBufferResult?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.HttpProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationProgressHandlerHttpGetBufferResult_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetBufferResult?, UWP.HttpProgress>?, _ progressInfo: UWP.HttpProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        let _progressInfo = __ABI_Windows_Web_Http._ABI_HttpProgress(from: progressInfo)
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, _progressInfo.val))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.HttpGetBufferResult?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerHttpGetBufferResult_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x5d399e45, Data2: 0x63aa, Data3: 0x52f7, Data4: ( 0xbb,0xb6,0xc7,0x18,0xca,0x64,0xbd,0x2a ))// 5d399e45-63aa-52f7-bbb6-c718ca64bd2a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.HttpProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationProgressHandlerHttpGetInputStreamResult_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>?, _ progressInfo: UWP.HttpProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        let _progressInfo = __ABI_Windows_Web_Http._ABI_HttpProgress(from: progressInfo)
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, _progressInfo.val))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerHttpGetInputStreamResult_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x43516920, Data2: 0xbbfc, Data3: 0x5ba6, Data4: ( 0x9d,0x59,0x8a,0xf3,0x4f,0xc9,0x7b,0x4e ))// 43516920-bbfc-5ba6-9d59-8af34fc97b4e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetStringResult?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.HttpProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationProgressHandlerHttpGetStringResult_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetStringResult?, UWP.HttpProgress>?, _ progressInfo: UWP.HttpProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        let _progressInfo = __ABI_Windows_Web_Http._ABI_HttpProgress(from: progressInfo)
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, _progressInfo.val))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.HttpGetStringResult?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerHttpGetStringResult_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x167f8eda, Data2: 0x2a7a, Data3: 0x56a2, Data4: ( 0xbb,0xa3,0x76,0xd7,0x8e,0x24,0xf1,0x3d ))// 167f8eda-2a7a-56a2-bba3-76d78e24f13d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpRequestResult?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.HttpProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationProgressHandlerHttpRequestResult_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpRequestResult?, UWP.HttpProgress>?, _ progressInfo: UWP.HttpProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        let _progressInfo = __ABI_Windows_Web_Http._ABI_HttpProgress(from: progressInfo)
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, _progressInfo.val))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.HttpRequestResult?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerHttpRequestResult_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x68e4606a, Data2: 0x76ec, Data3: 0x5816, Data4: ( 0xb2,0xfe,0xa0,0x4e,0xcd,0xe4,0x12,0x6a ))// 68e4606a-76ec-5816-b2fe-a04ecde4126a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpResponseMessage?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let progressInfo: UWP.HttpProgress = .from(abi: $2)
        __unwrapped__instance(asyncInfo, progressInfo)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationProgressHandlerHttpResponseMessage_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpResponseMessage?, UWP.HttpProgress>?, _ progressInfo: UWP.HttpProgress) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        let _progressInfo = __ABI_Windows_Web_Http._ABI_HttpProgress(from: progressInfo)
        _ = try perform(as: __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, _progressInfo.val))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationProgressHandler<UWP.HttpResponseMessage?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationProgressHandlerHttpResponseMessage_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, progressInfo) in
            try! _default.InvokeImpl(asyncInfo, progressInfo)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xbd75eebe, Data2: 0xe7b5, Data3: 0x5af6, Data4: ( 0x84,0x15,0xa4,0xb9,0xc9,0x04,0x52,0x02 ))// bd75eebe-e7b5-5af6-8415-a4b9c9045202
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64VTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<String, UInt64>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Bridge>
internal class AsyncOperationWithProgressCompletedHandlerString_UInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<String, UInt64>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<String, UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerString_UInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x98ab9acb, Data2: 0x38db, Data3: 0x588f, Data4: ( 0xa5,0xf9,0x9f,0x48,0x4b,0x22,0x00,0xcd ))// 98ab9acb-38db-588f-a5f9-9f484b2200cd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<String, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerString_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<String, UWP.HttpProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<String, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerString_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32: WindowsFoundation.IID {
    .init(Data1: 0x1e466dc5, Data2: 0x840f, Data3: 0x54f9, Data4: ( 0xb8,0x77,0x5e,0x3a,0x9f,0x4b,0x6c,0x74 ))// 1e466dc5-840f-54f9-b877-5e3a9f4b6c74
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32VTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UInt32, UInt32>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Bridge>
internal class AsyncOperationWithProgressCompletedHandlerUInt32_UInt32: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UInt32, UInt32>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UInt32, UInt32>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerUInt32_UInt32

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xd2024e41, Data2: 0x5500, Data3: 0x5b5a, Data4: ( 0xba,0x46,0xcb,0x70,0x09,0x59,0x6a,0x2f ))// d2024e41-5500-5b5a-ba46-cb7009596a2f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64VTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UInt64, UInt64>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Bridge>
internal class AsyncOperationWithProgressCompletedHandlerUInt64_UInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UInt64, UInt64>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UInt64, UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerUInt64_UInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress: WindowsFoundation.IID {
    .init(Data1: 0x6e1c7129, Data2: 0x61e0, Data3: 0x5d88, Data4: ( 0x9f,0xd4,0xf3,0xce,0x65,0xa0,0x57,0x19 ))// 6e1c7129-61e0-5d88-9fd4-f3ce65a05719
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DeploymentResult?, UWP.DeploymentProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerDeploymentResult_DeploymentProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DeploymentResult?, UWP.DeploymentProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.DeploymentResult?, UWP.DeploymentProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerDeploymentResult_DeploymentProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation: WindowsFoundation.IID {
    .init(Data1: 0x781b479c, Data2: 0x0207, Data3: 0x5d15, Data4: ( 0xa4,0xe5,0x78,0x37,0xd1,0x3b,0xf9,0x3d ))// 781b479c-0207-5d15-a4e5-7837d13bf93d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DownloadOperation?, UWP.DownloadOperation?>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationBridge>
internal class AsyncOperationWithProgressCompletedHandlerDownloadOperation_DownloadOperation: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DownloadOperation?, UWP.DownloadOperation?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.DownloadOperation?, UWP.DownloadOperation?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerDownloadOperation_DownloadOperation

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32: WindowsFoundation.IID {
    .init(Data1: 0x06386a7a, Data2: 0xe009, Data3: 0x5b0b, Data4: ( 0xab,0x68,0xa8,0xe4,0x8b,0x51,0x66,0x47 ))// 06386a7a-e009-5b0b-ab68-a8e48b516647
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32VTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt32>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Bridge>
internal class AsyncOperationWithProgressCompletedHandlerIBuffer_UInt32: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt32>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UInt32>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerIBuffer_UInt32

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xabc81235, Data2: 0x39c7, Data3: 0x59bf, Data4: ( 0x99,0x48,0x2d,0x14,0xa9,0x3d,0x40,0xfd ))// abc81235-39c7-59bf-9948-2d14a93d40fd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64VTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt64>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Bridge>
internal class AsyncOperationWithProgressCompletedHandlerIBuffer_UInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt64>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerIBuffer_UInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0xb0cf2f85, Data2: 0x6992, Data3: 0x52be, Data4: ( 0x8f,0x0b,0x93,0x96,0x4b,0x14,0xd9,0x63 ))// b0cf2f85-6992-52be-8f0b-93964b14d963
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerIBuffer_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UWP.HttpProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerIBuffer_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64: WindowsFoundation.IID {
    .init(Data1: 0x8db69706, Data2: 0x3dd1, Data3: 0x5a28, Data4: ( 0x98,0x6a,0x93,0xbe,0x07,0x76,0xd9,0xc3 ))// 8db69706-3dd1-5a28-986a-93be0776d9c3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64 {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64VTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64VTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UInt64>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Bridge>
internal class AsyncOperationWithProgressCompletedHandlerIInputStream_UInt64: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64 }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UInt64>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Bridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.AnyIInputStream?, UInt64>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerIInputStream_UInt64

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x504a34ec, Data2: 0x5499, Data3: 0x5a16, Data4: ( 0xbf,0xfc,0x3c,0xcb,0x64,0xa3,0x54,0x7a ))// 504a34ec-5499-5a16-bffc-3ccb64a3547a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerIInputStream_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UWP.HttpProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.AnyIInputStream?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerIInputStream_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x6bec534a, Data2: 0x1901, Data3: 0x5fa2, Data4: ( 0x96,0x86,0x9a,0x51,0x0f,0x6b,0x12,0x17 ))// 6bec534a-1901-5fa2-9686-9a510f6b1217
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetBufferResult?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerHttpGetBufferResult_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetBufferResult?, UWP.HttpProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.HttpGetBufferResult?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerHttpGetBufferResult_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x789b1519, Data2: 0x4ae1, Data3: 0x5475, Data4: ( 0xbb,0x01,0x67,0x34,0xca,0xd4,0x78,0xff ))// 789b1519-4ae1-5475-bb01-6734cad478ff
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerHttpGetInputStreamResult_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerHttpGetInputStreamResult_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x625df3b5, Data2: 0xbff7, Data3: 0x517a, Data4: ( 0x93,0x59,0x1d,0xc2,0x8f,0xb0,0xf5,0x86 ))// 625df3b5-bff7-517a-9359-1dc28fb0f586
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetStringResult?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerHttpGetStringResult_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetStringResult?, UWP.HttpProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.HttpGetStringResult?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerHttpGetStringResult_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0xfdfc3d8f, Data2: 0x08bb, Data3: 0x5d82, Data4: ( 0xbf,0xde,0xae,0x09,0x2e,0x7e,0x3f,0xe1 ))// fdfc3d8f-08bb-5d82-bfde-ae092e7e3fe1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpRequestResult?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerHttpRequestResult_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpRequestResult?, UWP.HttpProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.HttpRequestResult?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerHttpRequestResult_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0xbeadb572, Data2: 0xf9a3, Data3: 0x5e93, Data4: ( 0xb6,0xca,0xe3,0x11,0xb6,0x59,0x33,0xfc ))// beadb572-f9a3-5e93-b6ca-e311b65933fc
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpResponseMessage?, UWP.HttpProgress>? = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1))
        let asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class AsyncOperationWithProgressCompletedHandlerHttpResponseMessage_HttpProgress: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpResponseMessage?, UWP.HttpProgress>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        let asyncInfoWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(asyncInfo)
        let _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationWithProgressCompletedHandler<UWP.HttpResponseMessage?, UWP.HttpProgress>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = UWP.AsyncOperationWithProgressCompletedHandlerHttpResponseMessage_HttpProgress

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIIterable_1_float: WindowsFoundation.IID {
    .init(Data1: 0xb01bee51, Data2: 0x063a, Data3: 0x5fda, Data4: ( 0xbd,0x72,0xd7,0x66,0x37,0xbb,0x8c,0xb8 ))// b01bee51-063a-5fda-bd72-d76637bb8cb8
}

internal var __x_ABI_C__FIIterable_1_floatVTable: __x_ABI_C__FIIterable_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1_floatWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1_floatWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1_floatWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1_floatWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1_floatBridge>
internal class IIterableFloat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1_float }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<Float>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1_float.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1_floatWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1_floatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1_float
    internal typealias SwiftABI = IIterableFloat
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<Float>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1_floatImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1_floatImpl : IIterable, AbiInterfaceImpl {
    typealias T = Float
    typealias Bridge = __x_ABI_C__FIIterable_1_floatBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<Float>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1_GUID: WindowsFoundation.IID {
    .init(Data1: 0xf4ca3045, Data2: 0x5dd7, Data3: 0x54be, Data4: ( 0x98,0x2e,0xd8,0x8d,0x8c,0xa0,0x87,0x6e ))// f4ca3045-5dd7-54be-982e-d88d8ca0876e
}

internal var __x_ABI_C__FIIterable_1_GUIDVTable: __x_ABI_C__FIIterable_1_GUIDVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1_GUIDWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1_GUIDWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1_GUIDWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1_GUIDWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Foundation.UUID>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1_GUIDWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1_GUIDWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1_GUIDWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1_GUIDBridge>
internal class IIterableUUID: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1_GUID }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<Foundation.UUID>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1_GUID.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1_GUIDWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1_GUIDBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1_GUID
    internal typealias SwiftABI = IIterableUUID
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<Foundation.UUID>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1_GUIDImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1_GUIDVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1_GUIDImpl : IIterable, AbiInterfaceImpl {
    typealias T = Foundation.UUID
    typealias Bridge = __x_ABI_C__FIIterable_1_GUIDBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<Foundation.UUID>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xe2fcc7c1, Data2: 0x3bfc, Data3: 0x5a0b, Data4: ( 0xb2,0xb0,0x72,0xe7,0x69,0xd1,0xcb,0x7e ))// e2fcc7c1-3bfc-5a0b-b2b0-72e769d1cb7e
}

internal var __x_ABI_C__FIIterable_1_HSTRINGVTable: __x_ABI_C__FIIterable_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1_HSTRINGBridge>
internal class IIterableString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1_HSTRING }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1_HSTRING
    internal typealias SwiftABI = IIterableString
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1_HSTRINGImpl : IIterable, AbiInterfaceImpl {
    typealias T = String
    typealias Bridge = __x_ABI_C__FIIterable_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<String>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1_UINT32: WindowsFoundation.IID {
    .init(Data1: 0x421d4b91, Data2: 0xb13b, Data3: 0x5f37, Data4: ( 0xae,0x54,0xb5,0x24,0x9b,0xd8,0x05,0x39 ))// 421d4b91-b13b-5f37-ae54-b5249bd80539
}

internal var __x_ABI_C__FIIterable_1_UINT32VTable: __x_ABI_C__FIIterable_1_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1_UINT32Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1_UINT32Wrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<UInt32>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1_UINT32Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1_UINT32Bridge>
internal class IIterableUInt32: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1_UINT32 }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UInt32>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1_UINT32.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1_UINT32Wrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1_UINT32Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1_UINT32
    internal typealias SwiftABI = IIterableUInt32
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UInt32>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1_UINT32Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1_UINT32VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1_UINT32Impl : IIterable, AbiInterfaceImpl {
    typealias T = UInt32
    typealias Bridge = __x_ABI_C__FIIterable_1_UINT32Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UInt32>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfo: WindowsFoundation.IID {
    .init(Data1: 0x63d0bffe, Data2: 0x0e34, Data3: 0x55b3, Data4: ( 0x83,0xd5,0x31,0x4c,0xaf,0xf2,0xb1,0x37 ))// 63d0bffe-0e34-55b3-83d5-314caff2b137
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.ApplicationModel.AppInfo>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge>
internal class IIterableAppInfo: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfo }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AppInfo?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfo
    internal typealias SwiftABI = IIterableAppInfo
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AppInfo?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AppInfo?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AppInfo?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry: WindowsFoundation.IID {
    .init(Data1: 0x86f4d4ef, Data2: 0xd8fd, Data3: 0x5fb5, Data4: ( 0x80,0x7c,0x72,0xda,0x8f,0xc9,0xe5,0x44 ))// 86f4d4ef-d8fd-5fb5-807c-72da8fc9e544
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.ApplicationModel.Core.AppListEntry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge>
internal class IIterableAppListEntry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AppListEntry?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry
    internal typealias SwiftABI = IIterableAppListEntry
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AppListEntry?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AppListEntry?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AppListEntry?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem: WindowsFoundation.IID {
    .init(Data1: 0x5c3705f4, Data2: 0x8e46, Data3: 0x5ae5, Data4: ( 0x97,0xbf,0x88,0x22,0x0c,0xcc,0xff,0xd9 ))// 5c3705f4-8e46-5ae5-97bf-88220cccffd9
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.ApplicationModel.DataTransfer.ClipboardHistoryItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge>
internal class IIterableClipboardHistoryItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.ClipboardHistoryItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem
    internal typealias SwiftABI = IIterableClipboardHistoryItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.ClipboardHistoryItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.ClipboardHistoryItem?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ClipboardHistoryItem?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider: WindowsFoundation.IID {
    .init(Data1: 0x0903b218, Data2: 0x5cad, Data3: 0x53e6, Data4: ( 0x9a,0x21,0x6f,0x4b,0x31,0xc4,0xa4,0x09 ))// 0903b218-5cad-53e6-9a21-6f4b31c4a409
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.ApplicationModel.DataTransfer.ShareProvider>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge>
internal class IIterableShareProvider: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.ShareProvider?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider
    internal typealias SwiftABI = IIterableShareProvider
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.ShareProvider?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.ShareProvider?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ShareProvider?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackage: WindowsFoundation.IID {
    .init(Data1: 0x69ad6aa7, Data2: 0x0c49, Data3: 0x5f27, Data4: ( 0xa5,0xeb,0xef,0x4d,0x59,0x46,0x7b,0x6d ))// 69ad6aa7-0c49-5f27-a5eb-ef4d59467b6d
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.ApplicationModel.Package>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageBridge>
internal class IIterablePackage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackage }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.Package?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackage
    internal typealias SwiftABI = IIterablePackage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.Package?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.Package?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Package?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup: WindowsFoundation.IID {
    .init(Data1: 0xd7dd1456, Data2: 0x4805, Data3: 0x5768, Data4: ( 0xa2,0x5d,0x99,0x64,0x1b,0x09,0x64,0x91 ))// d7dd1456-4805-5768-a25d-99641b096491
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.ApplicationModel.PackageContentGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge>
internal class IIterablePackageContentGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.PackageContentGroup?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup
    internal typealias SwiftABI = IIterablePackageContentGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.PackageContentGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.PackageContentGroup?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PackageContentGroup?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegment: WindowsFoundation.IID {
    .init(Data1: 0x5498f4f3, Data2: 0xcee4, Data3: 0x5b72, Data4: ( 0x97,0x29,0x81,0x5c,0x4a,0xd7,0xb9,0xdc ))// 5498f4f3-cee4-5b72-9729-815c4ad7b9dc
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Data.Text.TextSegment>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge>
internal class IIterableTextSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegment }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.TextSegment>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegment
    internal typealias SwiftABI = IIterableTextSegment
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.TextSegment>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.TextSegment
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TextSegment>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation: WindowsFoundation.IID {
    .init(Data1: 0xdd9f8a5d, Data2: 0xec98, Data3: 0x5f4b, Data4: ( 0xa3,0xea,0x9c,0x8b,0x5a,0xd5,0x3c,0x4b ))// dd9f8a5d-ec98-5f4b-a3ea-9c8b5ad53c4b
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Devices.Enumeration.DeviceInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge>
internal class IIterableDeviceInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.DeviceInformation?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation
    internal typealias SwiftABI = IIterableDeviceInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.DeviceInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.DeviceInformation?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.DeviceInformation?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind: WindowsFoundation.IID {
    .init(Data1: 0xf04365ab, Data2: 0xd3f3, Data3: 0x5f85, Data4: ( 0xa7,0xda,0xdc,0x19,0xcf,0xf7,0x3d,0x86 ))// f04365ab-d3f3-5f85-a7da-dc19cff73d86
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Devices.Enumeration.DeviceWatcherEventKind>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindBridge>
internal class IIterableDeviceWatcherEventKind: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.DeviceWatcherEventKind>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind
    internal typealias SwiftABI = IIterableDeviceWatcherEventKind
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.DeviceWatcherEventKind>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.DeviceWatcherEventKind
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.DeviceWatcherEventKind>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice: WindowsFoundation.IID {
    .init(Data1: 0xad26662c, Data2: 0x845b, Data3: 0x5c6d, Data4: ( 0xae,0xaa,0x40,0x6f,0x48,0xc2,0x1a,0xe9 ))// ad26662c-845b-5c6d-aeaa-406f48c21ae9
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Devices.Input.PointerDevice>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge>
internal class IIterablePointerDevice: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.PointerDevice?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice
    internal typealias SwiftABI = IIterablePointerDevice
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.PointerDevice?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.PointerDevice?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PointerDevice?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage: WindowsFoundation.IID {
    .init(Data1: 0x592d6618, Data2: 0xeaab, Data3: 0x5a79, Data4: ( 0xa4,0x7a,0xc7,0xfc,0x0b,0x74,0x9a,0x4e ))// 592d6618-eaab-5a79-a47a-c7fc0b749a4e
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Devices.Input.PointerDeviceUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge>
internal class IIterablePointerDeviceUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.PointerDeviceUsage>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage
    internal typealias SwiftABI = IIterablePointerDeviceUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.PointerDeviceUsage>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.PointerDeviceUsage
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PointerDeviceUsage>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xf3b20528, Data2: 0xe3b3, Data3: 0x5331, Data4: ( 0xb2,0xd0,0x0c,0x26,0x23,0xae,0xe7,0x85 ))// f3b20528-e3b3-5331-b2d0-0c2623aee785
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Any>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge>
internal class IIterableIKeyValuePairUUID_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable
    internal typealias SwiftABI = IIterableIKeyValuePairUUID_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration: WindowsFoundation.IID {
    .init(Data1: 0x62ae0fda, Data2: 0xb238, Data3: 0x554f, Data4: ( 0xa2,0x75,0x1d,0xc1,0x6d,0x6c,0xa0,0x3a ))// 62ae0fda-b238-554f-a275-1dc16d6ca03a
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Windows.ApplicationModel.Background.BackgroundTaskRegistration>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge>
internal class IIterableIKeyValuePairUUID_BackgroundTaskRegistration: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration
    internal typealias SwiftABI = IIterableIKeyValuePairUUID_BackgroundTaskRegistration
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration: WindowsFoundation.IID {
    .init(Data1: 0x80fb0327, Data2: 0x5a00, Data3: 0x55cc, Data4: ( 0x85,0xdb,0xa8,0x52,0x71,0x99,0x81,0xb9 ))// 80fb0327-5a00-55cc-85db-a852719981b9
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Windows.ApplicationModel.Background.IBackgroundTaskRegistration>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge>
internal class IIterableIKeyValuePairUUID_IBackgroundTaskRegistration: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration
    internal typealias SwiftABI = IIterableIKeyValuePairUUID_IBackgroundTaskRegistration
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xfe2f3d47, Data2: 0x5d47, Data3: 0x5499, Data4: ( 0x83,0x74,0x43,0x0c,0x7c,0xda,0x02,0x04 ))// fe2f3d47-5d47-5499-8374-430c7cda0204
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Any>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge>
internal class IIterableIKeyValuePairString_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, Any?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable
    internal typealias SwiftABI = IIterableIKeyValuePairString_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<String, Any?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, Any?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, Any?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xe9bdaaf0, Data2: 0xcbf6, Data3: 0x5c72, Data4: ( 0xbe,0x90,0x29,0xcb,0xf3,0xa1,0x31,0x9b ))// e9bdaaf0-cbf6-5c72-be90-29cbf3a1319b
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, String>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge>
internal class IIterableIKeyValuePairString_String: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, String>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING
    internal typealias SwiftABI = IIterableIKeyValuePairString_String
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<String, String>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, String>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, String>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup: WindowsFoundation.IID {
    .init(Data1: 0x04428524, Data2: 0x7d54, Data3: 0x59b4, Data4: ( 0xbf,0x17,0xac,0x57,0xc4,0xce,0x6b,0x40 ))// 04428524-7d54-59b4-bf17-ac57c4ce6b40
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge>
internal class IIterableIKeyValuePairString_BackgroundTaskRegistrationGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup
    internal typealias SwiftABI = IIterableIKeyValuePairString_BackgroundTaskRegistrationGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment: WindowsFoundation.IID {
    .init(Data1: 0xf819a276, Data2: 0xb3f5, Data3: 0x54d4, Data4: ( 0xb8,0xfd,0xc9,0xad,0xb7,0xf7,0x00,0xe3 ))// f819a276-b3f5-54d4-b8fd-c9adb7f700e3
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Foundation.Collections.IVectorView`1<Windows.Data.Text.TextSegment>>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge>
internal class IIterableIKeyValuePairString_IVectorViewTextSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment
    internal typealias SwiftABI = IIterableIKeyValuePairString_IVectorViewTextSegment
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x4fed2669, Data2: 0xd0d3, Data3: 0x59f6, Data4: ( 0x91,0xd9,0x95,0x90,0x2d,0x72,0x8d,0x6a ))// 4fed2669-d0d3-59f6-91d9-95902d728d6a
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Foundation.Collections.IVector`1<String>>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge>
internal class IIterableIKeyValuePairString_IVectorString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING
    internal typealias SwiftABI = IIterableIKeyValuePairString_IVectorString
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue: WindowsFoundation.IID {
    .init(Data1: 0x05f9430c, Data2: 0x2f22, Data3: 0x5638, Data4: ( 0xaa,0x89,0x8c,0x9a,0xbc,0xd5,0x4f,0xf9 ))// 05f9430c-2f22-5638-aa89-8c9abcd54ff9
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Graphics.Imaging.BitmapTypedValue>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge>
internal class IIterableIKeyValuePairString_BitmapTypedValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue
    internal typealias SwiftABI = IIterableIKeyValuePairString_BitmapTypedValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0xc9729ba7, Data2: 0x5e20, Data3: 0x569d, Data4: ( 0xa3,0xd1,0x97,0xa4,0xe6,0x53,0xe5,0xbb ))// c9729ba7-5e20-569d-a3d1-97a4e653e5bb
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Storage.Streams.RandomAccessStreamReference>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class IIterableIKeyValuePairString_RandomAccessStreamReference: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = IIterableIKeyValuePairString_RandomAccessStreamReference
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase: WindowsFoundation.IID {
    .init(Data1: 0xc739c420, Data2: 0x64b2, Data3: 0x53f2, Data4: ( 0x89,0xb9,0x05,0x90,0x6a,0xba,0x7c,0xb0 ))// c739c420-64b2-53f2-89b9-05906aba7cb0
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.UI.Composition.ICompositionAnimationBase>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge>
internal class IIterableIKeyValuePairString_ICompositionAnimationBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase
    internal typealias SwiftABI = IIterableIKeyValuePairString_ICompositionAnimationBase
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUri: WindowsFoundation.IID {
    .init(Data1: 0xb0d63b78, Data2: 0x78ad, Data3: 0x5e31, Data4: ( 0xb6,0xd8,0xe3,0x2a,0x0e,0x16,0xc4,0x47 ))// b0d63b78-78ad-5e31-b6d8-e32a0e16c447
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Uri>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriBridge>
internal class IIterableUri: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUri }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.Uri?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUri.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUri
    internal typealias SwiftABI = IIterableUri
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.Uri?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.Uri?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CUriBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.Uri?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguage: WindowsFoundation.IID {
    .init(Data1: 0x48409a10, Data2: 0x61b6, Data3: 0x5db1, Data4: ( 0xa6,0x9d,0x8a,0xbc,0x46,0xac,0x60,0x8a ))// 48409a10-61b6-5db1-a69d-8abc46ac608a
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Globalization.Language>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageBridge>
internal class IIterableLanguage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguage }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.Language?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguage
    internal typealias SwiftABI = IIterableLanguage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.Language?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.Language?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Language?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation: WindowsFoundation.IID {
    .init(Data1: 0x2b6bdb90, Data2: 0xa4eb, Data3: 0x5142, Data4: ( 0xb5,0x82,0x3c,0xcb,0x1e,0xdc,0x57,0x89 ))// 2b6bdb90-a4eb-5142-b582-3ccb1edc5789
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Graphics.Imaging.BitmapCodecInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge>
internal class IIterableBitmapCodecInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.BitmapCodecInformation?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation
    internal typealias SwiftABI = IIterableBitmapCodecInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.BitmapCodecInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.BitmapCodecInformation?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.BitmapCodecInformation?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation: WindowsFoundation.IID {
    .init(Data1: 0x341348b9, Data2: 0x52c8, Data3: 0x5b57, Data4: ( 0x9e,0x91,0xf1,0x9f,0x2a,0x05,0xb1,0x88 ))// 341348b9-52c8-5b57-9e91-f19f2a05b188
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Management.Deployment.PackageUserInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationBridge>
internal class IIterablePackageUserInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.PackageUserInformation?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation
    internal typealias SwiftABI = IIterablePackageUserInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.PackageUserInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.PackageUserInformation?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PackageUserInformation?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume: WindowsFoundation.IID {
    .init(Data1: 0xa6199162, Data2: 0xb163, Data3: 0x56a1, Data4: ( 0x99,0x80,0xdb,0x0c,0x3f,0x4e,0x92,0x84 ))// a6199162-b163-56a1-9980-db0c3f4e9284
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Management.Deployment.PackageVolume>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge>
internal class IIterablePackageVolume: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.PackageVolume?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume
    internal typealias SwiftABI = IIterablePackageVolume
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.PackageVolume?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.PackageVolume?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PackageVolume?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat: WindowsFoundation.IID {
    .init(Data1: 0x1f029a27, Data2: 0x1123, Data3: 0x538a, Data4: ( 0x92,0x61,0x8a,0x38,0x0e,0x12,0xba,0xc6 ))// 1f029a27-1123-538a-9261-8a380e12bac6
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Capture.Frames.MediaFrameFormat>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge>
internal class IIterableMediaFrameFormat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MediaFrameFormat?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat
    internal typealias SwiftABI = IIterableMediaFrameFormat
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MediaFrameFormat?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameFormat?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaFrameFormat?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup: WindowsFoundation.IID {
    .init(Data1: 0xd0b71deb, Data2: 0x76e8, Data3: 0x5833, Data4: ( 0x96,0x23,0x2b,0x1e,0x1a,0x8e,0x1b,0x72 ))// d0b71deb-76e8-5833-9623-2b1e1a8e1b72
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Capture.Frames.MediaFrameSourceGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge>
internal class IIterableMediaFrameSourceGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MediaFrameSourceGroup?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup
    internal typealias SwiftABI = IIterableMediaFrameSourceGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MediaFrameSourceGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameSourceGroup?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaFrameSourceGroup?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo: WindowsFoundation.IID {
    .init(Data1: 0x2e29c5b0, Data2: 0x6aa9, Data3: 0x50f2, Data4: ( 0x91,0xa4,0x5b,0x67,0xa5,0x59,0x8f,0x2e ))// 2e29c5b0-6aa9-50f2-91a4-5b67a5598f2e
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Capture.Frames.MediaFrameSourceInfo>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge>
internal class IIterableMediaFrameSourceInfo: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MediaFrameSourceInfo?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo
    internal typealias SwiftABI = IIterableMediaFrameSourceInfo
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MediaFrameSourceInfo?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameSourceInfo?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaFrameSourceInfo?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription: WindowsFoundation.IID {
    .init(Data1: 0x0895e56d, Data2: 0xfe1f, Data3: 0x5364, Data4: ( 0xab,0x67,0xc5,0x97,0xd8,0x97,0x0b,0x89 ))// 0895e56d-fe1f-5364-ab67-c597d8970b89
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge>
internal class IIterableMediaCaptureVideoProfileMediaDescription: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MediaCaptureVideoProfileMediaDescription?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription
    internal typealias SwiftABI = IIterableMediaCaptureVideoProfileMediaDescription
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MediaCaptureVideoProfileMediaDescription?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MediaCaptureVideoProfileMediaDescription?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaCaptureVideoProfileMediaDescription?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack: WindowsFoundation.IID {
    .init(Data1: 0xb3be50a8, Data2: 0x9856, Data3: 0x5656, Data4: ( 0xab,0x6d,0xcd,0x58,0xf9,0xde,0x0a,0x4f ))// b3be50a8-9856-5656-ab6d-cd58f9de0a4f
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Core.AudioTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge>
internal class IIterableAudioTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AudioTrack?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack
    internal typealias SwiftABI = IIterableAudioTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AudioTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AudioTrack?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AudioTrack?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue: WindowsFoundation.IID {
    .init(Data1: 0x737a2098, Data2: 0x41bf, Data3: 0x5d9f, Data4: ( 0xa1,0xd2,0x2f,0x17,0x1c,0x57,0x8b,0x3c ))// 737a2098-41bf-5d9f-a1d2-2f171c578b3c
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Core.IMediaCue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge>
internal class IIterableIMediaCue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AnyIMediaCue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue
    internal typealias SwiftABI = IIterableIMediaCue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AnyIMediaCue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AnyIMediaCue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AnyIMediaCue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer: WindowsFoundation.IID {
    .init(Data1: 0x5ca0da86, Data2: 0x6307, Data3: 0x558a, Data4: ( 0x86,0x5f,0x3a,0x1e,0xf9,0xfe,0x56,0xb3 ))// 5ca0da86-6307-558a-865f-3a1ef9fe56b3
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Core.MseSourceBuffer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge>
internal class IIterableMseSourceBuffer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MseSourceBuffer?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer
    internal typealias SwiftABI = IIterableMseSourceBuffer
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MseSourceBuffer?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MseSourceBuffer?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MseSourceBuffer?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange: WindowsFoundation.IID {
    .init(Data1: 0xed0c6e08, Data2: 0xe22f, Data3: 0x5ac2, Data4: ( 0xba,0x14,0xe0,0xff,0x1d,0xf3,0x46,0x7f ))// ed0c6e08-e22f-5ac2-ba14-e0ff1df3467f
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Core.MseTimeRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge>
internal class IIterableMseTimeRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MseTimeRange>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange
    internal typealias SwiftABI = IIterableMseTimeRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MseTimeRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MseTimeRange
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MseTimeRange>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack: WindowsFoundation.IID {
    .init(Data1: 0x150a4454, Data2: 0x03bb, Data3: 0x5dd1, Data4: ( 0x81,0x53,0x6a,0x60,0x0e,0x85,0x1f,0x71 ))// 150a4454-03bb-5dd1-8153-6a600e851f71
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Core.TimedMetadataTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge>
internal class IIterableTimedMetadataTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.TimedMetadataTrack?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack
    internal typealias SwiftABI = IIterableTimedMetadataTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.TimedMetadataTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.TimedMetadataTrack?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TimedMetadataTrack?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource: WindowsFoundation.IID {
    .init(Data1: 0x4fc57282, Data2: 0x0edf, Data3: 0x5d85, Data4: ( 0x9d,0x89,0xdd,0xc2,0xa5,0x69,0x2c,0x13 ))// 4fc57282-0edf-5d85-9d89-ddc2a5692c13
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Core.TimedTextSource>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge>
internal class IIterableTimedTextSource: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.TimedTextSource?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource
    internal typealias SwiftABI = IIterableTimedTextSource
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.TimedTextSource?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.TimedTextSource?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TimedTextSource?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack: WindowsFoundation.IID {
    .init(Data1: 0x84413442, Data2: 0xa2e3, Data3: 0x5e0f, Data4: ( 0x93,0x6d,0xbc,0x40,0xb0,0xfb,0x2d,0xcd ))// 84413442-a2e3-5e0f-936d-bc40b0fb2dcd
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Core.VideoTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge>
internal class IIterableVideoTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.VideoTrack?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack
    internal typealias SwiftABI = IIterableVideoTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.VideoTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.VideoTrack?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.VideoTrack?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode: WindowsFoundation.IID {
    .init(Data1: 0x7d090784, Data2: 0x70a9, Data3: 0x570c, Data4: ( 0xbe,0x82,0x0d,0x08,0x90,0x31,0x89,0x75 ))// 7d090784-70a9-570c-be82-0d0890318975
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.AdvancedPhotoMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge>
internal class IIterableAdvancedPhotoMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AdvancedPhotoMode>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode
    internal typealias SwiftABI = IIterableAdvancedPhotoMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AdvancedPhotoMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AdvancedPhotoMode
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AdvancedPhotoMode>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange: WindowsFoundation.IID {
    .init(Data1: 0x751664c6, Data2: 0xf8d6, Data3: 0x50a3, Data4: ( 0xab,0x80,0x13,0x7c,0x6d,0x90,0x8c,0x55 ))// 751664c6-f8d6-50a3-ab80-137c6d908c55
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.AutoFocusRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge>
internal class IIterableAutoFocusRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AutoFocusRange>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange
    internal typealias SwiftABI = IIterableAutoFocusRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AutoFocusRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AutoFocusRange
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AutoFocusRange>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode: WindowsFoundation.IID {
    .init(Data1: 0x16d26b98, Data2: 0x2cbc, Data3: 0x52f0, Data4: ( 0xab,0x64,0x17,0x23,0x71,0x44,0x18,0xe9 ))// 16d26b98-2cbc-52f0-ab64-1723714418e9
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.CaptureSceneMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge>
internal class IIterableCaptureSceneMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.CaptureSceneMode>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode
    internal typealias SwiftABI = IIterableCaptureSceneMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.CaptureSceneMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.CaptureSceneMode
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CaptureSceneMode>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController: WindowsFoundation.IID {
    .init(Data1: 0xbd8eeadc, Data2: 0x2dd9, Data3: 0x5ad8, Data4: ( 0xac,0x5d,0xf3,0xb1,0x3b,0x94,0xb9,0xc2 ))// bd8eeadc-2dd9-5ad8-ac5d-f3b13b94b9c2
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.Core.FrameController>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge>
internal class IIterableFrameController: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.FrameController?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController
    internal typealias SwiftABI = IIterableFrameController
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.FrameController?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.FrameController?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.FrameController?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode: WindowsFoundation.IID {
    .init(Data1: 0x561bc21f, Data2: 0x4ae2, Data3: 0x580a, Data4: ( 0xa2,0x16,0x0a,0xd4,0x8f,0x37,0x3a,0x4c ))// 561bc21f-4ae2-580a-a216-0ad48f373a4c
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.FocusMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge>
internal class IIterableFocusMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.FocusMode>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode
    internal typealias SwiftABI = IIterableFocusMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.FocusMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.FocusMode
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.FocusMode>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset: WindowsFoundation.IID {
    .init(Data1: 0x26ba711b, Data2: 0x3a32, Data3: 0x5216, Data4: ( 0xbc,0x34,0x61,0xec,0xaf,0xbe,0xbd,0xc1 ))// 26ba711b-3a32-5216-bc34-61ecafbebdc1
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.FocusPreset>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge>
internal class IIterableFocusPreset: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.FocusPreset>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset
    internal typealias SwiftABI = IIterableFocusPreset
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.FocusPreset>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.FocusPreset
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.FocusPreset>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode: WindowsFoundation.IID {
    .init(Data1: 0x1d9679a7, Data2: 0x2d06, Data3: 0x5294, Data4: ( 0xac,0x67,0xf9,0xcd,0x35,0x61,0xdc,0xb8 ))// 1d9679a7-2d06-5294-ac67-f9cd3561dcb8
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.HdrVideoMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge>
internal class IIterableHdrVideoMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HdrVideoMode>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode
    internal typealias SwiftABI = IIterableHdrVideoMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HdrVideoMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HdrVideoMode
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HdrVideoMode>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode: WindowsFoundation.IID {
    .init(Data1: 0x58a4b7b6, Data2: 0x36c3, Data3: 0x5541, Data4: ( 0xb3,0x83,0x36,0x90,0xd7,0x29,0x3c,0x10 ))// 58a4b7b6-36c3-5541-b383-3690d7293c10
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.InfraredTorchMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge>
internal class IIterableInfraredTorchMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.InfraredTorchMode>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode
    internal typealias SwiftABI = IIterableInfraredTorchMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.InfraredTorchMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.InfraredTorchMode
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.InfraredTorchMode>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset: WindowsFoundation.IID {
    .init(Data1: 0x94839abe, Data2: 0x9712, Data3: 0x545a, Data4: ( 0xa9,0x4d,0xa5,0x67,0xa3,0xe8,0xdf,0xb7 ))// 94839abe-9712-545a-a94d-a567a3e8dfb7
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.IsoSpeedPreset>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge>
internal class IIterableIsoSpeedPreset: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.IsoSpeedPreset>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset
    internal typealias SwiftABI = IIterableIsoSpeedPreset
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.IsoSpeedPreset>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.IsoSpeedPreset
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.IsoSpeedPreset>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance: WindowsFoundation.IID {
    .init(Data1: 0xcf8cbeb1, Data2: 0x2a4c, Data3: 0x522d, Data4: ( 0x96,0x2f,0x84,0xc3,0x1a,0x59,0x8d,0x68 ))// cf8cbeb1-2a4c-522d-962f-84c31a598d68
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.ManualFocusDistance>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge>
internal class IIterableManualFocusDistance: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.ManualFocusDistance>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance
    internal typealias SwiftABI = IIterableManualFocusDistance
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.ManualFocusDistance>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.ManualFocusDistance
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ManualFocusDistance>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode: WindowsFoundation.IID {
    .init(Data1: 0x323d7734, Data2: 0x94c2, Data3: 0x544d, Data4: ( 0xa5,0x60,0x56,0x56,0x0f,0xe6,0x88,0x19 ))// 323d7734-94c2-544d-a560-56560fe68819
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.OpticalImageStabilizationMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge>
internal class IIterableOpticalImageStabilizationMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.OpticalImageStabilizationMode>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode
    internal typealias SwiftABI = IIterableOpticalImageStabilizationMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.OpticalImageStabilizationMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.OpticalImageStabilizationMode
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.OpticalImageStabilizationMode>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest: WindowsFoundation.IID {
    .init(Data1: 0xd73144c7, Data2: 0x9d75, Data3: 0x5dfb, Data4: ( 0x80,0x40,0x62,0x62,0x02,0xdc,0xf4,0x54 ))// d73144c7-9d75-5dfb-8040-626202dcf454
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.RegionOfInterest>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestBridge>
internal class IIterableRegionOfInterest: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.RegionOfInterest?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest
    internal typealias SwiftABI = IIterableRegionOfInterest
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.RegionOfInterest?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.RegionOfInterest?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.RegionOfInterest?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode: WindowsFoundation.IID {
    .init(Data1: 0xcaf26629, Data2: 0xee84, Data3: 0x5d4c, Data4: ( 0xae,0x37,0x9d,0xc4,0xb2,0x69,0x78,0xeb ))// caf26629-ee84-5d4c-ae37-9dc4b26978eb
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.VideoTemporalDenoisingMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge>
internal class IIterableVideoTemporalDenoisingMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.VideoTemporalDenoisingMode>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode
    internal typealias SwiftABI = IIterableVideoTemporalDenoisingMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.VideoTemporalDenoisingMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.VideoTemporalDenoisingMode
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.VideoTemporalDenoisingMode>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode: WindowsFoundation.IID {
    .init(Data1: 0xdb656915, Data2: 0x8fac, Data3: 0x5fb2, Data4: ( 0x98,0xe0,0x0e,0x97,0x42,0x16,0x56,0xc5 ))// db656915-8fac-5fb2-98e0-0e97421656c5
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Devices.ZoomTransitionMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge>
internal class IIterableZoomTransitionMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.ZoomTransitionMode>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode
    internal typealias SwiftABI = IIterableZoomTransitionMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.ZoomTransitionMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.ZoomTransitionMode
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ZoomTransitionMode>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties: WindowsFoundation.IID {
    .init(Data1: 0xd7fc75d5, Data2: 0x3492, Data3: 0x5bbb, Data4: ( 0x9b,0x34,0xda,0xc3,0xe2,0x4e,0x79,0xd0 ))// d7fc75d5-3492-5bbb-9b34-dac3e24e79d0
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.MediaProperties.IMediaEncodingProperties>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge>
internal class IIterableIMediaEncodingProperties: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AnyIMediaEncodingProperties?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties
    internal typealias SwiftABI = IIterableIMediaEncodingProperties
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AnyIMediaEncodingProperties?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AnyIMediaEncodingProperties?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AnyIMediaEncodingProperties?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRange: WindowsFoundation.IID {
    .init(Data1: 0x268204e2, Data2: 0x9d52, Data3: 0x5e7b, Data4: ( 0xa5,0x4b,0x86,0x9c,0x63,0xde,0xfc,0x8e ))// 268204e2-9d52-5e7b-a54b-869c63defc8e
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.MediaTimeRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge>
internal class IIterableMediaTimeRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRange }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MediaTimeRange>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRange
    internal typealias SwiftABI = IIterableMediaTimeRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MediaTimeRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MediaTimeRange
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaTimeRange>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak: WindowsFoundation.IID {
    .init(Data1: 0x04f000ec, Data2: 0xc727, Data3: 0x5dc0, Data4: ( 0x9f,0x7c,0x24,0x5c,0x75,0xc9,0x2f,0x2f ))// 04f000ec-c727-5dc0-9f7c-245c75c92f2f
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Playback.MediaBreak>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge>
internal class IIterableMediaBreak: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MediaBreak?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak
    internal typealias SwiftABI = IIterableMediaBreak
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MediaBreak?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MediaBreak?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaBreak?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem: WindowsFoundation.IID {
    .init(Data1: 0x8b8ab4a4, Data2: 0x0253, Data3: 0x56e9, Data4: ( 0xa2,0x32,0x94,0xe3,0x35,0xae,0xfa,0x8f ))// 8b8ab4a4-0253-56e9-a232-94e335aefa8f
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Playback.MediaPlaybackItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge>
internal class IIterableMediaPlaybackItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.MediaPlaybackItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem
    internal typealias SwiftABI = IIterableMediaPlaybackItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.MediaPlaybackItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.MediaPlaybackItem?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaPlaybackItem?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker: WindowsFoundation.IID {
    .init(Data1: 0xdeeccfe9, Data2: 0x6c01, Data3: 0x576f, Data4: ( 0x95,0xf2,0x93,0x51,0x5a,0xe4,0x0e,0xbf ))// deeccfe9-6c01-576f-95f2-93515ae40ebf
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Playback.PlaybackMediaMarker>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerBridge>
internal class IIterablePlaybackMediaMarker: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.PlaybackMediaMarker?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker
    internal typealias SwiftABI = IIterablePlaybackMediaMarker
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.PlaybackMediaMarker?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.PlaybackMediaMarker?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PlaybackMediaMarker?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem: WindowsFoundation.IID {
    .init(Data1: 0x07015868, Data2: 0x578c, Data3: 0x556b, Data4: ( 0x8a,0x35,0x40,0x39,0xa3,0x5d,0x1d,0x92 ))// 07015868-578c-556b-8a35-4039a35d1d92
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Media.Protection.RevocationAndRenewalItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge>
internal class IIterableRevocationAndRenewalItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.RevocationAndRenewalItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem
    internal typealias SwiftABI = IIterableRevocationAndRenewalItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.RevocationAndRenewalItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.RevocationAndRenewalItem?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.RevocationAndRenewalItem?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange: WindowsFoundation.IID {
    .init(Data1: 0x2cc2d499, Data2: 0x974c, Data3: 0x5078, Data4: ( 0x89,0xae,0x2d,0x4e,0xe1,0x13,0x97,0x21 ))// 2cc2d499-974c-5078-89ae-2d4ee1139721
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Networking.BackgroundTransfer.BackgroundTransferFileRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge>
internal class IIterableBackgroundTransferFileRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.BackgroundTransferFileRange>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange
    internal typealias SwiftABI = IIterableBackgroundTransferFileRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.BackgroundTransferFileRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.BackgroundTransferFileRange
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.BackgroundTransferFileRange>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0xd061dcb9, Data2: 0x6854, Data3: 0x5ef9, Data4: ( 0x8e,0x03,0x00,0x8a,0x7a,0x70,0x4c,0x48 ))// d061dcb9-6854-5ef9-8e03-008a7a704c48
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Networking.Connectivity.AttributedNetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge>
internal class IIterableAttributedNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AttributedNetworkUsage?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage
    internal typealias SwiftABI = IIterableAttributedNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AttributedNetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AttributedNetworkUsage?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AttributedNetworkUsage?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval: WindowsFoundation.IID {
    .init(Data1: 0x58051a8b, Data2: 0xb259, Data3: 0x5414, Data4: ( 0x9b,0x9a,0xca,0xa0,0x78,0x9e,0x83,0x3e ))// 58051a8b-b259-5414-9b9a-caa0789e833e
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Networking.Connectivity.ConnectivityInterval>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge>
internal class IIterableConnectivityInterval: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.ConnectivityInterval?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval
    internal typealias SwiftABI = IIterableConnectivityInterval
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.ConnectivityInterval?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.ConnectivityInterval?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ConnectivityInterval?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0xdd2656b1, Data2: 0x8360, Data3: 0x5772, Data4: ( 0xb2,0x72,0xc4,0x7f,0x7f,0x0f,0xc7,0xa6 ))// dd2656b1-8360-5772-b272-c47f7f0fc7a6
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Networking.Connectivity.NetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge>
internal class IIterableNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.NetworkUsage?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage
    internal typealias SwiftABI = IIterableNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.NetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.NetworkUsage?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.NetworkUsage?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0xf79bc7ba, Data2: 0x01df, Data3: 0x51ec, Data4: ( 0xbf,0xaf,0xfd,0x88,0x3f,0x69,0x8e,0x07 ))// f79bc7ba-01df-51ec-bfaf-fd883f698e07
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Networking.Connectivity.ProviderNetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge>
internal class IIterableProviderNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.ProviderNetworkUsage?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage
    internal typealias SwiftABI = IIterableProviderNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.ProviderNetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.ProviderNetworkUsage?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ProviderNetworkUsage?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate: WindowsFoundation.IID {
    .init(Data1: 0x0c7d1423, Data2: 0xe8fd, Data3: 0x5a91, Data4: ( 0xb5,0x5c,0x8b,0xfb,0xe7,0xac,0x2d,0x40 ))// 0c7d1423-e8fd-5a91-b55c-8bfbe7ac2d40
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Security.Cryptography.Certificates.Certificate>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge>
internal class IIterableCertificate: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.Certificate?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate
    internal typealias SwiftABI = IIterableCertificate
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.Certificate?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.Certificate?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Certificate?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult: WindowsFoundation.IID {
    .init(Data1: 0x2628f58f, Data2: 0x3f02, Data3: 0x54f2, Data4: ( 0x80,0x8f,0xe1,0x11,0x77,0x09,0xd6,0xd0 ))// 2628f58f-3f02-54f2-808f-e1117709d6d0
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Security.Cryptography.Certificates.ChainValidationResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge>
internal class IIterableChainValidationResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.ChainValidationResult>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult
    internal typealias SwiftABI = IIterableChainValidationResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.ChainValidationResult>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.ChainValidationResult
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ChainValidationResult>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0xbb8b8418, Data2: 0x65d1, Data3: 0x544b, Data4: ( 0xb0,0x83,0x6d,0x17,0x2f,0x56,0x8c,0x73 ))// bb8b8418-65d1-544b-b083-6d172f568c73
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Storage.IStorageItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemBridge>
internal class IIterableIStorageItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItem }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.AnyIStorageItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItem
    internal typealias SwiftABI = IIterableIStorageItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.AnyIStorageItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.AnyIStorageItem?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AnyIStorageItem?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry: WindowsFoundation.IID {
    .init(Data1: 0x35aff6f9, Data2: 0xef75, Data3: 0x5280, Data4: ( 0xbb,0x84,0xa2,0xbf,0x83,0x17,0xcf,0x35 ))// 35aff6f9-ef75-5280-bb84-a2bf8317cf35
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Storage.Search.SortEntry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge>
internal class IIterableSortEntry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.SortEntry>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry
    internal typealias SwiftABI = IIterableSortEntry
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.SortEntry>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.SortEntry
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.SortEntry>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFile: WindowsFoundation.IID {
    .init(Data1: 0x9ac00304, Data2: 0x83ea, Data3: 0x5688, Data4: ( 0x87,0xb6,0xae,0x38,0xaa,0xb6,0x5d,0x0b ))// 9ac00304-83ea-5688-87b6-ae38aab65d0b
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Storage.StorageFile>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileBridge>
internal class IIterableStorageFile: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFile }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.StorageFile?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFile
    internal typealias SwiftABI = IIterableStorageFile
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.StorageFile?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.StorageFile?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.StorageFile?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolder: WindowsFoundation.IID {
    .init(Data1: 0x4669befc, Data2: 0xae5c, Data3: 0x52b1, Data4: ( 0x8a,0x97,0x54,0x66,0xce,0x61,0xe9,0x4e ))// 4669befc-ae5c-52b1-8a97-5466ce61e94e
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Storage.StorageFolder>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderBridge>
internal class IIterableStorageFolder: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolder }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.StorageFolder?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolder
    internal typealias SwiftABI = IIterableStorageFolder
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.StorageFolder?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.StorageFolder?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.StorageFolder?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChange: WindowsFoundation.IID {
    .init(Data1: 0x87c15dfc, Data2: 0x0c5e, Data3: 0x518b, Data4: ( 0x92,0x06,0x97,0xd3,0xd9,0x82,0x3c,0x61 ))// 87c15dfc-0c5e-518b-9206-97d3d9823c61
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Storage.StorageLibraryChange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge>
internal class IIterableStorageLibraryChange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChange }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.StorageLibraryChange?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChange
    internal typealias SwiftABI = IIterableStorageLibraryChange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.StorageLibraryChange?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.StorageLibraryChange?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.StorageLibraryChange?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUser: WindowsFoundation.IID {
    .init(Data1: 0xd1bacd1f, Data2: 0x0376, Data3: 0x5823, Data4: ( 0x8c,0x29,0x1d,0x45,0xb9,0xf4,0xc1,0x91 ))// d1bacd1f-0376-5823-8c29-1d45b9f4c191
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.System.User>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserBridge>
internal class IIterableUser: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUser }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.User?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUser
    internal typealias SwiftABI = IIterableUser
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.User?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.User?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.User?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation: WindowsFoundation.IID {
    .init(Data1: 0x0cb59942, Data2: 0xc6f3, Data3: 0x585f, Data4: ( 0x9a,0x92,0xb4,0x7e,0x8d,0xd3,0x8e,0xbf ))// 0cb59942-c6f3-585f-9a92-b47e8dd38ebf
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionAnimation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationBridge>
internal class IIterableCompositionAnimation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.CompositionAnimation?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation
    internal typealias SwiftABI = IIterableCompositionAnimation
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.CompositionAnimation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.CompositionAnimation?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionAnimation?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop: WindowsFoundation.IID {
    .init(Data1: 0x0f2cfac1, Data2: 0xcdbc, Data3: 0x5c4e, Data4: ( 0xa7,0xd2,0xa3,0x91,0x4f,0xb6,0x34,0x26 ))// 0f2cfac1-cdbc-5c4e-a7d2-a3914fb63426
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionColorGradientStop>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge>
internal class IIterableCompositionColorGradientStop: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.CompositionColorGradientStop?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop
    internal typealias SwiftABI = IIterableCompositionColorGradientStop
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.CompositionColorGradientStop?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.CompositionColorGradientStop?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionColorGradientStop?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster: WindowsFoundation.IID {
    .init(Data1: 0xb8301b02, Data2: 0x429b, Data3: 0x5d71, Data4: ( 0xab,0x0c,0x8d,0x11,0x41,0xb1,0x2a,0xc3 ))// b8301b02-429b-5d71-ab0c-8d1141b12ac3
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionProjectedShadowCaster>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterBridge>
internal class IIterableCompositionProjectedShadowCaster: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.CompositionProjectedShadowCaster?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster
    internal typealias SwiftABI = IIterableCompositionProjectedShadowCaster
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.CompositionProjectedShadowCaster?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.CompositionProjectedShadowCaster?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionProjectedShadowCaster?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver: WindowsFoundation.IID {
    .init(Data1: 0xe2775a28, Data2: 0xec48, Data3: 0x5cb8, Data4: ( 0xb3,0x52,0x76,0xf7,0xf9,0x81,0xd7,0xa4 ))// e2775a28-ec48-5cb8-b352-76f7f981d7a4
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionProjectedShadowReceiver>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverBridge>
internal class IIterableCompositionProjectedShadowReceiver: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.CompositionProjectedShadowReceiver?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver
    internal typealias SwiftABI = IIterableCompositionProjectedShadowReceiver
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.CompositionProjectedShadowReceiver?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.CompositionProjectedShadowReceiver?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionProjectedShadowReceiver?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape: WindowsFoundation.IID {
    .init(Data1: 0x1135adf5, Data2: 0xdb12, Data3: 0x55e8, Data4: ( 0xae,0x0f,0xbd,0x8d,0x91,0x4b,0xd3,0x99 ))// 1135adf5-db12-55e8-ae0f-bd8d914bd399
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionShape>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge>
internal class IIterableCompositionShape: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.CompositionShape?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape
    internal typealias SwiftABI = IIterableCompositionShape
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.CompositionShape?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.CompositionShape?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionShape?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisual: WindowsFoundation.IID {
    .init(Data1: 0x4eed7dce, Data2: 0xe4ac, Data3: 0x5891, Data4: ( 0x9b,0x52,0x79,0x9d,0x70,0xdf,0x47,0xfe ))// 4eed7dce-e4ac-5891-9b52-799d70df47fe
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.Visual>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualBridge>
internal class IIterableVisual: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisual }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.Visual?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisual.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisual
    internal typealias SwiftABI = IIterableVisual
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.Visual?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.Visual?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CVisualBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Visual?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPoint: WindowsFoundation.IID {
    .init(Data1: 0xf6f2cba6, Data2: 0x7076, Data3: 0x5b59, Data4: ( 0x96,0x31,0xf6,0xac,0x32,0xb5,0x76,0x95 ))// f6f2cba6-7076-5b59-9631-f6ac32b57695
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.UI.Input.PointerPoint>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge>
internal class IIterablePointerPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPoint }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.PointerPoint?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPoint
    internal typealias SwiftABI = IIterablePointerPoint
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.PointerPoint?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.PointerPoint?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PointerPoint?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification: WindowsFoundation.IID {
    .init(Data1: 0x1863baee, Data2: 0x44f1, Data3: 0x5e51, Data4: ( 0xbc,0xdf,0xa3,0xcd,0xab,0x82,0x6a,0x15 ))// 1863baee-44f1-5e51-bcdf-a3cdab826a15
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.UI.Notifications.ShownTileNotification>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge>
internal class IIterableShownTileNotification: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.ShownTileNotification?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification
    internal typealias SwiftABI = IIterableShownTileNotification
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.ShownTileNotification?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.ShownTileNotification?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ShownTileNotification?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x17847e58, Data2: 0xf0cf, Data3: 0x52e7, Data4: ( 0x81,0xc0,0x9d,0x06,0xa0,0x81,0x56,0x9f ))// 17847e58-f0cf-52e7-81c0-9d06a081569f
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpChallengeHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge>
internal class IIterableHttpChallengeHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpChallengeHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue
    internal typealias SwiftABI = IIterableHttpChallengeHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpChallengeHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpChallengeHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpChallengeHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x1afc512f, Data2: 0xdfa2, Data3: 0x5528, Data4: ( 0x8a,0xef,0x6e,0x6a,0x37,0x78,0x9b,0x3c ))// 1afc512f-dfa2-5528-8aef-6e6a37789b3c
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge>
internal class IIterableHttpConnectionOptionHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpConnectionOptionHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue
    internal typealias SwiftABI = IIterableHttpConnectionOptionHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpConnectionOptionHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpConnectionOptionHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpConnectionOptionHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x0e8960c2, Data2: 0x76e5, Data3: 0x56c1, Data4: ( 0x9f,0xe6,0x8c,0xd9,0x01,0x8a,0x67,0x86 ))// 0e8960c2-76e5-56c1-9fe6-8cd9018a6786
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpContentCodingHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge>
internal class IIterableHttpContentCodingHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpContentCodingHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue
    internal typealias SwiftABI = IIterableHttpContentCodingHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpContentCodingHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpContentCodingHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpContentCodingHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x916e6271, Data2: 0xcef6, Data3: 0x53b8, Data4: ( 0xb9,0x3f,0xdc,0x8d,0xca,0x55,0x9e,0x50 ))// 916e6271-cef6-53b8-b93f-dc8dca559e50
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge>
internal class IIterableHttpContentCodingWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpContentCodingWithQualityHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue
    internal typealias SwiftABI = IIterableHttpContentCodingWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpContentCodingWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpContentCodingWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpContentCodingWithQualityHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x16773244, Data2: 0x5011, Data3: 0x5244, Data4: ( 0xbb,0x00,0x14,0xdb,0x4c,0xf7,0x10,0x05 ))// 16773244-5011-5244-bb00-14db4cf71005
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpCookiePairHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge>
internal class IIterableHttpCookiePairHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpCookiePairHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue
    internal typealias SwiftABI = IIterableHttpCookiePairHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpCookiePairHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpCookiePairHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpCookiePairHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x0a391c2b, Data2: 0x13c3, Data3: 0x59b8, Data4: ( 0x86,0x62,0x13,0xaf,0xfb,0x9d,0x17,0x54 ))// 0a391c2b-13c3-59b8-8662-13affb9d1754
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpExpectationHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge>
internal class IIterableHttpExpectationHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpExpectationHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue
    internal typealias SwiftABI = IIterableHttpExpectationHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpExpectationHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpExpectationHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpExpectationHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x0c5a4a0d, Data2: 0xdbb7, Data3: 0x5abf, Data4: ( 0xa5,0xfd,0xc3,0xb9,0x8d,0x9c,0x14,0x87 ))// 0c5a4a0d-dbb7-5abf-a5fd-c3b98d9c1487
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge>
internal class IIterableHttpLanguageRangeWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpLanguageRangeWithQualityHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue
    internal typealias SwiftABI = IIterableHttpLanguageRangeWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpLanguageRangeWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpLanguageRangeWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpLanguageRangeWithQualityHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xffc7dfde, Data2: 0x58b8, Data3: 0x51e9, Data4: ( 0xb3,0x3b,0x65,0xa5,0xd6,0xa4,0xe2,0x4c ))// ffc7dfde-58b8-51e9-b33b-65a5d6a4e24c
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge>
internal class IIterableHttpMediaTypeWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpMediaTypeWithQualityHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue
    internal typealias SwiftABI = IIterableHttpMediaTypeWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpMediaTypeWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpMediaTypeWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpMediaTypeWithQualityHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x5838a126, Data2: 0xb617, Data3: 0x5417, Data4: ( 0xb3,0x2e,0xde,0xd2,0xd2,0x7d,0x40,0xa3 ))// 5838a126-b617-5417-b32e-ded2d27d40a3
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpNameValueHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge>
internal class IIterableHttpNameValueHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpNameValueHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue
    internal typealias SwiftABI = IIterableHttpNameValueHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpNameValueHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpNameValueHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpNameValueHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xbf97cf99, Data2: 0xe614, Data3: 0x5765, Data4: ( 0xba,0xd7,0x16,0x1a,0xe3,0xa9,0x3a,0xe9 ))// bf97cf99-e614-5765-bad7-161ae3a93ae9
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpProductInfoHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge>
internal class IIterableHttpProductInfoHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpProductInfoHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue
    internal typealias SwiftABI = IIterableHttpProductInfoHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpProductInfoHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpProductInfoHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpProductInfoHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x57402048, Data2: 0x38bf, Data3: 0x5055, Data4: ( 0xac,0xb6,0x5c,0x4d,0xa7,0x65,0xe3,0x88 ))// 57402048-38bf-5055-acb6-5c4da765e388
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.Headers.HttpTransferCodingHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge>
internal class IIterableHttpTransferCodingHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpTransferCodingHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue
    internal typealias SwiftABI = IIterableHttpTransferCodingHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpTransferCodingHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpTransferCodingHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpTransferCodingHeaderValue?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod: WindowsFoundation.IID {
    .init(Data1: 0xc088bb1a, Data2: 0xdc61, Data3: 0x57e1, Data4: ( 0xb9,0x67,0x78,0xda,0xb3,0x54,0x1d,0xa5 ))// c088bb1a-dc61-57e1-b967-78dab3541da5
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.Http.HttpMethod>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge>
internal class IIterableHttpMethod: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.HttpMethod?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod
    internal typealias SwiftABI = IIterableHttpMethod
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.HttpMethod?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.HttpMethod?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpMethod?>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatus: WindowsFoundation.IID {
    .init(Data1: 0x7b7f182e, Data2: 0xa6ce, Data3: 0x556b, Data4: ( 0x9a,0x2e,0xef,0x97,0x66,0x2f,0x2a,0xee ))// 7b7f182e-a6ce-556b-9a2e-ef97662f2aee
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Web.WebErrorStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.first()
        let resultWrapper = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge>
internal class IIterableWebErrorStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatus }

    internal func FirstImpl() throws -> WindowsFoundation.AnyIIterator<UWP.WebErrorStatus>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatus
    internal typealias SwiftABI = IIterableWebErrorStatus
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterable<UWP.WebErrorStatus>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusImpl : IIterable, AbiInterfaceImpl {
    typealias T = UWP.WebErrorStatus
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.WebErrorStatus>? {
        try! _default.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1_float: WindowsFoundation.IID {
    .init(Data1: 0x42614e61, Data2: 0xb0aa, Data3: 0x5e72, Data4: ( 0x93,0x54,0x27,0x71,0xdb,0x20,0xb7,0xa8 ))// 42614e61-b0aa-5e72-9354-2771db20b7a8
}

internal var __x_ABI_C__FIIterator_1_floatVTable: __x_ABI_C__FIIterator_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1_floatWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1_floatWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1_floatWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1_floatBridge>
internal class IIteratorFloat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1_float }

    internal func get_CurrentImpl() throws -> Float {
        var result: FLOAT = 0.0
        _ = try perform(as: __x_ABI_C__FIIterator_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1_floatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1_float
    internal typealias SwiftABI = IIteratorFloat
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<Float>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1_floatImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1_floatImpl : IIterator, AbiInterfaceImpl {
    typealias T = Float
    typealias Bridge = __x_ABI_C__FIIterator_1_floatBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : Float {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1_GUID: WindowsFoundation.IID {
    .init(Data1: 0xd3d64048, Data2: 0x82b3, Data3: 0x53c7, Data4: ( 0x92,0x85,0xb0,0xbe,0x18,0x36,0x84,0x82 ))// d3d64048-82b3-53c7-9285-b0be18368482
}

internal var __x_ABI_C__FIIterator_1_GUIDVTable: __x_ABI_C__FIIterator_1_GUIDVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1_GUIDWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1_GUIDWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1_GUIDWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1_GUIDWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Foundation.UUID>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_GUIDWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_GUIDWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_GUIDWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1_GUIDWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1_GUIDBridge>
internal class IIteratorUUID: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1_GUID }

    internal func get_CurrentImpl() throws -> Foundation.UUID {
        var result: WindowsFoundation.GUID = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1_GUID.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_GUID.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_GUID.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1_GUIDBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1_GUID
    internal typealias SwiftABI = IIteratorUUID
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<Foundation.UUID>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1_GUIDImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1_GUIDVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1_GUIDImpl : IIterator, AbiInterfaceImpl {
    typealias T = Foundation.UUID
    typealias Bridge = __x_ABI_C__FIIterator_1_GUIDBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : Foundation.UUID {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x8c304ebb, Data2: 0x6615, Data3: 0x50a4, Data4: ( 0x88,0x29,0x87,0x9e,0xcd,0x44,0x32,0x36 ))// 8c304ebb-6615-50a4-8829-879ecd443236
}

internal var __x_ABI_C__FIIterator_1_HSTRINGVTable: __x_ABI_C__FIIterator_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1_HSTRINGBridge>
internal class IIteratorString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1_HSTRING }

    internal func get_CurrentImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIIterator_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1_HSTRING
    internal typealias SwiftABI = IIteratorString
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1_HSTRINGImpl : IIterator, AbiInterfaceImpl {
    typealias T = String
    typealias Bridge = __x_ABI_C__FIIterator_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : String {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1_UINT32: WindowsFoundation.IID {
    .init(Data1: 0xf06a2739, Data2: 0x9443, Data3: 0x5ef0, Data4: ( 0xb2,0x84,0xdc,0x5a,0xff,0x3e,0x7d,0x10 ))// f06a2739-9443-5ef0-b284-dc5aff3e7d10
}

internal var __x_ABI_C__FIIterator_1_UINT32VTable: __x_ABI_C__FIIterator_1_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1_UINT32Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1_UINT32Wrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<UInt32>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1_UINT32Bridge>
internal class IIteratorUInt32: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1_UINT32 }

    internal func get_CurrentImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1_UINT32Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1_UINT32
    internal typealias SwiftABI = IIteratorUInt32
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UInt32>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1_UINT32Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1_UINT32VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1_UINT32Impl : IIterator, AbiInterfaceImpl {
    typealias T = UInt32
    typealias Bridge = __x_ABI_C__FIIterator_1_UINT32Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UInt32 {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfo: WindowsFoundation.IID {
    .init(Data1: 0x69cec62c, Data2: 0x41eb, Data3: 0x5d69, Data4: ( 0xa4,0x75,0x29,0xee,0x22,0x32,0x3d,0xd8 ))// 69cec62c-41eb-5d69-a475-29ee22323dd8
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.ApplicationModel.AppInfo>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge>
internal class IIteratorAppInfo: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfo }

    internal func get_CurrentImpl() throws -> UWP.AppInfo? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfo
    internal typealias SwiftABI = IIteratorAppInfo
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AppInfo?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AppInfo?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AppInfo? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry: WindowsFoundation.IID {
    .init(Data1: 0xb93e2028, Data2: 0x50bc, Data3: 0x599e, Data4: ( 0xb3,0xd9,0x42,0x7b,0x61,0xd2,0x6c,0x01 ))// b93e2028-50bc-599e-b3d9-427b61d26c01
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.ApplicationModel.Core.AppListEntry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge>
internal class IIteratorAppListEntry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry }

    internal func get_CurrentImpl() throws -> UWP.AppListEntry? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry
    internal typealias SwiftABI = IIteratorAppListEntry
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AppListEntry?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AppListEntry?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AppListEntry? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem: WindowsFoundation.IID {
    .init(Data1: 0x63fac521, Data2: 0x1395, Data3: 0x5c95, Data4: ( 0xaa,0xff,0x97,0x36,0x37,0x8a,0x4f,0x2f ))// 63fac521-1395-5c95-aaff-9736378a4f2f
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.ApplicationModel.DataTransfer.ClipboardHistoryItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge>
internal class IIteratorClipboardHistoryItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem }

    internal func get_CurrentImpl() throws -> UWP.ClipboardHistoryItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem
    internal typealias SwiftABI = IIteratorClipboardHistoryItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.ClipboardHistoryItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.ClipboardHistoryItem?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.ClipboardHistoryItem? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider: WindowsFoundation.IID {
    .init(Data1: 0x886f5642, Data2: 0xe9f9, Data3: 0x573b, Data4: ( 0x92,0x13,0x58,0x40,0xb5,0x06,0x2b,0x40 ))// 886f5642-e9f9-573b-9213-5840b5062b40
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.ApplicationModel.DataTransfer.ShareProvider>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge>
internal class IIteratorShareProvider: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider }

    internal func get_CurrentImpl() throws -> UWP.ShareProvider? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider
    internal typealias SwiftABI = IIteratorShareProvider
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.ShareProvider?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.ShareProvider?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.ShareProvider? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackage: WindowsFoundation.IID {
    .init(Data1: 0x0217f069, Data2: 0x025c, Data3: 0x5ee6, Data4: ( 0xa8,0x7f,0xe7,0x82,0xe3,0xb6,0x23,0xae ))// 0217f069-025c-5ee6-a87f-e782e3b623ae
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.ApplicationModel.Package>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageBridge>
internal class IIteratorPackage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackage }

    internal func get_CurrentImpl() throws -> UWP.Package? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackage
    internal typealias SwiftABI = IIteratorPackage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.Package?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.Package?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.Package? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup: WindowsFoundation.IID {
    .init(Data1: 0x5f23d323, Data2: 0x28f5, Data3: 0x560f, Data4: ( 0xa4,0x0e,0x6f,0x38,0x27,0xf8,0x2e,0x9f ))// 5f23d323-28f5-560f-a40e-6f3827f82e9f
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.ApplicationModel.PackageContentGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge>
internal class IIteratorPackageContentGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup }

    internal func get_CurrentImpl() throws -> UWP.PackageContentGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup
    internal typealias SwiftABI = IIteratorPackageContentGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.PackageContentGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.PackageContentGroup?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.PackageContentGroup? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegment: WindowsFoundation.IID {
    .init(Data1: 0x645a39b4, Data2: 0xf001, Data3: 0x5272, Data4: ( 0x90,0x15,0xfb,0x4a,0x32,0x71,0x79,0xae ))// 645a39b4-f001-5272-9015-fb4a327179ae
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Data.Text.TextSegment>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge>
internal class IIteratorTextSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegment }

    internal func get_CurrentImpl() throws -> UWP.TextSegment {
        var result: __x_ABI_CWindows_CData_CText_CTextSegment = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegment
    internal typealias SwiftABI = IIteratorTextSegment
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.TextSegment>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.TextSegment
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.TextSegment {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation: WindowsFoundation.IID {
    .init(Data1: 0x6f85d843, Data2: 0xe8ab, Data3: 0x5b46, Data4: ( 0x85,0xd7,0x32,0x7c,0x58,0xd1,0x87,0x12 ))// 6f85d843-e8ab-5b46-85d7-327c58d18712
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Devices.Enumeration.DeviceInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge>
internal class IIteratorDeviceInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation }

    internal func get_CurrentImpl() throws -> UWP.DeviceInformation? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation
    internal typealias SwiftABI = IIteratorDeviceInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.DeviceInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.DeviceInformation?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.DeviceInformation? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind: WindowsFoundation.IID {
    .init(Data1: 0xcb5ca9db, Data2: 0xccd6, Data3: 0x5103, Data4: ( 0xa9,0x3d,0xc9,0x25,0xc9,0x08,0x83,0x8d ))// cb5ca9db-ccd6-5103-a93d-c925c908838d
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Devices.Enumeration.DeviceWatcherEventKind>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindBridge>
internal class IIteratorDeviceWatcherEventKind: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind }

    internal func get_CurrentImpl() throws -> UWP.DeviceWatcherEventKind {
        var result: __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherEventKind = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKind
    internal typealias SwiftABI = IIteratorDeviceWatcherEventKind
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.DeviceWatcherEventKind>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.DeviceWatcherEventKind
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcherEventKindBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.DeviceWatcherEventKind {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice: WindowsFoundation.IID {
    .init(Data1: 0xde94641c, Data2: 0x7960, Data3: 0x5fcd, Data4: ( 0xab,0xe8,0xd6,0xba,0x60,0x9e,0xf7,0xd3 ))// de94641c-7960-5fcd-abe8-d6ba609ef7d3
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Devices.Input.PointerDevice>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge>
internal class IIteratorPointerDevice: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice }

    internal func get_CurrentImpl() throws -> UWP.PointerDevice? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice
    internal typealias SwiftABI = IIteratorPointerDevice
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.PointerDevice?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.PointerDevice?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.PointerDevice? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage: WindowsFoundation.IID {
    .init(Data1: 0x9ab2160d, Data2: 0x11ef, Data3: 0x5eca, Data4: ( 0x8d,0xd9,0x3e,0x13,0xaa,0x4e,0x5f,0x99 ))// 9ab2160d-11ef-5eca-8dd9-3e13aa4e5f99
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Devices.Input.PointerDeviceUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge>
internal class IIteratorPointerDeviceUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage }

    internal func get_CurrentImpl() throws -> UWP.PointerDeviceUsage {
        var result: __x_ABI_CWindows_CDevices_CInput_CPointerDeviceUsage = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage
    internal typealias SwiftABI = IIteratorPointerDeviceUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.PointerDeviceUsage>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.PointerDeviceUsage
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.PointerDeviceUsage {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x4f25059a, Data2: 0x0b9a, Data3: 0x5f25, Data4: ( 0x9b,0x9e,0x4b,0x9f,0x1d,0x22,0xff,0x65 ))// 4f25059a-0b9a-5f25-9b9e-4b9f1d22ff65
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Any>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge>
internal class IIteratorIKeyValuePairUUID_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable
    internal typealias SwiftABI = IIteratorIKeyValuePairUUID_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration: WindowsFoundation.IID {
    .init(Data1: 0x8445d2ae, Data2: 0xdd03, Data3: 0x5b98, Data4: ( 0x95,0xe4,0x82,0xb4,0x3a,0x3f,0x0d,0x64 ))// 8445d2ae-dd03-5b98-95e4-82b43a3f0d64
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Windows.ApplicationModel.Background.BackgroundTaskRegistration>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge>
internal class IIteratorIKeyValuePairUUID_BackgroundTaskRegistration: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration
    internal typealias SwiftABI = IIteratorIKeyValuePairUUID_BackgroundTaskRegistration
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration: WindowsFoundation.IID {
    .init(Data1: 0x2001aea5, Data2: 0x1a86, Data3: 0x517e, Data4: ( 0x8b,0xe5,0x11,0xd7,0xfb,0x59,0x35,0xb2 ))// 2001aea5-1a86-517e-8be5-11d7fb5935b2
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Windows.ApplicationModel.Background.IBackgroundTaskRegistration>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge>
internal class IIteratorIKeyValuePairUUID_IBackgroundTaskRegistration: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration
    internal typealias SwiftABI = IIteratorIKeyValuePairUUID_IBackgroundTaskRegistration
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x5db5fa32, Data2: 0x707c, Data3: 0x5849, Data4: ( 0xa0,0x6b,0x91,0xc8,0xeb,0x9d,0x10,0xe8 ))// 5db5fa32-707c-5849-a06b-91c8eb9d10e8
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Any>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge>
internal class IIteratorIKeyValuePairString_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<String, Any?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable
    internal typealias SwiftABI = IIteratorIKeyValuePairString_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, Any?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, Any?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<String, Any?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x05eb86f1, Data2: 0x7140, Data3: 0x5517, Data4: ( 0xb8,0x8d,0xcb,0xae,0xbe,0x57,0xe6,0xb1 ))// 05eb86f1-7140-5517-b88d-cbaebe57e6b1
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, String>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge>
internal class IIteratorIKeyValuePairString_String: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<String, String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING
    internal typealias SwiftABI = IIteratorIKeyValuePairString_String
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, String>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, String>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<String, String>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup: WindowsFoundation.IID {
    .init(Data1: 0x4c21744b, Data2: 0xb583, Data3: 0x559d, Data4: ( 0x89,0xf7,0xd4,0x13,0x8c,0xff,0xff,0xbc ))// 4c21744b-b583-559d-89f7-d4138cffffbc
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge>
internal class IIteratorIKeyValuePairString_BackgroundTaskRegistrationGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup
    internal typealias SwiftABI = IIteratorIKeyValuePairString_BackgroundTaskRegistrationGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment: WindowsFoundation.IID {
    .init(Data1: 0x00078aa3, Data2: 0x8676, Data3: 0x5f06, Data4: ( 0xad,0xf5,0xff,0xe5,0xd6,0x61,0xd6,0x70 ))// 00078aa3-8676-5f06-adf5-ffe5d661d670
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Foundation.Collections.IVectorView`1<Windows.Data.Text.TextSegment>>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge>
internal class IIteratorIKeyValuePairString_IVectorViewTextSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment
    internal typealias SwiftABI = IIteratorIKeyValuePairString_IVectorViewTextSegment
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xa11824c9, Data2: 0xe458, Data3: 0x502a, Data4: ( 0xaf,0xd8,0xce,0x3c,0xe0,0xab,0xd6,0xfe ))// a11824c9-e458-502a-afd8-ce3ce0abd6fe
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Foundation.Collections.IVector`1<String>>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge>
internal class IIteratorIKeyValuePairString_IVectorString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING
    internal typealias SwiftABI = IIteratorIKeyValuePairString_IVectorString
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue: WindowsFoundation.IID {
    .init(Data1: 0x2ad3fb0c, Data2: 0x0656, Data3: 0x5302, Data4: ( 0xb5,0x04,0x31,0x53,0xbe,0x84,0x51,0x61 ))// 2ad3fb0c-0656-5302-b504-3153be845161
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Graphics.Imaging.BitmapTypedValue>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge>
internal class IIteratorIKeyValuePairString_BitmapTypedValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue
    internal typealias SwiftABI = IIteratorIKeyValuePairString_BitmapTypedValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0x9419af53, Data2: 0xacb8, Data3: 0x5328, Data4: ( 0x88,0x53,0x70,0xba,0x87,0xeb,0x6a,0xd5 ))// 9419af53-acb8-5328-8853-70ba87eb6ad5
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Storage.Streams.RandomAccessStreamReference>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class IIteratorIKeyValuePairString_RandomAccessStreamReference: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = IIteratorIKeyValuePairString_RandomAccessStreamReference
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase: WindowsFoundation.IID {
    .init(Data1: 0x85924e77, Data2: 0xfc46, Data3: 0x5a0d, Data4: ( 0xbd,0xaf,0x46,0x3c,0x4f,0x86,0xc1,0x72 ))// 85924e77-fc46-5a0d-bdaf-463c4f86c172
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.UI.Composition.ICompositionAnimationBase>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge>
internal class IIteratorIKeyValuePairString_ICompositionAnimationBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase }

    internal func get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase
    internal typealias SwiftABI = IIteratorIKeyValuePairString_ICompositionAnimationBase
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUri: WindowsFoundation.IID {
    .init(Data1: 0x1c157d0f, Data2: 0x5efe, Data3: 0x5cec, Data4: ( 0xbb,0xd6,0x0c,0x6c,0xe9,0xaf,0x07,0xa5 ))// 1c157d0f-5efe-5cec-bbd6-0c6ce9af07a5
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Uri>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriBridge>
internal class IIteratorUri: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUri }

    internal func get_CurrentImpl() throws -> WindowsFoundation.Uri? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUri.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUri.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUri.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUri
    internal typealias SwiftABI = IIteratorUri
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.Uri?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.Uri?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CUriBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.Uri? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguage: WindowsFoundation.IID {
    .init(Data1: 0x30e99ae6, Data2: 0xf414, Data3: 0x5243, Data4: ( 0x8d,0xb2,0xaa,0xb3,0x8e,0xa3,0xf1,0xf1 ))// 30e99ae6-f414-5243-8db2-aab38ea3f1f1
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Globalization.Language>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageBridge>
internal class IIteratorLanguage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguage }

    internal func get_CurrentImpl() throws -> UWP.Language? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguage
    internal typealias SwiftABI = IIteratorLanguage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.Language?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.Language?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGlobalization__CLanguageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.Language? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation: WindowsFoundation.IID {
    .init(Data1: 0x4ff2b2db, Data2: 0x9326, Data3: 0x537f, Data4: ( 0xb8,0xdc,0x4c,0x93,0xd7,0x7f,0xbb,0x84 ))// 4ff2b2db-9326-537f-b8dc-4c93d77fbb84
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Graphics.Imaging.BitmapCodecInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge>
internal class IIteratorBitmapCodecInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation }

    internal func get_CurrentImpl() throws -> UWP.BitmapCodecInformation? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation
    internal typealias SwiftABI = IIteratorBitmapCodecInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.BitmapCodecInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.BitmapCodecInformation?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.BitmapCodecInformation? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation: WindowsFoundation.IID {
    .init(Data1: 0x75660566, Data2: 0xae43, Data3: 0x5858, Data4: ( 0xad,0xa6,0xd5,0x7d,0xda,0xe9,0x02,0x77 ))// 75660566-ae43-5858-ada6-d57ddae90277
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Management.Deployment.PackageUserInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationBridge>
internal class IIteratorPackageUserInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation }

    internal func get_CurrentImpl() throws -> UWP.PackageUserInformation? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformation
    internal typealias SwiftABI = IIteratorPackageUserInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.PackageUserInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.PackageUserInformation?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageUserInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.PackageUserInformation? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume: WindowsFoundation.IID {
    .init(Data1: 0xa8d5b736, Data2: 0x4e68, Data3: 0x5ef1, Data4: ( 0x9f,0x07,0xf0,0x68,0x37,0x98,0x8c,0x73 ))// a8d5b736-4e68-5ef1-9f07-f06837988c73
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Management.Deployment.PackageVolume>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge>
internal class IIteratorPackageVolume: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume }

    internal func get_CurrentImpl() throws -> UWP.PackageVolume? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume
    internal typealias SwiftABI = IIteratorPackageVolume
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.PackageVolume?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.PackageVolume?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.PackageVolume? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat: WindowsFoundation.IID {
    .init(Data1: 0x83a0cfaa, Data2: 0x6546, Data3: 0x5a63, Data4: ( 0x8c,0xd7,0xf6,0x21,0x52,0xa7,0x5d,0x27 ))// 83a0cfaa-6546-5a63-8cd7-f62152a75d27
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Capture.Frames.MediaFrameFormat>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge>
internal class IIteratorMediaFrameFormat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat }

    internal func get_CurrentImpl() throws -> UWP.MediaFrameFormat? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat
    internal typealias SwiftABI = IIteratorMediaFrameFormat
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MediaFrameFormat?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameFormat?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MediaFrameFormat? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup: WindowsFoundation.IID {
    .init(Data1: 0xdc0c1f9a, Data2: 0xb748, Data3: 0x5cfa, Data4: ( 0x9b,0x42,0xa3,0xa8,0xfe,0x37,0x28,0x1a ))// dc0c1f9a-b748-5cfa-9b42-a3a8fe37281a
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Capture.Frames.MediaFrameSourceGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge>
internal class IIteratorMediaFrameSourceGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup }

    internal func get_CurrentImpl() throws -> UWP.MediaFrameSourceGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup
    internal typealias SwiftABI = IIteratorMediaFrameSourceGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MediaFrameSourceGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameSourceGroup?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MediaFrameSourceGroup? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo: WindowsFoundation.IID {
    .init(Data1: 0x443c60d8, Data2: 0x208e, Data3: 0x5399, Data4: ( 0xbc,0x44,0xed,0xc6,0xfe,0xf0,0x22,0x93 ))// 443c60d8-208e-5399-bc44-edc6fef02293
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Capture.Frames.MediaFrameSourceInfo>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge>
internal class IIteratorMediaFrameSourceInfo: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo }

    internal func get_CurrentImpl() throws -> UWP.MediaFrameSourceInfo? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo
    internal typealias SwiftABI = IIteratorMediaFrameSourceInfo
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MediaFrameSourceInfo?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameSourceInfo?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MediaFrameSourceInfo? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription: WindowsFoundation.IID {
    .init(Data1: 0xb3e8378f, Data2: 0x710c, Data3: 0x5126, Data4: ( 0xa6,0xc9,0x8f,0x48,0x9f,0x63,0xe1,0x5e ))// b3e8378f-710c-5126-a6c9-8f489f63e15e
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge>
internal class IIteratorMediaCaptureVideoProfileMediaDescription: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription }

    internal func get_CurrentImpl() throws -> UWP.MediaCaptureVideoProfileMediaDescription? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription
    internal typealias SwiftABI = IIteratorMediaCaptureVideoProfileMediaDescription
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MediaCaptureVideoProfileMediaDescription?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MediaCaptureVideoProfileMediaDescription?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MediaCaptureVideoProfileMediaDescription? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack: WindowsFoundation.IID {
    .init(Data1: 0x138064ef, Data2: 0x8693, Data3: 0x5303, Data4: ( 0x8a,0x75,0xeb,0xa4,0x94,0xd0,0x63,0x42 ))// 138064ef-8693-5303-8a75-eba494d06342
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Core.AudioTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge>
internal class IIteratorAudioTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack }

    internal func get_CurrentImpl() throws -> UWP.AudioTrack? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack
    internal typealias SwiftABI = IIteratorAudioTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AudioTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AudioTrack?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AudioTrack? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue: WindowsFoundation.IID {
    .init(Data1: 0x1a594dc8, Data2: 0xa64b, Data3: 0x55ed, Data4: ( 0x9b,0x34,0x7b,0x27,0x4e,0x1d,0x5c,0x70 ))// 1a594dc8-a64b-55ed-9b34-7b274e1d5c70
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Core.IMediaCue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = __ABI_Windows_Media_Core.IMediaCueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge>
internal class IIteratorIMediaCue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue }

    internal func get_CurrentImpl() throws -> UWP.AnyIMediaCue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Media_Core.IMediaCueWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue
    internal typealias SwiftABI = IIteratorIMediaCue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AnyIMediaCue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AnyIMediaCue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AnyIMediaCue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer: WindowsFoundation.IID {
    .init(Data1: 0x53076581, Data2: 0x01a9, Data3: 0x51b9, Data4: ( 0x98,0xcc,0x52,0x65,0x50,0x4c,0xd3,0x52 ))// 53076581-01a9-51b9-98cc-5265504cd352
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Core.MseSourceBuffer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge>
internal class IIteratorMseSourceBuffer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer }

    internal func get_CurrentImpl() throws -> UWP.MseSourceBuffer? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer
    internal typealias SwiftABI = IIteratorMseSourceBuffer
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MseSourceBuffer?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MseSourceBuffer?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MseSourceBuffer? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange: WindowsFoundation.IID {
    .init(Data1: 0x92a36852, Data2: 0xfbb3, Data3: 0x5b48, Data4: ( 0xb4,0xec,0x01,0xdd,0xa0,0x97,0x2a,0x5c ))// 92a36852-fbb3-5b48-b4ec-01dda0972a5c
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Core.MseTimeRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge>
internal class IIteratorMseTimeRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange }

    internal func get_CurrentImpl() throws -> UWP.MseTimeRange {
        var result: __x_ABI_CWindows_CMedia_CCore_CMseTimeRange = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange
    internal typealias SwiftABI = IIteratorMseTimeRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MseTimeRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MseTimeRange
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MseTimeRange {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack: WindowsFoundation.IID {
    .init(Data1: 0x859354e5, Data2: 0x077b, Data3: 0x5d53, Data4: ( 0xb2,0x97,0x1a,0x07,0xb9,0x7f,0x09,0xc3 ))// 859354e5-077b-5d53-b297-1a07b97f09c3
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Core.TimedMetadataTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge>
internal class IIteratorTimedMetadataTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack }

    internal func get_CurrentImpl() throws -> UWP.TimedMetadataTrack? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack
    internal typealias SwiftABI = IIteratorTimedMetadataTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.TimedMetadataTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.TimedMetadataTrack?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.TimedMetadataTrack? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource: WindowsFoundation.IID {
    .init(Data1: 0xbdded7c0, Data2: 0x5c73, Data3: 0x57f5, Data4: ( 0x9b,0x08,0x65,0x29,0x33,0x58,0x6d,0xd5 ))// bdded7c0-5c73-57f5-9b08-652933586dd5
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Core.TimedTextSource>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge>
internal class IIteratorTimedTextSource: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource }

    internal func get_CurrentImpl() throws -> UWP.TimedTextSource? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource
    internal typealias SwiftABI = IIteratorTimedTextSource
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.TimedTextSource?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.TimedTextSource?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.TimedTextSource? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack: WindowsFoundation.IID {
    .init(Data1: 0xa7c8d22c, Data2: 0xb59d, Data3: 0x5d7a, Data4: ( 0x8d,0x70,0x67,0xf8,0x98,0xa0,0xb8,0x77 ))// a7c8d22c-b59d-5d7a-8d70-67f898a0b877
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Core.VideoTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge>
internal class IIteratorVideoTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack }

    internal func get_CurrentImpl() throws -> UWP.VideoTrack? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack
    internal typealias SwiftABI = IIteratorVideoTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.VideoTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.VideoTrack?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.VideoTrack? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode: WindowsFoundation.IID {
    .init(Data1: 0xe6d0bc9d, Data2: 0xe1cb, Data3: 0x5ed0, Data4: ( 0x8e,0xde,0x7d,0x03,0x7b,0xcc,0x2e,0x07 ))// e6d0bc9d-e1cb-5ed0-8ede-7d037bcc2e07
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.AdvancedPhotoMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge>
internal class IIteratorAdvancedPhotoMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode }

    internal func get_CurrentImpl() throws -> UWP.AdvancedPhotoMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CAdvancedPhotoMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode
    internal typealias SwiftABI = IIteratorAdvancedPhotoMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AdvancedPhotoMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AdvancedPhotoMode
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AdvancedPhotoMode {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange: WindowsFoundation.IID {
    .init(Data1: 0x07489ac5, Data2: 0x3c71, Data3: 0x59c6, Data4: ( 0xb7,0xdc,0x7f,0x21,0x34,0x1c,0x2f,0x71 ))// 07489ac5-3c71-59c6-b7dc-7f21341c2f71
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.AutoFocusRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge>
internal class IIteratorAutoFocusRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange }

    internal func get_CurrentImpl() throws -> UWP.AutoFocusRange {
        var result: __x_ABI_CWindows_CMedia_CDevices_CAutoFocusRange = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange
    internal typealias SwiftABI = IIteratorAutoFocusRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AutoFocusRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AutoFocusRange
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AutoFocusRange {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode: WindowsFoundation.IID {
    .init(Data1: 0xaafa6d7a, Data2: 0x2f7f, Data3: 0x5dd7, Data4: ( 0xaa,0x0a,0x26,0x57,0x31,0xa2,0xb3,0xb3 ))// aafa6d7a-2f7f-5dd7-aa0a-265731a2b3b3
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.CaptureSceneMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge>
internal class IIteratorCaptureSceneMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode }

    internal func get_CurrentImpl() throws -> UWP.CaptureSceneMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode
    internal typealias SwiftABI = IIteratorCaptureSceneMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.CaptureSceneMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.CaptureSceneMode
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.CaptureSceneMode {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController: WindowsFoundation.IID {
    .init(Data1: 0x1440dc88, Data2: 0x63ff, Data3: 0x5a01, Data4: ( 0xbb,0x93,0x39,0x0c,0x76,0x74,0x24,0x88 ))// 1440dc88-63ff-5a01-bb93-390c76742488
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.Core.FrameController>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge>
internal class IIteratorFrameController: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController }

    internal func get_CurrentImpl() throws -> UWP.FrameController? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController
    internal typealias SwiftABI = IIteratorFrameController
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.FrameController?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.FrameController?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.FrameController? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode: WindowsFoundation.IID {
    .init(Data1: 0xf9a43cd4, Data2: 0xb300, Data3: 0x541f, Data4: ( 0xaf,0x79,0x3d,0xe3,0x40,0x0e,0x16,0xaf ))// f9a43cd4-b300-541f-af79-3de3400e16af
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.FocusMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge>
internal class IIteratorFocusMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode }

    internal func get_CurrentImpl() throws -> UWP.FocusMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CFocusMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode
    internal typealias SwiftABI = IIteratorFocusMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.FocusMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.FocusMode
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.FocusMode {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset: WindowsFoundation.IID {
    .init(Data1: 0xd3ebc8e9, Data2: 0xf0c5, Data3: 0x51c0, Data4: ( 0xbb,0x86,0xbd,0xea,0x0a,0x69,0x46,0xfb ))// d3ebc8e9-f0c5-51c0-bb86-bdea0a6946fb
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.FocusPreset>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge>
internal class IIteratorFocusPreset: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset }

    internal func get_CurrentImpl() throws -> UWP.FocusPreset {
        var result: __x_ABI_CWindows_CMedia_CDevices_CFocusPreset = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset
    internal typealias SwiftABI = IIteratorFocusPreset
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.FocusPreset>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.FocusPreset
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.FocusPreset {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode: WindowsFoundation.IID {
    .init(Data1: 0x3db61d13, Data2: 0x0f30, Data3: 0x5d2d, Data4: ( 0x99,0xcb,0x30,0xc7,0xb9,0x00,0x98,0x78 ))// 3db61d13-0f30-5d2d-99cb-30c7b9009878
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.HdrVideoMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge>
internal class IIteratorHdrVideoMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode }

    internal func get_CurrentImpl() throws -> UWP.HdrVideoMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CHdrVideoMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode
    internal typealias SwiftABI = IIteratorHdrVideoMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HdrVideoMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HdrVideoMode
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HdrVideoMode {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode: WindowsFoundation.IID {
    .init(Data1: 0x42a9e83e, Data2: 0x1786, Data3: 0x57f4, Data4: ( 0x90,0x6e,0x2f,0x9b,0x6f,0x9f,0x84,0x9a ))// 42a9e83e-1786-57f4-906e-2f9b6f9f849a
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.InfraredTorchMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge>
internal class IIteratorInfraredTorchMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode }

    internal func get_CurrentImpl() throws -> UWP.InfraredTorchMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CInfraredTorchMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode
    internal typealias SwiftABI = IIteratorInfraredTorchMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.InfraredTorchMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.InfraredTorchMode
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.InfraredTorchMode {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset: WindowsFoundation.IID {
    .init(Data1: 0x1b33af76, Data2: 0x980b, Data3: 0x5348, Data4: ( 0x91,0x6a,0x79,0x3f,0x61,0xb5,0x55,0xa0 ))// 1b33af76-980b-5348-916a-793f61b555a0
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.IsoSpeedPreset>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge>
internal class IIteratorIsoSpeedPreset: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset }

    internal func get_CurrentImpl() throws -> UWP.IsoSpeedPreset {
        var result: __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset
    internal typealias SwiftABI = IIteratorIsoSpeedPreset
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.IsoSpeedPreset>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.IsoSpeedPreset
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.IsoSpeedPreset {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance: WindowsFoundation.IID {
    .init(Data1: 0xb02944e1, Data2: 0xf649, Data3: 0x511e, Data4: ( 0x80,0xdd,0x2e,0x2b,0x20,0x37,0x9d,0xeb ))// b02944e1-f649-511e-80dd-2e2b20379deb
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.ManualFocusDistance>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge>
internal class IIteratorManualFocusDistance: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance }

    internal func get_CurrentImpl() throws -> UWP.ManualFocusDistance {
        var result: __x_ABI_CWindows_CMedia_CDevices_CManualFocusDistance = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance
    internal typealias SwiftABI = IIteratorManualFocusDistance
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.ManualFocusDistance>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.ManualFocusDistance
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.ManualFocusDistance {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode: WindowsFoundation.IID {
    .init(Data1: 0x4a165d46, Data2: 0xcf19, Data3: 0x5a03, Data4: ( 0xbb,0x54,0x63,0xfc,0x2b,0x4e,0xd3,0x9b ))// 4a165d46-cf19-5a03-bb54-63fc2b4ed39b
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.OpticalImageStabilizationMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge>
internal class IIteratorOpticalImageStabilizationMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode }

    internal func get_CurrentImpl() throws -> UWP.OpticalImageStabilizationMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_COpticalImageStabilizationMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode
    internal typealias SwiftABI = IIteratorOpticalImageStabilizationMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.OpticalImageStabilizationMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.OpticalImageStabilizationMode
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.OpticalImageStabilizationMode {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest: WindowsFoundation.IID {
    .init(Data1: 0x8eb80e4e, Data2: 0x9691, Data3: 0x594f, Data4: ( 0x8b,0x3d,0xf5,0x2e,0xcc,0x0f,0x78,0x37 ))// 8eb80e4e-9691-594f-8b3d-f52ecc0f7837
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.RegionOfInterest>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestBridge>
internal class IIteratorRegionOfInterest: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest }

    internal func get_CurrentImpl() throws -> UWP.RegionOfInterest? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterest
    internal typealias SwiftABI = IIteratorRegionOfInterest
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.RegionOfInterest?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.RegionOfInterest?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CRegionOfInterestBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.RegionOfInterest? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode: WindowsFoundation.IID {
    .init(Data1: 0x9b062552, Data2: 0xe75c, Data3: 0x515e, Data4: ( 0xa2,0xa4,0x1b,0x08,0x1b,0x64,0x06,0x14 ))// 9b062552-e75c-515e-a2a4-1b081b640614
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.VideoTemporalDenoisingMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge>
internal class IIteratorVideoTemporalDenoisingMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode }

    internal func get_CurrentImpl() throws -> UWP.VideoTemporalDenoisingMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CVideoTemporalDenoisingMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode
    internal typealias SwiftABI = IIteratorVideoTemporalDenoisingMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.VideoTemporalDenoisingMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.VideoTemporalDenoisingMode
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.VideoTemporalDenoisingMode {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode: WindowsFoundation.IID {
    .init(Data1: 0x80eb468a, Data2: 0xfdc4, Data3: 0x5c89, Data4: ( 0x99,0xb8,0x8d,0x47,0x62,0x64,0xe2,0x11 ))// 80eb468a-fdc4-5c89-99b8-8d476264e211
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Devices.ZoomTransitionMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge>
internal class IIteratorZoomTransitionMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode }

    internal func get_CurrentImpl() throws -> UWP.ZoomTransitionMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CZoomTransitionMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode
    internal typealias SwiftABI = IIteratorZoomTransitionMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.ZoomTransitionMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.ZoomTransitionMode
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.ZoomTransitionMode {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties: WindowsFoundation.IID {
    .init(Data1: 0x7c094aec, Data2: 0xc8f3, Data3: 0x5f49, Data4: ( 0x99,0xc7,0xb6,0x6d,0x84,0x14,0x20,0x0e ))// 7c094aec-c8f3-5f49-99c7-b66d8414200e
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.MediaProperties.IMediaEncodingProperties>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = __ABI_Windows_Media_MediaProperties.IMediaEncodingPropertiesWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge>
internal class IIteratorIMediaEncodingProperties: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties }

    internal func get_CurrentImpl() throws -> UWP.AnyIMediaEncodingProperties? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Media_MediaProperties.IMediaEncodingPropertiesWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties
    internal typealias SwiftABI = IIteratorIMediaEncodingProperties
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AnyIMediaEncodingProperties?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AnyIMediaEncodingProperties?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AnyIMediaEncodingProperties? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRange: WindowsFoundation.IID {
    .init(Data1: 0x29b8d190, Data2: 0x5e46, Data3: 0x5873, Data4: ( 0xaf,0xc0,0x8f,0x2f,0x40,0xfb,0xe8,0xfd ))// 29b8d190-5e46-5873-afc0-8f2f40fbe8fd
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.MediaTimeRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge>
internal class IIteratorMediaTimeRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRange }

    internal func get_CurrentImpl() throws -> UWP.MediaTimeRange {
        var result: __x_ABI_CWindows_CMedia_CMediaTimeRange = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRange
    internal typealias SwiftABI = IIteratorMediaTimeRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MediaTimeRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MediaTimeRange
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MediaTimeRange {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak: WindowsFoundation.IID {
    .init(Data1: 0x9efd8746, Data2: 0xf93c, Data3: 0x524f, Data4: ( 0x9f,0x95,0x4b,0x59,0x8a,0xcf,0x8d,0x25 ))// 9efd8746-f93c-524f-9f95-4b598acf8d25
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Playback.MediaBreak>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge>
internal class IIteratorMediaBreak: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak }

    internal func get_CurrentImpl() throws -> UWP.MediaBreak? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak
    internal typealias SwiftABI = IIteratorMediaBreak
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MediaBreak?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MediaBreak?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MediaBreak? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem: WindowsFoundation.IID {
    .init(Data1: 0xab074059, Data2: 0x8c08, Data3: 0x53e7, Data4: ( 0x96,0x54,0x02,0xd2,0x59,0x8f,0xff,0x55 ))// ab074059-8c08-53e7-9654-02d2598fff55
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Playback.MediaPlaybackItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge>
internal class IIteratorMediaPlaybackItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem }

    internal func get_CurrentImpl() throws -> UWP.MediaPlaybackItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem
    internal typealias SwiftABI = IIteratorMediaPlaybackItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.MediaPlaybackItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.MediaPlaybackItem?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.MediaPlaybackItem? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker: WindowsFoundation.IID {
    .init(Data1: 0x28607d6b, Data2: 0xdaa4, Data3: 0x5eef, Data4: ( 0x9f,0x81,0xcc,0x08,0xa8,0x29,0x71,0x82 ))// 28607d6b-daa4-5eef-9f81-cc08a8297182
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Playback.PlaybackMediaMarker>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerBridge>
internal class IIteratorPlaybackMediaMarker: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker }

    internal func get_CurrentImpl() throws -> UWP.PlaybackMediaMarker? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarker
    internal typealias SwiftABI = IIteratorPlaybackMediaMarker
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.PlaybackMediaMarker?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.PlaybackMediaMarker?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.PlaybackMediaMarker? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem: WindowsFoundation.IID {
    .init(Data1: 0xdfb9655c, Data2: 0x8b22, Data3: 0x511f, Data4: ( 0x8e,0xaf,0x3a,0xea,0x75,0x21,0x80,0x2b ))// dfb9655c-8b22-511f-8eaf-3aea7521802b
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Media.Protection.RevocationAndRenewalItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge>
internal class IIteratorRevocationAndRenewalItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem }

    internal func get_CurrentImpl() throws -> UWP.RevocationAndRenewalItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem
    internal typealias SwiftABI = IIteratorRevocationAndRenewalItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.RevocationAndRenewalItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.RevocationAndRenewalItem?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.RevocationAndRenewalItem? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange: WindowsFoundation.IID {
    .init(Data1: 0xa753d778, Data2: 0x8cbb, Data3: 0x524a, Data4: ( 0xb8,0xc4,0x70,0xc5,0x15,0xa4,0x27,0x82 ))// a753d778-8cbb-524a-b8c4-70c515a42782
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Networking.BackgroundTransfer.BackgroundTransferFileRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge>
internal class IIteratorBackgroundTransferFileRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange }

    internal func get_CurrentImpl() throws -> UWP.BackgroundTransferFileRange {
        var result: __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferFileRange = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange
    internal typealias SwiftABI = IIteratorBackgroundTransferFileRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.BackgroundTransferFileRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.BackgroundTransferFileRange
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.BackgroundTransferFileRange {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0x4070c40f, Data2: 0xab2f, Data3: 0x56f2, Data4: ( 0xb5,0x4c,0x82,0x32,0xae,0x86,0xaa,0xcd ))// 4070c40f-ab2f-56f2-b54c-8232ae86aacd
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Networking.Connectivity.AttributedNetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge>
internal class IIteratorAttributedNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage }

    internal func get_CurrentImpl() throws -> UWP.AttributedNetworkUsage? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage
    internal typealias SwiftABI = IIteratorAttributedNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AttributedNetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AttributedNetworkUsage?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AttributedNetworkUsage? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval: WindowsFoundation.IID {
    .init(Data1: 0x741cea48, Data2: 0x651c, Data3: 0x5fd9, Data4: ( 0x93,0x1e,0x4f,0x91,0xb5,0x21,0xe1,0x82 ))// 741cea48-651c-5fd9-931e-4f91b521e182
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Networking.Connectivity.ConnectivityInterval>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge>
internal class IIteratorConnectivityInterval: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval }

    internal func get_CurrentImpl() throws -> UWP.ConnectivityInterval? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval
    internal typealias SwiftABI = IIteratorConnectivityInterval
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.ConnectivityInterval?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.ConnectivityInterval?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.ConnectivityInterval? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0x5fafb57b, Data2: 0x9c82, Data3: 0x50a1, Data4: ( 0x99,0x70,0x69,0xf9,0xcb,0x06,0x96,0x95 ))// 5fafb57b-9c82-50a1-9970-69f9cb069695
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Networking.Connectivity.NetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge>
internal class IIteratorNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage }

    internal func get_CurrentImpl() throws -> UWP.NetworkUsage? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage
    internal typealias SwiftABI = IIteratorNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.NetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.NetworkUsage?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.NetworkUsage? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0xd7090752, Data2: 0xab5f, Data3: 0x506f, Data4: ( 0x8f,0x15,0x56,0xb3,0x75,0x52,0xfb,0xea ))// d7090752-ab5f-506f-8f15-56b37552fbea
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Networking.Connectivity.ProviderNetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge>
internal class IIteratorProviderNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage }

    internal func get_CurrentImpl() throws -> UWP.ProviderNetworkUsage? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage
    internal typealias SwiftABI = IIteratorProviderNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.ProviderNetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.ProviderNetworkUsage?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.ProviderNetworkUsage? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate: WindowsFoundation.IID {
    .init(Data1: 0x676fc159, Data2: 0xf15c, Data3: 0x58bd, Data4: ( 0x91,0xa7,0x28,0xf7,0xe7,0x95,0xc7,0x56 ))// 676fc159-f15c-58bd-91a7-28f7e795c756
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Security.Cryptography.Certificates.Certificate>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge>
internal class IIteratorCertificate: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate }

    internal func get_CurrentImpl() throws -> UWP.Certificate? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate
    internal typealias SwiftABI = IIteratorCertificate
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.Certificate?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.Certificate?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.Certificate? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult: WindowsFoundation.IID {
    .init(Data1: 0x8bcad2b7, Data2: 0x0e3b, Data3: 0x5eae, Data4: ( 0xbf,0x69,0xe1,0xf6,0xd9,0xc8,0x88,0xf8 ))// 8bcad2b7-0e3b-5eae-bf69-e1f6d9c888f8
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Security.Cryptography.Certificates.ChainValidationResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge>
internal class IIteratorChainValidationResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult }

    internal func get_CurrentImpl() throws -> UWP.ChainValidationResult {
        var result: __x_ABI_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult
    internal typealias SwiftABI = IIteratorChainValidationResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.ChainValidationResult>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.ChainValidationResult
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.ChainValidationResult {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0x05b487c2, Data2: 0x3830, Data3: 0x5d3c, Data4: ( 0x98,0xda,0x25,0xfa,0x11,0x54,0x2d,0xbd ))// 05b487c2-3830-5d3c-98da-25fa11542dbd
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Storage.IStorageItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let resultWrapper = __ABI_Windows_Storage.IStorageItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemBridge>
internal class IIteratorIStorageItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItem }

    internal func get_CurrentImpl() throws -> UWP.AnyIStorageItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItem
    internal typealias SwiftABI = IIteratorIStorageItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.AnyIStorageItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.AnyIStorageItem?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CIStorageItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.AnyIStorageItem? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry: WindowsFoundation.IID {
    .init(Data1: 0x520434a2, Data2: 0xacf7, Data3: 0x58c9, Data4: ( 0xb4,0x7a,0x27,0x41,0xf2,0xfa,0xc2,0xc2 ))// 520434a2-acf7-58c9-b47a-2741f2fac2c2
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Storage.Search.SortEntry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        let _result = __ABI_Windows_Storage_Search._ABI_SortEntry(from: result)
        	$1?.initialize(to: _result.detach())
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge>
internal class IIteratorSortEntry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry }

    internal func get_CurrentImpl() throws -> UWP.SortEntry {
        var result: __x_ABI_CWindows_CStorage_CSearch_CSortEntry = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry
    internal typealias SwiftABI = IIteratorSortEntry
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.SortEntry>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.SortEntry
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.SortEntry {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFile: WindowsFoundation.IID {
    .init(Data1: 0x43e29f53, Data2: 0x0298, Data3: 0x55aa, Data4: ( 0xa6,0xc8,0x4e,0xdd,0x32,0x3d,0x95,0x98 ))// 43e29f53-0298-55aa-a6c8-4edd323d9598
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Storage.StorageFile>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileBridge>
internal class IIteratorStorageFile: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFile }

    internal func get_CurrentImpl() throws -> UWP.StorageFile? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFile
    internal typealias SwiftABI = IIteratorStorageFile
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.StorageFile?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.StorageFile?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFileBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.StorageFile? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolder: WindowsFoundation.IID {
    .init(Data1: 0x5aac96fb, Data2: 0xb3b9, Data3: 0x5a7f, Data4: ( 0xa9,0x20,0x4b,0x5a,0x8d,0xf8,0x11,0x68 ))// 5aac96fb-b3b9-5a7f-a920-4b5a8df81168
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Storage.StorageFolder>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderBridge>
internal class IIteratorStorageFolder: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolder }

    internal func get_CurrentImpl() throws -> UWP.StorageFolder? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolder
    internal typealias SwiftABI = IIteratorStorageFolder
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.StorageFolder?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.StorageFolder?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageFolderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.StorageFolder? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChange: WindowsFoundation.IID {
    .init(Data1: 0xc48a1103, Data2: 0x56e6, Data3: 0x5398, Data4: ( 0x84,0xfe,0x92,0xed,0xad,0x7f,0xc1,0x11 ))// c48a1103-56e6-5398-84fe-92edad7fc111
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Storage.StorageLibraryChange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge>
internal class IIteratorStorageLibraryChange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChange }

    internal func get_CurrentImpl() throws -> UWP.StorageLibraryChange? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChange
    internal typealias SwiftABI = IIteratorStorageLibraryChange
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.StorageLibraryChange?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.StorageLibraryChange?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.StorageLibraryChange? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUser: WindowsFoundation.IID {
    .init(Data1: 0x326fe162, Data2: 0x582b, Data3: 0x5659, Data4: ( 0xb8,0xa4,0x68,0xff,0x0f,0x52,0x57,0x45 ))// 326fe162-582b-5659-b8a4-68ff0f525745
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.System.User>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserBridge>
internal class IIteratorUser: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUser }

    internal func get_CurrentImpl() throws -> UWP.User? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUser
    internal typealias SwiftABI = IIteratorUser
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.User?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.User?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CSystem__CUserBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.User? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation: WindowsFoundation.IID {
    .init(Data1: 0x98efbe55, Data2: 0x0a66, Data3: 0x556a, Data4: ( 0x9a,0xdc,0x4a,0xb5,0x9c,0x69,0x68,0x46 ))// 98efbe55-0a66-556a-9adc-4ab59c696846
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.UI.Composition.CompositionAnimation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationBridge>
internal class IIteratorCompositionAnimation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation }

    internal func get_CurrentImpl() throws -> UWP.CompositionAnimation? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimation
    internal typealias SwiftABI = IIteratorCompositionAnimation
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.CompositionAnimation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.CompositionAnimation?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionAnimationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.CompositionAnimation? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop: WindowsFoundation.IID {
    .init(Data1: 0x746a0f51, Data2: 0x47f4, Data3: 0x5395, Data4: ( 0x8e,0xdd,0x8a,0xe1,0xe9,0x3a,0x81,0x83 ))// 746a0f51-47f4-5395-8edd-8ae1e93a8183
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.UI.Composition.CompositionColorGradientStop>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge>
internal class IIteratorCompositionColorGradientStop: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop }

    internal func get_CurrentImpl() throws -> UWP.CompositionColorGradientStop? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop
    internal typealias SwiftABI = IIteratorCompositionColorGradientStop
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.CompositionColorGradientStop?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.CompositionColorGradientStop?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.CompositionColorGradientStop? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster: WindowsFoundation.IID {
    .init(Data1: 0x6563b1b1, Data2: 0x4b53, Data3: 0x53df, Data4: ( 0xa0,0xc0,0xd3,0xca,0x1d,0xbb,0xfe,0x59 ))// 6563b1b1-4b53-53df-a0c0-d3ca1dbbfe59
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.UI.Composition.CompositionProjectedShadowCaster>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterBridge>
internal class IIteratorCompositionProjectedShadowCaster: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster }

    internal func get_CurrentImpl() throws -> UWP.CompositionProjectedShadowCaster? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCaster
    internal typealias SwiftABI = IIteratorCompositionProjectedShadowCaster
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.CompositionProjectedShadowCaster?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.CompositionProjectedShadowCaster?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowCasterBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.CompositionProjectedShadowCaster? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver: WindowsFoundation.IID {
    .init(Data1: 0xd2452315, Data2: 0x9a6e, Data3: 0x5033, Data4: ( 0x9e,0x8f,0xc2,0x59,0x41,0xad,0xbe,0x71 ))// d2452315-9a6e-5033-9e8f-c25941adbe71
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.UI.Composition.CompositionProjectedShadowReceiver>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverBridge>
internal class IIteratorCompositionProjectedShadowReceiver: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver }

    internal func get_CurrentImpl() throws -> UWP.CompositionProjectedShadowReceiver? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiver
    internal typealias SwiftABI = IIteratorCompositionProjectedShadowReceiver
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.CompositionProjectedShadowReceiver?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.CompositionProjectedShadowReceiver?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionProjectedShadowReceiverBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.CompositionProjectedShadowReceiver? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape: WindowsFoundation.IID {
    .init(Data1: 0xff8d5b3b, Data2: 0xab18, Data3: 0x5307, Data4: ( 0x9f,0xfe,0xe3,0xb5,0xd6,0x34,0x52,0xa4 ))// ff8d5b3b-ab18-5307-9ffe-e3b5d63452a4
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.UI.Composition.CompositionShape>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge>
internal class IIteratorCompositionShape: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape }

    internal func get_CurrentImpl() throws -> UWP.CompositionShape? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape
    internal typealias SwiftABI = IIteratorCompositionShape
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.CompositionShape?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.CompositionShape?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.CompositionShape? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisual: WindowsFoundation.IID {
    .init(Data1: 0xeca15496, Data2: 0xdcaa, Data3: 0x5095, Data4: ( 0xa8,0x98,0xf8,0x60,0x2a,0x40,0xe1,0x0a ))// eca15496-dcaa-5095-a898-f8602a40e10a
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.UI.Composition.Visual>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualBridge>
internal class IIteratorVisual: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisual }

    internal func get_CurrentImpl() throws -> UWP.Visual? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisual.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisual.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisual.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisual
    internal typealias SwiftABI = IIteratorVisual
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.Visual?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.Visual?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CComposition__CVisualBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.Visual? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPoint: WindowsFoundation.IID {
    .init(Data1: 0x721fe01c, Data2: 0x5ad4, Data3: 0x5262, Data4: ( 0xb0,0x78,0x3a,0xb3,0x45,0x10,0x5d,0xb8 ))// 721fe01c-5ad4-5262-b078-3ab345105db8
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.UI.Input.PointerPoint>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge>
internal class IIteratorPointerPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPoint }

    internal func get_CurrentImpl() throws -> UWP.PointerPoint? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPoint
    internal typealias SwiftABI = IIteratorPointerPoint
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.PointerPoint?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.PointerPoint?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.PointerPoint? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification: WindowsFoundation.IID {
    .init(Data1: 0x04d8d70b, Data2: 0x7c15, Data3: 0x5f60, Data4: ( 0x98,0x94,0xb2,0x13,0x66,0xb4,0x27,0xc2 ))// 04d8d70b-7c15-5f60-9894-b21366b427c2
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.UI.Notifications.ShownTileNotification>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge>
internal class IIteratorShownTileNotification: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification }

    internal func get_CurrentImpl() throws -> UWP.ShownTileNotification? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification
    internal typealias SwiftABI = IIteratorShownTileNotification
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.ShownTileNotification?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.ShownTileNotification?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.ShownTileNotification? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x6bc05705, Data2: 0x2c6f, Data3: 0x57e8, Data4: ( 0xbf,0x96,0x56,0xa7,0x61,0xe9,0x0e,0x8f ))// 6bc05705-2c6f-57e8-bf96-56a761e90e8f
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpChallengeHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge>
internal class IIteratorHttpChallengeHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpChallengeHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue
    internal typealias SwiftABI = IIteratorHttpChallengeHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpChallengeHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpChallengeHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpChallengeHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xe95057be, Data2: 0xe8bd, Data3: 0x53df, Data4: ( 0xa2,0xf6,0x86,0x5a,0x66,0xa0,0x7c,0x6b ))// e95057be-e8bd-53df-a2f6-865a66a07c6b
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge>
internal class IIteratorHttpConnectionOptionHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpConnectionOptionHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue
    internal typealias SwiftABI = IIteratorHttpConnectionOptionHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpConnectionOptionHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpConnectionOptionHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpConnectionOptionHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xe21ad0b2, Data2: 0xc893, Data3: 0x5360, Data4: ( 0xa4,0xfe,0xf0,0x83,0xb3,0x08,0xa9,0xcd ))// e21ad0b2-c893-5360-a4fe-f083b308a9cd
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpContentCodingHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge>
internal class IIteratorHttpContentCodingHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpContentCodingHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue
    internal typealias SwiftABI = IIteratorHttpContentCodingHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpContentCodingHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpContentCodingHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpContentCodingHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x3780c808, Data2: 0x8b98, Data3: 0x5327, Data4: ( 0x84,0xc7,0x05,0x53,0x63,0xfe,0x32,0xad ))// 3780c808-8b98-5327-84c7-055363fe32ad
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge>
internal class IIteratorHttpContentCodingWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpContentCodingWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue
    internal typealias SwiftABI = IIteratorHttpContentCodingWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpContentCodingWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpContentCodingWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpContentCodingWithQualityHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xed3b6323, Data2: 0xb1c3, Data3: 0x558b, Data4: ( 0x99,0x17,0x08,0x26,0xc4,0xa9,0xe8,0xc0 ))// ed3b6323-b1c3-558b-9917-0826c4a9e8c0
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpCookiePairHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge>
internal class IIteratorHttpCookiePairHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpCookiePairHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue
    internal typealias SwiftABI = IIteratorHttpCookiePairHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpCookiePairHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpCookiePairHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpCookiePairHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x6b72326a, Data2: 0x46b1, Data3: 0x5d80, Data4: ( 0xa1,0x62,0xc5,0xf4,0x5b,0xe0,0x2e,0x2b ))// 6b72326a-46b1-5d80-a162-c5f45be02e2b
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpExpectationHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge>
internal class IIteratorHttpExpectationHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpExpectationHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue
    internal typealias SwiftABI = IIteratorHttpExpectationHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpExpectationHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpExpectationHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpExpectationHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xa25503de, Data2: 0x4aef, Data3: 0x5ef4, Data4: ( 0x9f,0x06,0x5d,0xf4,0x09,0x40,0x51,0xbe ))// a25503de-4aef-5ef4-9f06-5df4094051be
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge>
internal class IIteratorHttpLanguageRangeWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpLanguageRangeWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue
    internal typealias SwiftABI = IIteratorHttpLanguageRangeWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpLanguageRangeWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpLanguageRangeWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpLanguageRangeWithQualityHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x6a2084a3, Data2: 0x941a, Data3: 0x5528, Data4: ( 0xa2,0xec,0x28,0xcf,0x1f,0xf9,0xb1,0xa9 ))// 6a2084a3-941a-5528-a2ec-28cf1ff9b1a9
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge>
internal class IIteratorHttpMediaTypeWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpMediaTypeWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue
    internal typealias SwiftABI = IIteratorHttpMediaTypeWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpMediaTypeWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpMediaTypeWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpMediaTypeWithQualityHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x3bb0c8fa, Data2: 0x5f1f, Data3: 0x5c70, Data4: ( 0x99,0x50,0x5d,0x1d,0x1a,0x70,0x3d,0xd4 ))// 3bb0c8fa-5f1f-5c70-9950-5d1d1a703dd4
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpNameValueHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge>
internal class IIteratorHttpNameValueHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpNameValueHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue
    internal typealias SwiftABI = IIteratorHttpNameValueHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpNameValueHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpNameValueHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpNameValueHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x4f785951, Data2: 0xb59c, Data3: 0x5108, Data4: ( 0xb0,0xcd,0x14,0x37,0x57,0x8a,0xf4,0x9c ))// 4f785951-b59c-5108-b0cd-1437578af49c
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpProductInfoHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge>
internal class IIteratorHttpProductInfoHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpProductInfoHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue
    internal typealias SwiftABI = IIteratorHttpProductInfoHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpProductInfoHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpProductInfoHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpProductInfoHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x49e58dec, Data2: 0xb5cd, Data3: 0x5ba4, Data4: ( 0xa6,0x03,0x36,0x5d,0x15,0x88,0xad,0x4c ))// 49e58dec-b5cd-5ba4-a603-365d1588ad4c
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.Headers.HttpTransferCodingHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge>
internal class IIteratorHttpTransferCodingHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue }

    internal func get_CurrentImpl() throws -> UWP.HttpTransferCodingHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue
    internal typealias SwiftABI = IIteratorHttpTransferCodingHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpTransferCodingHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpTransferCodingHeaderValue?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpTransferCodingHeaderValue? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod: WindowsFoundation.IID {
    .init(Data1: 0xd13a880f, Data2: 0xd612, Data3: 0x50cf, Data4: ( 0xa6,0xf9,0xdd,0x96,0xf9,0x16,0xf4,0x91 ))// d13a880f-d612-50cf-a6f9-dd96f916f491
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.Http.HttpMethod>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge>
internal class IIteratorHttpMethod: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod }

    internal func get_CurrentImpl() throws -> UWP.HttpMethod? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod
    internal typealias SwiftABI = IIteratorHttpMethod
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.HttpMethod?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.HttpMethod?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.HttpMethod? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatus: WindowsFoundation.IID {
    .init(Data1: 0xfa704929, Data2: 0x0761, Data3: 0x5dd6, Data4: ( 0x96,0x75,0x05,0x2a,0x8c,0x61,0xe2,0xc2 ))// fa704929-0761-5dd6-9675-052a8c61e2c2
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Web.WebErrorStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard let __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge>
internal class IIteratorWebErrorStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatus }

    internal func get_CurrentImpl() throws -> UWP.WebErrorStatus {
        var result: __x_ABI_CWindows_CWeb_CWebErrorStatus = .init(0)
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal func get_HasCurrentImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal func MoveNextImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatus
    internal typealias SwiftABI = IIteratorWebErrorStatus
    internal typealias SwiftProjection = WindowsFoundation.AnyIIterator<UWP.WebErrorStatus>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusImpl : IIterator, AbiInterfaceImpl {
    typealias T = UWP.WebErrorStatus
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate func moveNext() -> Bool {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : UWP.WebErrorStatus {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Bool {
        get { try! _default.get_HasCurrentImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x3bda1540, Data2: 0xd089, Data3: 0x5a1a, Data4: ( 0x8f,0x0d,0x94,0xeb,0xa8,0x06,0x8e,0x58 ))// 3bda1540-d089-5a1a-8f0d-94eba8068e58
}

internal var __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVTable: __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        let resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge>
internal class IKeyValuePairUUID_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_GUID_IInspectable }

    internal func get_KeyImpl() throws -> Foundation.UUID {
        var result: WindowsFoundation.GUID = .init()
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> Any? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_GUID_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_GUID_IInspectable
    internal typealias SwiftABI = IKeyValuePairUUID_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_GUID_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = Foundation.UUID
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_GUID_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : Foundation.UUID {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : Any? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration: WindowsFoundation.IID {
    .init(Data1: 0x9bcb843b, Data2: 0x221b, Data3: 0x5fbe, Data4: ( 0x9b,0x20,0x70,0x28,0xbc,0x4e,0x86,0x53 ))// 9bcb843b-221b-5fbe-9b20-7028bc4e8653
}

internal var __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVTable: __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Windows.ApplicationModel.Background.BackgroundTaskRegistration>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        result?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge>
internal class IKeyValuePairUUID_BackgroundTaskRegistration: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration }

    internal func get_KeyImpl() throws -> Foundation.UUID {
        var result: WindowsFoundation.GUID = .init()
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> UWP.BackgroundTaskRegistration? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration
    internal typealias SwiftABI = IKeyValuePairUUID_BackgroundTaskRegistration
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = Foundation.UUID
    typealias V = UWP.BackgroundTaskRegistration?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : Foundation.UUID {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : UWP.BackgroundTaskRegistration? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration: WindowsFoundation.IID {
    .init(Data1: 0x5a1f6d75, Data2: 0x8678, Data3: 0x547c, Data4: ( 0x8f,0xd7,0xfb,0xce,0xb6,0xeb,0xf9,0x68 ))// 5a1f6d75-8678-547c-8fd7-fbceb6ebf968
}

internal var __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVTable: __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<Foundation.UUID, Windows.ApplicationModel.Background.IBackgroundTaskRegistration>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        let resultWrapper = __ABI_Windows_ApplicationModel_Background.IBackgroundTaskRegistrationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge>
internal class IKeyValuePairUUID_IBackgroundTaskRegistration: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration }

    internal func get_KeyImpl() throws -> Foundation.UUID {
        var result: WindowsFoundation.GUID = .init()
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> UWP.AnyIBackgroundTaskRegistration? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_ApplicationModel_Background.IBackgroundTaskRegistrationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration
    internal typealias SwiftABI = IKeyValuePairUUID_IBackgroundTaskRegistration
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = Foundation.UUID
    typealias V = UWP.AnyIBackgroundTaskRegistration?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : Foundation.UUID {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : UWP.AnyIBackgroundTaskRegistration? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x09335560, Data2: 0x6c6b, Data3: 0x5a26, Data4: ( 0x93,0x48,0x97,0xb7,0x81,0x13,0x2b,0x20 ))// 09335560-6c6b-5a26-9348-97b781132b20
}

internal var __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVTable: __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<String, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        let resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge>
internal class IKeyValuePairString_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> Any? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectable
    internal typealias SwiftABI = IKeyValuePairString_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<String, Any?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = String
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : Any? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x60310303, Data2: 0x49c5, Data3: 0x52e6, Data4: ( 0xab,0xc6,0xa9,0xb3,0x6e,0xcc,0xc7,0x16 ))// 60310303-49c5-52e6-abc6-a9b36eccc716
}

internal var __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVTable: __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<String, String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge>
internal class IKeyValuePairString_String: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRING
    internal typealias SwiftABI = IKeyValuePairString_String
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<String, String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = String
    typealias V = String
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : String {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup: WindowsFoundation.IID {
    .init(Data1: 0x67a07f76, Data2: 0x20b0, Data3: 0x573b, Data4: ( 0x9d,0x74,0xed,0x0f,0xc4,0xf6,0x53,0xc7 ))// 67a07f76-20b0-573b-9d74-ed0fc4f653c7
}

internal var __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVTable: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        result?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge>
internal class IKeyValuePairString_BackgroundTaskRegistrationGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> UWP.BackgroundTaskRegistrationGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup
    internal typealias SwiftABI = IKeyValuePairString_BackgroundTaskRegistrationGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = String
    typealias V = UWP.BackgroundTaskRegistrationGroup?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : UWP.BackgroundTaskRegistrationGroup? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment: WindowsFoundation.IID {
    .init(Data1: 0x77b4daf4, Data2: 0x4f4f, Data3: 0x5568, Data4: ( 0x90,0xee,0x1a,0x32,0xcf,0x0c,0xaa,0xea ))// 77b4daf4-4f4f-5568-90ee-1a32cf0caaea
}

internal var __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Foundation.Collections.IVectorView`1<Windows.Data.Text.TextSegment>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge>
internal class IKeyValuePairString_IVectorViewTextSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.TextSegment>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment
    internal typealias SwiftABI = IKeyValuePairString_IVectorViewTextSegment
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = String
    typealias V = WindowsFoundation.AnyIVectorView<UWP.TextSegment>?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : WindowsFoundation.AnyIVectorView<UWP.TextSegment>? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x174f26c7, Data2: 0x79ea, Data3: 0x5f7c, Data4: ( 0xbd,0x70,0xac,0x44,0x57,0xf2,0xca,0xc8 ))// 174f26c7-79ea-5f7c-bd70-ac4457f2cac8
}

internal var __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Foundation.Collections.IVector`1<String>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        let resultWrapper = UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge>
internal class IKeyValuePairString_IVectorString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> WindowsFoundation.AnyIVector<String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRING
    internal typealias SwiftABI = IKeyValuePairString_IVectorString
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = String
    typealias V = WindowsFoundation.AnyIVector<String>?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : WindowsFoundation.AnyIVector<String>? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue: WindowsFoundation.IID {
    .init(Data1: 0x93621bf0, Data2: 0xdae9, Data3: 0x5f00, Data4: ( 0x94,0xac,0x79,0x5a,0xa9,0x43,0xdc,0xa6 ))// 93621bf0-dae9-5f00-94ac-795aa943dca6
}

internal var __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Graphics.Imaging.BitmapTypedValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        result?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge>
internal class IKeyValuePairString_BitmapTypedValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> UWP.BitmapTypedValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue
    internal typealias SwiftABI = IKeyValuePairString_BitmapTypedValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = String
    typealias V = UWP.BitmapTypedValue?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : UWP.BitmapTypedValue? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0xe5195792, Data2: 0xaeab, Data3: 0x56e8, Data4: ( 0xbd,0x30,0x13,0x72,0xc4,0x34,0x0b,0xf6 ))// e5195792-aeab-56e8-bd30-1372c4340bf6
}

internal var __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.Storage.Streams.RandomAccessStreamReference>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        result?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class IKeyValuePairString_RandomAccessStreamReference: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> UWP.RandomAccessStreamReference? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = IKeyValuePairString_RandomAccessStreamReference
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = String
    typealias V = UWP.RandomAccessStreamReference?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : UWP.RandomAccessStreamReference? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase: WindowsFoundation.IID {
    .init(Data1: 0x3b9a274f, Data2: 0x891d, Data3: 0x5208, Data4: ( 0x96,0xbb,0xe3,0xf4,0x0c,0x80,0x9e,0x9b ))// 3b9a274f-891d-5208-96bb-e3f40c809e9b
}

internal var __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<String, Windows.UI.Composition.ICompositionAnimationBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.value
        let resultWrapper = __ABI_Windows_UI_Composition.ICompositionAnimationBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge>
internal class IKeyValuePairString_ICompositionAnimationBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

    internal func get_ValueImpl() throws -> UWP.AnyICompositionAnimationBase? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_UI_Composition.ICompositionAnimationBaseWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase
    internal typealias SwiftABI = IKeyValuePairString_ICompositionAnimationBase
    internal typealias SwiftProjection = WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = String
    typealias V = UWP.AnyICompositionAnimationBase?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : UWP.AnyICompositionAnimationBase? {
        get { try! _default.get_ValueImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapChangedEventArgs_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x60141efb, Data2: 0xf2f9, Data3: 0x5377, Data4: ( 0x96,0xfd,0xf8,0xc6,0x0d,0x95,0x58,0xb5 ))// 60141efb-f2f9-5377-96fd-f8c60d9558b5
}

internal var __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGVTable: __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapChangedEventArgs`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_CollectionChange: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.collectionChange
        $1?.initialize(to: result)
        return S_OK
    },

    get_Key: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.key
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    }
)
typealias __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapChangedEventArgs_1_HSTRINGBridge>
internal class IMapChangedEventArgsString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapChangedEventArgs_1_HSTRING }

    internal func get_CollectionChangeImpl() throws -> WindowsFoundation.CollectionChange {
        var result: __x_ABI_CWindows_CFoundation_CCollections_CCollectionChange = .init(0)
        _ = try perform(as: __x_ABI_C__FIMapChangedEventArgs_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_CollectionChange(pThis, &result))
        }
        return result
    }

    internal func get_KeyImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIMapChangedEventArgs_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapChangedEventArgs_1_HSTRING
    internal typealias SwiftABI = IMapChangedEventArgsString
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapChangedEventArgs<String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapChangedEventArgs_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGImpl : IMapChangedEventArgs, AbiInterfaceImpl {
    typealias K = String
    typealias Bridge = __x_ABI_C__FIMapChangedEventArgs_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapchangedeventargs-1.collectionchange)
    fileprivate var collectionChange : WindowsFoundation.CollectionChange {
        get { try! _default.get_CollectionChangeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapchangedeventargs-1.key)
    fileprivate var key : String {
        get { try! _default.get_KeyImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_GUID_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xe4d2c732, Data2: 0xbbc1, Data3: 0x5ef4, Data4: ( 0x86,0x9f,0x50,0x07,0xce,0xb5,0x5f,0x6e ))// e4d2c732-bbc1-5ef4-869f-5007ceb55f6e
}

internal var __x_ABI_C__FIMapView_2_GUID_IInspectableVTable: __x_ABI_C__FIMapView_2_GUID_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<Foundation.UUID, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>?
        var second: WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_GUID_IInspectableWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_GUID_IInspectableWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_GUID_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_GUID_IInspectableBridge>
internal class IMapViewUUID_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_GUID_IInspectable }

    internal func LookupImpl(_ key: Foundation.UUID) throws -> Any? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMapView_2_GUID_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, .init(from: key), &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: Foundation.UUID) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, .init(from: key), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>?, _ second: inout WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_GUID_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_GUID_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_GUID_IInspectable
    internal typealias SwiftABI = IMapViewUUID_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_GUID_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_GUID_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_GUID_IInspectableImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?
    typealias K = Foundation.UUID
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIMapView_2_GUID_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: Foundation.UUID) -> Any? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: Foundation.UUID) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>?, _ second: inout WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairUUID_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration: WindowsFoundation.IID {
    .init(Data1: 0x2c08602f, Data2: 0x40b1, Data3: 0x5e97, Data4: ( 0xae,0x21,0x5c,0x04,0xd7,0xfb,0x82,0x9c ))// 2c08602f-40b1-5e97-ae21-5c04d7fb829c
}

internal var __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVTable: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<Foundation.UUID, Windows.ApplicationModel.Background.BackgroundTaskRegistration>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.BackgroundTaskRegistration?>?
        var second: WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.BackgroundTaskRegistration?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge>
internal class IMapViewUUID_BackgroundTaskRegistration: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration }

    internal func LookupImpl(_ key: Foundation.UUID) throws -> UWP.BackgroundTaskRegistration? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, .init(from: key), &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: Foundation.UUID) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, .init(from: key), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.BackgroundTaskRegistration?>?, _ second: inout WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.BackgroundTaskRegistration?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistration
    internal typealias SwiftABI = IMapViewUUID_BackgroundTaskRegistration
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.BackgroundTaskRegistration?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>?
    typealias K = Foundation.UUID
    typealias V = UWP.BackgroundTaskRegistration?
    typealias Bridge = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: Foundation.UUID) -> UWP.BackgroundTaskRegistration? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: Foundation.UUID) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.BackgroundTaskRegistration?>?, _ second: inout WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.BackgroundTaskRegistration?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairUUID_BackgroundTaskRegistration! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.BackgroundTaskRegistration?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration: WindowsFoundation.IID {
    .init(Data1: 0x78c880f6, Data2: 0xa7dc, Data3: 0x5172, Data4: ( 0x89,0xda,0x77,0x49,0xfc,0x82,0xaa,0x82 ))// 78c880f6-a7dc-5172-89da-7749fc82aa82
}

internal var __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVTable: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<Foundation.UUID, Windows.ApplicationModel.Background.IBackgroundTaskRegistration>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = __ABI_Windows_ApplicationModel_Background.IBackgroundTaskRegistrationWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?
        var second: WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge>
internal class IMapViewUUID_IBackgroundTaskRegistration: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration }

    internal func LookupImpl(_ key: Foundation.UUID) throws -> UWP.AnyIBackgroundTaskRegistration? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, .init(from: key), &resultAbi))
            }
        }
        return __ABI_Windows_ApplicationModel_Background.IBackgroundTaskRegistrationWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: Foundation.UUID) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, .init(from: key), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?, _ second: inout WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistration
    internal typealias SwiftABI = IMapViewUUID_IBackgroundTaskRegistration
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?
    typealias K = Foundation.UUID
    typealias V = UWP.AnyIBackgroundTaskRegistration?
    typealias Bridge = __x_ABI_C__FIMapView_2_GUID___x_ABI_CWindows__CApplicationModel__CBackground__CIBackgroundTaskRegistrationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: Foundation.UUID) -> UWP.AnyIBackgroundTaskRegistration? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: Foundation.UUID) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?, _ second: inout WindowsFoundation.AnyIMapView<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairUUID_IBackgroundTaskRegistration! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, UWP.AnyIBackgroundTaskRegistration?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xbb78502a, Data2: 0xf79d, Data3: 0x54fa, Data4: ( 0x92,0xc9,0x90,0xc5,0x03,0x9f,0xdf,0x7e ))// bb78502a-f79d-54fa-92c9-90c5039fdf7e
}

internal var __x_ABI_C__FIMapView_2_HSTRING_IInspectableVTable: __x_ABI_C__FIMapView_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<String, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<String, Any?>?
        var second: WindowsFoundation.AnyIMapView<String, Any?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_HSTRING_IInspectableBridge>
internal class IMapViewString_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_HSTRING_IInspectable }

    internal func LookupImpl(_ key: String) throws -> Any? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<String, Any?>?, _ second: inout WindowsFoundation.AnyIMapView<String, Any?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_HSTRING_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_HSTRING_IInspectable
    internal typealias SwiftABI = IMapViewString_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<String, Any?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_HSTRING_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_HSTRING_IInspectableImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, Any?>?
    typealias K = String
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIMapView_2_HSTRING_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: String) -> Any? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<String, Any?>?, _ second: inout WindowsFoundation.AnyIMapView<String, Any?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_HSTRING_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xac7f26f2, Data2: 0xfeb7, Data3: 0x5b2a, Data4: ( 0x8a,0xc4,0x34,0x5b,0xc6,0x2c,0xae,0xde ))// ac7f26f2-feb7-5b2a-8ac4-345bc62caede
}

internal var __x_ABI_C__FIMapView_2_HSTRING_HSTRINGVTable: __x_ABI_C__FIMapView_2_HSTRING_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<String, String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        $2?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<String, String>?
        var second: WindowsFoundation.AnyIMapView<String, String>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_HSTRING_HSTRINGBridge>
internal class IMapViewString_String: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_HSTRING_HSTRING }

    internal func LookupImpl(_ key: String) throws -> String {
        var result: HSTRING?
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<String, String>?, _ second: inout WindowsFoundation.AnyIMapView<String, String>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_HSTRING_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_HSTRING_HSTRING
    internal typealias SwiftABI = IMapViewString_String
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<String, String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_HSTRING_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_HSTRING_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_HSTRING_HSTRINGImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, String>?
    typealias K = String
    typealias V = String
    typealias Bridge = __x_ABI_C__FIMapView_2_HSTRING_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: String) -> String {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<String, String>?, _ second: inout WindowsFoundation.AnyIMapView<String, String>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_String! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, String>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup: WindowsFoundation.IID {
    .init(Data1: 0xf6a9dc12, Data2: 0x01f7, Data3: 0x54f0, Data4: ( 0xa2,0x57,0xc4,0x04,0x81,0x5b,0x9c,0x1c ))// f6a9dc12-01f7-54f0-a257-c404815b9c1c
}

internal var __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVTable: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<String, Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<String, UWP.BackgroundTaskRegistrationGroup?>?
        var second: WindowsFoundation.AnyIMapView<String, UWP.BackgroundTaskRegistrationGroup?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge>
internal class IMapViewString_BackgroundTaskRegistrationGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup }

    internal func LookupImpl(_ key: String) throws -> UWP.BackgroundTaskRegistrationGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<String, UWP.BackgroundTaskRegistrationGroup?>?, _ second: inout WindowsFoundation.AnyIMapView<String, UWP.BackgroundTaskRegistrationGroup?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup
    internal typealias SwiftABI = IMapViewString_BackgroundTaskRegistrationGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<String, UWP.BackgroundTaskRegistrationGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>?
    typealias K = String
    typealias V = UWP.BackgroundTaskRegistrationGroup?
    typealias Bridge = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: String) -> UWP.BackgroundTaskRegistrationGroup? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<String, UWP.BackgroundTaskRegistrationGroup?>?, _ second: inout WindowsFoundation.AnyIMapView<String, UWP.BackgroundTaskRegistrationGroup?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_BackgroundTaskRegistrationGroup! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BackgroundTaskRegistrationGroup?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment: WindowsFoundation.IID {
    .init(Data1: 0x91d443d6, Data2: 0x3777, Data3: 0x5102, Data4: ( 0xb0,0xbc,0x3d,0x41,0x83,0xa2,0x6f,0xf9 ))// 91d443d6-3777-5102-b0bc-3d4183a26ff9
}

internal var __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<String, Windows.Foundation.Collections.IVectorView`1<Windows.Data.Text.TextSegment>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?
        var second: WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge>
internal class IMapViewString_IVectorViewTextSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment }

    internal func LookupImpl(_ key: String) throws -> WindowsFoundation.AnyIVectorView<UWP.TextSegment>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?, _ second: inout WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment
    internal typealias SwiftABI = IMapViewString_IVectorViewTextSegment
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?
    typealias K = String
    typealias V = WindowsFoundation.AnyIVectorView<UWP.TextSegment>?
    typealias Bridge = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: String) -> WindowsFoundation.AnyIVectorView<UWP.TextSegment>? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?, _ second: inout WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_IVectorViewTextSegment! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x153f9c9c, Data2: 0xd22a, Data3: 0x5c9e, Data4: ( 0x9c,0x74,0x8b,0x85,0xc9,0x08,0xb0,0x00 ))// 153f9c9c-d22a-5c9e-9c74-8b85c908b000
}

internal var __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<String, Windows.Foundation.Collections.IVector`1<String>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>?
        var second: WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge>
internal class IMapViewString_IVectorString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRING }

    internal func LookupImpl(_ key: String) throws -> WindowsFoundation.AnyIVector<String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>?, _ second: inout WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRING
    internal typealias SwiftABI = IMapViewString_IVectorString
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?
    typealias K = String
    typealias V = WindowsFoundation.AnyIVector<String>?
    typealias Bridge = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: String) -> WindowsFoundation.AnyIVector<String>? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>?, _ second: inout WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_IVectorString! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue: WindowsFoundation.IID {
    .init(Data1: 0x9cda5a9a, Data2: 0x8924, Data3: 0x5b3b, Data4: ( 0x8b,0x19,0x89,0x4d,0x8d,0xa9,0x9d,0xde ))// 9cda5a9a-8924-5b3b-8b19-894d8da99dde
}

internal var __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<String, Windows.Graphics.Imaging.BitmapTypedValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>?
        var second: WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge>
internal class IMapViewString_BitmapTypedValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue }

    internal func LookupImpl(_ key: String) throws -> UWP.BitmapTypedValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>?, _ second: inout WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue
    internal typealias SwiftABI = IMapViewString_BitmapTypedValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?
    typealias K = String
    typealias V = UWP.BitmapTypedValue?
    typealias Bridge = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: String) -> UWP.BitmapTypedValue? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>?, _ second: inout WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_BitmapTypedValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0x0a4ce7a5, Data2: 0xdfe0, Data3: 0x5796, Data4: ( 0xa4,0x38,0xef,0xfd,0xfa,0xa3,0x1f,0x1b ))// 0a4ce7a5-dfe0-5796-a438-effdfaa31f1b
}

internal var __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<String, Windows.Storage.Streams.RandomAccessStreamReference>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?
        var second: WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class IMapViewString_RandomAccessStreamReference: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func LookupImpl(_ key: String) throws -> UWP.RandomAccessStreamReference? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?, _ second: inout WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = IMapViewString_RandomAccessStreamReference
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?
    typealias K = String
    typealias V = UWP.RandomAccessStreamReference?
    typealias Bridge = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: String) -> UWP.RandomAccessStreamReference? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?, _ second: inout WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_RandomAccessStreamReference! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase: WindowsFoundation.IID {
    .init(Data1: 0xb65e6ece, Data2: 0xd9af, Data3: 0x5d4a, Data4: ( 0xab,0xaa,0xc0,0x8e,0x34,0xa5,0xf8,0x15 ))// b65e6ece-d9af-5d4a-abaa-c08e34a5f815
}

internal var __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMapView`2<String, Windows.UI.Composition.ICompositionAnimationBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = __ABI_Windows_UI_Composition.ICompositionAnimationBaseWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard let __unwrapped__instance = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>?
        var second: WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>?
        __unwrapped__instance.split(&first, &second)
        let firstWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper(first)
        firstWrapper?.copyTo($1)
        let secondWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge>
internal class IMapViewString_ICompositionAnimationBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase }

    internal func LookupImpl(_ key: String) throws -> UWP.AnyICompositionAnimationBase? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return __ABI_Windows_UI_Composition.ICompositionAnimationBaseWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>?, _ second: inout WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>?) throws {
        let (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.unwrapFrom(abi: _first)
        second = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase
    internal typealias SwiftABI = IMapViewString_ICompositionAnimationBase
    internal typealias SwiftProjection = WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?
    typealias K = String
    typealias V = UWP.AnyICompositionAnimationBase?
    typealias Bridge = __x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate func lookup(_ key: String) -> UWP.AnyICompositionAnimationBase? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate func split(_ first: inout WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>?, _ second: inout WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_ICompositionAnimationBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMap_2_GUID_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x5ee3189c, Data2: 0x7dbf, Data3: 0x5998, Data4: ( 0xad,0x07,0x54,0x14,0xfb,0x82,0x56,0x7c ))// 5ee3189c-7dbf-5998-ad07-5414fb82567c
}

internal var __x_ABI_C__FIMap_2_GUID_IInspectableVTable: __x_ABI_C__FIMap_2_GUID_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMap_2_GUID_IInspectableWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_GUID_IInspectableWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMap`2<Foundation.UUID, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIMapView_2_GUID_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        let value: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        let result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: Foundation.UUID = .init(from: $1)
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_GUID_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_GUID_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMap_2_GUID_IInspectableBridge>
internal class IMapUUID_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_GUID_IInspectable }

    internal func LookupImpl(_ key: Foundation.UUID) throws -> Any? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_GUID_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, .init(from: key), &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: Foundation.UUID) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, .init(from: key), &result))
        }
        return .init(from: result)
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_GUID_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_GUID_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal func InsertImpl(_ key: Foundation.UUID, _ value: Any?) throws -> Bool {
        var result: boolean = 0
        let valueWrapper = __ABI_.AnyWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMap_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, .init(from: key), _value, &result))
        }
        return .init(from: result)
    }

    internal func RemoveImpl(_ key: Foundation.UUID) throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, .init(from: key)))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_GUID_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_GUID_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_GUID_IInspectable
    internal typealias SwiftABI = IMapUUID_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIMap<Foundation.UUID, Any?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMap_2_GUID_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_GUID_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_GUID_IInspectableImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?
    typealias K = Foundation.UUID
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIMap_2_GUID_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate func lookup(_ key: Foundation.UUID) -> Any? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate func hasKey(_ key: Foundation.UUID) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate func insert(_ key: Foundation.UUID, _ value: Any?) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate func remove(_ key: Foundation.UUID) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairUUID_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMap_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x1b0d3570, Data2: 0x0877, Data3: 0x5ec2, Data4: ( 0x8a,0x2c,0x3b,0x95,0x39,0x50,0x6a,0xca ))// 1b0d3570-0877-5ec2-8a2c-3b9539506aca
}

internal var __x_ABI_C__FIMap_2_HSTRING_IInspectableVTable: __x_ABI_C__FIMap_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMap`2<String, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let value: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        let result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMap_2_HSTRING_IInspectableBridge>
internal class IMapString_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_HSTRING_IInspectable }

    internal func LookupImpl(_ key: String) throws -> Any? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIMapView<String, Any?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal func InsertImpl(_ key: String, _ value: Any?) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        let valueWrapper = __ABI_.AnyWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, _key.get(), _value, &result))
        }
        return .init(from: result)
    }

    internal func RemoveImpl(_ key: String) throws {
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, _key.get()))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_HSTRING_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_HSTRING_IInspectable
    internal typealias SwiftABI = IMapString_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIMap<String, Any?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMap_2_HSTRING_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_HSTRING_IInspectableImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, Any?>?
    typealias K = String
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIMap_2_HSTRING_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate func lookup(_ key: String) -> Any? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<String, Any?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate func insert(_ key: String, _ value: Any?) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate func remove(_ key: String) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMap_2_HSTRING_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xf6d1f700, Data2: 0x49c2, Data3: 0x52ae, Data4: ( 0x81,0x54,0x82,0x6f,0x99,0x08,0x77,0x3c ))// f6d1f700-49c2-52ae-8154-826f9908773c
}

internal var __x_ABI_C__FIMap_2_HSTRING_HSTRINGVTable: __x_ABI_C__FIMap_2_HSTRING_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_HSTRINGWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMap`2<String, String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        $2?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let value: String = .init(from: $2)
        let result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_HSTRING_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMap_2_HSTRING_HSTRINGBridge>
internal class IMapString_String: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_HSTRING_HSTRING }

    internal func LookupImpl(_ key: String) throws -> String {
        var result: HSTRING?
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIMapView<String, String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_HSTRING_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func InsertImpl(_ key: String, _ value: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        let _value = try! HString(value)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, _key.get(), _value.get(), &result))
        }
        return .init(from: result)
    }

    internal func RemoveImpl(_ key: String) throws {
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, _key.get()))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_HSTRING_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_HSTRING_HSTRING
    internal typealias SwiftABI = IMapString_String
    internal typealias SwiftProjection = WindowsFoundation.AnyIMap<String, String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMap_2_HSTRING_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_HSTRING_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_HSTRING_HSTRINGImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, String>?
    typealias K = String
    typealias V = String
    typealias Bridge = __x_ABI_C__FIMap_2_HSTRING_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate func lookup(_ key: String) -> String {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<String, String>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate func insert(_ key: String, _ value: String) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate func remove(_ key: String) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_String! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, String>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment: WindowsFoundation.IID {
    .init(Data1: 0xa31b6540, Data2: 0xb2b1, Data3: 0x536d, Data4: ( 0x81,0x8f,0x8a,0xde,0x70,0x51,0xc3,0xb3 ))// a31b6540-b2b1-536d-818f-8ade7051c3b3
}

internal var __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMap`2<String, Windows.Foundation.Collections.IVectorView`1<Windows.Data.Text.TextSegment>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let value: WindowsFoundation.AnyIVectorView<UWP.TextSegment>? = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: ComPtr($2))
        let result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge>
internal class IMapString_IVectorViewTextSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment }

    internal func LookupImpl(_ key: String) throws -> WindowsFoundation.AnyIVectorView<UWP.TextSegment>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.unwrapFrom(abi: result)
    }

    internal func InsertImpl(_ key: String, _ value: WindowsFoundation.AnyIVectorView<UWP.TextSegment>?) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        let valueWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, _key.get(), _value, &result))
        }
        return .init(from: result)
    }

    internal func RemoveImpl(_ key: String) throws {
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, _key.get()))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment
    internal typealias SwiftABI = IMapString_IVectorViewTextSegment
    internal typealias SwiftProjection = WindowsFoundation.AnyIMap<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?
    typealias K = String
    typealias V = WindowsFoundation.AnyIVectorView<UWP.TextSegment>?
    typealias Bridge = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate func lookup(_ key: String) -> WindowsFoundation.AnyIVectorView<UWP.TextSegment>? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate func insert(_ key: String, _ value: WindowsFoundation.AnyIVectorView<UWP.TextSegment>?) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate func remove(_ key: String) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_IVectorViewTextSegment! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVectorView<UWP.TextSegment>?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xe475ca9d, Data2: 0x6afb, Data3: 0x5992, Data4: ( 0x99,0x3e,0x53,0xe6,0xef,0x7a,0x9e,0xcd ))// e475ca9d-6afb-5992-993e-53e6ef7a9ecd
}

internal var __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMap`2<String, Windows.Foundation.Collections.IVector`1<String>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let value: WindowsFoundation.AnyIVector<String>? = UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($2))
        let result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge>
internal class IMapString_IVectorString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING }

    internal func LookupImpl(_ key: String) throws -> WindowsFoundation.AnyIVector<String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func InsertImpl(_ key: String, _ value: WindowsFoundation.AnyIVector<String>?) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        let valueWrapper = UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, _key.get(), _value, &result))
        }
        return .init(from: result)
    }

    internal func RemoveImpl(_ key: String) throws {
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, _key.get()))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING
    internal typealias SwiftABI = IMapString_IVectorString
    internal typealias SwiftProjection = WindowsFoundation.AnyIMap<String, WindowsFoundation.AnyIVector<String>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?
    typealias K = String
    typealias V = WindowsFoundation.AnyIVector<String>?
    typealias Bridge = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate func lookup(_ key: String) -> WindowsFoundation.AnyIVector<String>? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate func insert(_ key: String, _ value: WindowsFoundation.AnyIVector<String>?) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate func remove(_ key: String) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_IVectorString! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue: WindowsFoundation.IID {
    .init(Data1: 0x2c70ef8d, Data2: 0x5d4c, Data3: 0x5185, Data4: ( 0x8d,0xb7,0xfe,0xd8,0x77,0x28,0x16,0x5d ))// 2c70ef8d-5d4c-5185-8db7-fed87728165d
}

internal var __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMap`2<String, Windows.Graphics.Imaging.BitmapTypedValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let value: UWP.BitmapTypedValue? = .from(abi: ComPtr($2))
        let result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge>
internal class IMapString_BitmapTypedValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue }

    internal func LookupImpl(_ key: String) throws -> UWP.BitmapTypedValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueWrapper.unwrapFrom(abi: result)
    }

    internal func InsertImpl(_ key: String, _ value: UWP.BitmapTypedValue?) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, _key.get(), RawPointer(value), &result))
        }
        return .init(from: result)
    }

    internal func RemoveImpl(_ key: String) throws {
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, _key.get()))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValue
    internal typealias SwiftABI = IMapString_BitmapTypedValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIMap<String, UWP.BitmapTypedValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?
    typealias K = String
    typealias V = UWP.BitmapTypedValue?
    typealias Bridge = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CGraphics__CImaging__CBitmapTypedValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate func lookup(_ key: String) -> UWP.BitmapTypedValue? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<String, UWP.BitmapTypedValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate func insert(_ key: String, _ value: UWP.BitmapTypedValue?) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate func remove(_ key: String) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_BitmapTypedValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.BitmapTypedValue?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0xe5d2ccfc, Data2: 0x825a, Data3: 0x5a8e, Data4: ( 0x82,0xaa,0x09,0x5e,0xd5,0xdb,0xd5,0xd1 ))// e5d2ccfc-825a-5a8e-82aa-095ed5dbd5d1
}

internal var __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMap`2<String, Windows.Storage.Streams.RandomAccessStreamReference>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let value: UWP.RandomAccessStreamReference? = .from(abi: ComPtr($2))
        let result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class IMapString_RandomAccessStreamReference: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func LookupImpl(_ key: String) throws -> UWP.RandomAccessStreamReference? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: result)
    }

    internal func InsertImpl(_ key: String, _ value: UWP.RandomAccessStreamReference?) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, _key.get(), RawPointer(value), &result))
        }
        return .init(from: result)
    }

    internal func RemoveImpl(_ key: String) throws {
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, _key.get()))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = IMapString_RandomAccessStreamReference
    internal typealias SwiftProjection = WindowsFoundation.AnyIMap<String, UWP.RandomAccessStreamReference?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?
    typealias K = String
    typealias V = UWP.RandomAccessStreamReference?
    typealias Bridge = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate func lookup(_ key: String) -> UWP.RandomAccessStreamReference? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate func insert(_ key: String, _ value: UWP.RandomAccessStreamReference?) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate func remove(_ key: String) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_RandomAccessStreamReference! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.RandomAccessStreamReference?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase: WindowsFoundation.IID {
    .init(Data1: 0x4ba9aa1d, Data2: 0x57ac, Data3: 0x54de, Data4: ( 0xa8,0x07,0xb5,0x2e,0x68,0x9b,0xfc,0x04 ))// 4ba9aa1d-57ac-54de-a807-b52e689bfc04
}

internal var __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IMap`2<String, Windows.UI.Composition.ICompositionAnimationBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.lookup(key)
        let resultWrapper = __ABI_Windows_UI_Composition.ICompositionAnimationBaseWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        let value: UWP.AnyICompositionAnimationBase? = __ABI_Windows_UI_Composition.ICompositionAnimationBaseWrapper.unwrapFrom(abi: ComPtr($2))
        let result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let key: String = .init(from: $1)
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge>
internal class IMapString_ICompositionAnimationBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase }

    internal func LookupImpl(_ key: String) throws -> UWP.AnyICompositionAnimationBase? {
        let (result) = try ComPtrs.initialize { resultAbi in
            let _key = try! HString(key)
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key.get(), &resultAbi))
            }
        }
        return __ABI_Windows_UI_Composition.ICompositionAnimationBaseWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func HasKeyImpl(_ key: String) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key.get(), &result))
        }
        return .init(from: result)
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseWrapper.unwrapFrom(abi: result)
    }

    internal func InsertImpl(_ key: String, _ value: UWP.AnyICompositionAnimationBase?) throws -> Bool {
        var result: boolean = 0
        let _key = try! HString(key)
        let valueWrapper = __ABI_Windows_UI_Composition.ICompositionAnimationBaseWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, _key.get(), _value, &result))
        }
        return .init(from: result)
    }

    internal func RemoveImpl(_ key: String) throws {
        let _key = try! HString(key)
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, _key.get()))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBase
    internal typealias SwiftABI = IMapString_ICompositionAnimationBase
    internal typealias SwiftProjection = WindowsFoundation.AnyIMap<String, UWP.AnyICompositionAnimationBase?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?
    typealias K = String
    typealias V = UWP.AnyICompositionAnimationBase?
    typealias Bridge = __x_ABI_C__FIMap_2_HSTRING___x_ABI_CWindows__CUI__CComposition__CICompositionAnimationBaseBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate func lookup(_ key: String) -> UWP.AnyICompositionAnimationBase? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<String, UWP.AnyICompositionAnimationBase?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate func insert(_ key: String, _ value: UWP.AnyICompositionAnimationBase?) -> Bool {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate func remove(_ key: String) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_ICompositionAnimationBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, UWP.AnyICompositionAnimationBase?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIObservableMap_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x236aac9d, Data2: 0xfb12, Data3: 0x5c4d, Data4: ( 0xa4,0x1c,0x9e,0x44,0x5f,0xb4,0xd7,0xec ))// 236aac9d-fb12-5c4d-a41c-9e445fb4d7ec
}

internal var __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableVTable: __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 5).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.IID
        iids[4] = UWP.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_HSTRING_IInspectableWrapper.IID
        $1!.pointee = 5
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IObservableMap`2<String, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    add_MapChanged: {
        guard let __unwrapped__instance = __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let vhnd = UWP.__x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        let result = __unwrapped__instance.mapChanged.addHandler(vhnd)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    remove_MapChanged: {
        guard let __unwrapped__instance = __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let token: EventRegistrationToken = $1
        __unwrapped__instance.mapChanged.removeHandler(token)
        return S_OK
    }
)
typealias __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIObservableMap_2_HSTRING_IInspectableBridge>
internal class IObservableMapString_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIObservableMap_2_HSTRING_IInspectable }

    internal func add_MapChangedImpl(_ vhnd: MapChangedEventHandler<String, Any?>?) throws -> EventRegistrationToken {
        var result: EventRegistrationToken = .init()
        let vhndWrapper = UWP.__x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableWrapper(vhnd)
        let _vhnd = try! vhndWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIObservableMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.add_MapChanged(pThis, _vhnd, &result))
        }
        return result
    }

    internal func remove_MapChangedImpl(_ token: EventRegistrationToken) throws {
        _ = try perform(as: __x_ABI_C__FIObservableMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.remove_MapChanged(pThis, token))
        }
    }

}

internal enum __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIObservableMap_2_HSTRING_IInspectable
    internal typealias SwiftABI = IObservableMapString_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIObservableMap<String, Any?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIObservableMap_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableImpl : IObservableMap, AbiInterfaceImpl {
    typealias K = String
    typealias V = Any?
    typealias T = WindowsFoundation.AnyIKeyValuePair<String, Any?>?
    typealias Bridge = __x_ABI_C__FIObservableMap_2_HSTRING_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.mapchanged)
    fileprivate lazy var mapChanged : Event<MapChangedEventHandler<String, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_MapChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_MapChangedImpl($0)
       }
      )
    }()

    private lazy var _IMap: IMapString_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.lookup)
    fileprivate func lookup(_ key: String) -> Any? {
        try! _IMap.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.haskey)
    fileprivate func hasKey(_ key: String) -> Bool {
        try! _IMap.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIMapView<String, Any?>? {
        try! _IMap.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.insert)
    fileprivate func insert(_ key: String, _ value: Any?) -> Bool {
        try! _IMap.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.remove)
    fileprivate func remove(_ key: String) {
        try! _IMap.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.clear)
    fileprivate func clear() {
        try! _IMap.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.size)
    fileprivate var size : UInt32 {
        get { try! _IMap.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablemap-2.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack: WindowsFoundation.IID {
    .init(Data1: 0x98ebeba8, Data2: 0x6659, Data3: 0x5af2, Data4: ( 0xbe,0x4f,0x32,0xfd,0xee,0xde,0x3b,0x77 ))// 98ebeba8-6659-5af2-be4f-32fdeede3b77
}

internal var __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 5).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        iids[4] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        $1!.pointee = 5
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IObservableVector`1<Windows.Media.Core.TimedMetadataTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    add_VectorChanged: {
        guard let __unwrapped__instance = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let vhnd = UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        let result = __unwrapped__instance.vectorChanged.addHandler(vhnd)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    remove_VectorChanged: {
        guard let __unwrapped__instance = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let token: EventRegistrationToken = $1
        __unwrapped__instance.vectorChanged.removeHandler(token)
        return S_OK
    }
)
typealias __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge>
internal class IObservableVectorTimedMetadataTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack }

    internal func add_VectorChangedImpl(_ vhnd: VectorChangedEventHandler<UWP.TimedMetadataTrack?>?) throws -> EventRegistrationToken {
        var result: EventRegistrationToken = .init()
        let vhndWrapper = UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper(vhnd)
        let _vhnd = try! vhndWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.add_VectorChanged(pThis, _vhnd, &result))
        }
        return result
    }

    internal func remove_VectorChangedImpl(_ token: EventRegistrationToken) throws {
        _ = try perform(as: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.remove_VectorChanged(pThis, token))
        }
    }

}

internal enum __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack
    internal typealias SwiftABI = IObservableVectorTimedMetadataTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIObservableVector<UWP.TimedMetadataTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl : IObservableVector, AbiInterfaceImpl {
    typealias T = UWP.TimedMetadataTrack?
    typealias Bridge = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.vectorchanged)
    fileprivate lazy var vectorChanged : Event<VectorChangedEventHandler<TimedMetadataTrack?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_VectorChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_VectorChangedImpl($0)
       }
      )
    }()

    private lazy var _IVector: IVectorTimedMetadataTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.TimedMetadataTrack? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.TimedMetadataTrack?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.indexof)
    fileprivate func indexOf(_ value: UWP.TimedMetadataTrack?, _ index: inout UInt32) -> Bool {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.TimedMetadataTrack?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.TimedMetadataTrack?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.append)
    fileprivate func append(_ value: UWP.TimedMetadataTrack?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.clear)
    fileprivate func clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.size)
    fileprivate var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimedMetadataTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TimedMetadataTrack?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource: WindowsFoundation.IID {
    .init(Data1: 0x95e6c852, Data2: 0x6e9c, Data3: 0x50a9, Data4: ( 0x89,0x35,0x05,0x43,0x20,0x24,0x29,0x45 ))// 95e6c852-6e9c-50a9-8935-054320242945
}

internal var __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 5).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        iids[4] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        $1!.pointee = 5
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IObservableVector`1<Windows.Media.Core.TimedTextSource>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    add_VectorChanged: {
        guard let __unwrapped__instance = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let vhnd = UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        let result = __unwrapped__instance.vectorChanged.addHandler(vhnd)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    remove_VectorChanged: {
        guard let __unwrapped__instance = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let token: EventRegistrationToken = $1
        __unwrapped__instance.vectorChanged.removeHandler(token)
        return S_OK
    }
)
typealias __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge>
internal class IObservableVectorTimedTextSource: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource }

    internal func add_VectorChangedImpl(_ vhnd: VectorChangedEventHandler<UWP.TimedTextSource?>?) throws -> EventRegistrationToken {
        var result: EventRegistrationToken = .init()
        let vhndWrapper = UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper(vhnd)
        let _vhnd = try! vhndWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.add_VectorChanged(pThis, _vhnd, &result))
        }
        return result
    }

    internal func remove_VectorChangedImpl(_ token: EventRegistrationToken) throws {
        _ = try perform(as: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.remove_VectorChanged(pThis, token))
        }
    }

}

internal enum __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource
    internal typealias SwiftABI = IObservableVectorTimedTextSource
    internal typealias SwiftProjection = WindowsFoundation.AnyIObservableVector<UWP.TimedTextSource?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl : IObservableVector, AbiInterfaceImpl {
    typealias T = UWP.TimedTextSource?
    typealias Bridge = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.vectorchanged)
    fileprivate lazy var vectorChanged : Event<VectorChangedEventHandler<TimedTextSource?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_VectorChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_VectorChangedImpl($0)
       }
      )
    }()

    private lazy var _IVector: IVectorTimedTextSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.TimedTextSource? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.TimedTextSource?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.indexof)
    fileprivate func indexOf(_ value: UWP.TimedTextSource?, _ index: inout UInt32) -> Bool {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.TimedTextSource?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.TimedTextSource?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.append)
    fileprivate func append(_ value: UWP.TimedTextSource?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.clear)
    fileprivate func clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.size)
    fileprivate var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimedTextSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TimedTextSource?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem: WindowsFoundation.IID {
    .init(Data1: 0xfabf4843, Data2: 0x39eb, Data3: 0x5c3d, Data4: ( 0xa1,0x2b,0xfc,0xa1,0x89,0xb4,0x6e,0x8e ))// fabf4843-39eb-5c3d-a12b-fca189b46e8e
}

internal var __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 5).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        iids[4] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        $1!.pointee = 5
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IObservableVector`1<Windows.Media.Playback.MediaPlaybackItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    add_VectorChanged: {
        guard let __unwrapped__instance = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let vhnd = UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        let result = __unwrapped__instance.vectorChanged.addHandler(vhnd)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    remove_VectorChanged: {
        guard let __unwrapped__instance = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let token: EventRegistrationToken = $1
        __unwrapped__instance.vectorChanged.removeHandler(token)
        return S_OK
    }
)
typealias __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge>
internal class IObservableVectorMediaPlaybackItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem }

    internal func add_VectorChangedImpl(_ vhnd: VectorChangedEventHandler<UWP.MediaPlaybackItem?>?) throws -> EventRegistrationToken {
        var result: EventRegistrationToken = .init()
        let vhndWrapper = UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper(vhnd)
        let _vhnd = try! vhndWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.add_VectorChanged(pThis, _vhnd, &result))
        }
        return result
    }

    internal func remove_VectorChangedImpl(_ token: EventRegistrationToken) throws {
        _ = try perform(as: __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.remove_VectorChanged(pThis, token))
        }
    }

}

internal enum __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem
    internal typealias SwiftABI = IObservableVectorMediaPlaybackItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIObservableVector<UWP.MediaPlaybackItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl : IObservableVector, AbiInterfaceImpl {
    typealias T = UWP.MediaPlaybackItem?
    typealias Bridge = __x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.vectorchanged)
    fileprivate lazy var vectorChanged : Event<VectorChangedEventHandler<MediaPlaybackItem?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_VectorChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_VectorChangedImpl($0)
       }
      )
    }()

    private lazy var _IVector: IVectorMediaPlaybackItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaPlaybackItem? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.MediaPlaybackItem?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaPlaybackItem?, _ index: inout UInt32) -> Bool {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.MediaPlaybackItem?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.MediaPlaybackItem?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.append)
    fileprivate func append(_ value: UWP.MediaPlaybackItem?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.clear)
    fileprivate func clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.size)
    fileprivate var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaPlaybackItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaPlaybackItem?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1_float: WindowsFoundation.IID {
    .init(Data1: 0x7bca64fd, Data2: 0x150c, Data3: 0x5d50, Data4: ( 0xb5,0x6b,0x9f,0x4f,0x47,0x4c,0x59,0x30 ))// 7bca64fd-150c-5d50-b56b-9f4f474c5930
}

internal var __x_ABI_C__FIVectorView_1_floatVTable: __x_ABI_C__FIVectorView_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1_floatWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1_floatWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1_floatWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: Float = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1_floatWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1_floatBridge>
internal class IVectorViewFloat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1_float }

    internal func GetAtImpl(_ index: UInt32) throws -> Float {
        var result: FLOAT = 0.0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: Float, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1_floatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1_float
    internal typealias SwiftABI = IVectorViewFloat
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<Float>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1_floatImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1_floatImpl : IVectorView, AbiInterfaceImpl {
    typealias T = Float
    typealias Bridge = __x_ABI_C__FIVectorView_1_floatBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> Float {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: Float, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableFloat! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<Float>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1_GUID: WindowsFoundation.IID {
    .init(Data1: 0x9520e64b, Data2: 0x15b2, Data3: 0x52a6, Data4: ( 0x98,0xed,0x31,0x91,0xfa,0x6c,0xf6,0x8a ))// 9520e64b-15b2-52a6-98ed-3191fa6cf68a
}

internal var __x_ABI_C__FIVectorView_1_GUIDVTable: __x_ABI_C__FIVectorView_1_GUIDVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1_GUIDWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1_GUIDWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1_GUIDWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1_GUIDWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1_GUIDWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Foundation.UUID>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_GUIDWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_GUIDWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_GUIDWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: Foundation.UUID = .init(from: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1_GUIDWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1_GUIDBridge>
internal class IVectorViewUUID: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1_GUID }

    internal func GetAtImpl(_ index: UInt32) throws -> Foundation.UUID {
        var result: WindowsFoundation.GUID = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1_GUID.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .init(from: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_GUID.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: Foundation.UUID, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_GUID.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .init(from: value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1_GUIDBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1_GUID
    internal typealias SwiftABI = IVectorViewUUID
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<Foundation.UUID>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1_GUIDImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1_GUIDVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1_GUIDImpl : IVectorView, AbiInterfaceImpl {
    typealias T = Foundation.UUID
    typealias Bridge = __x_ABI_C__FIVectorView_1_GUIDBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> Foundation.UUID {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: Foundation.UUID, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableUUID! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<Foundation.UUID>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x2f13c006, Data2: 0xa03a, Data3: 0x5f69, Data4: ( 0xb0,0x90,0x75,0xa4,0x3e,0x33,0x42,0x3e ))// 2f13c006-a03a-5f69-b090-75a43e33423e
}

internal var __x_ABI_C__FIVectorView_1_HSTRINGVTable: __x_ABI_C__FIVectorView_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1_HSTRINGWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1_HSTRINGWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: String = .init(from: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1_HSTRINGBridge>
internal class IVectorViewString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1_HSTRING }

    internal func GetAtImpl(_ index: UInt32) throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIVectorView_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .init(from: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: String, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        let _value = try! HString(value)
        _ = try perform(as: __x_ABI_C__FIVectorView_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value.get(), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1_HSTRING
    internal typealias SwiftABI = IVectorViewString
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1_HSTRINGImpl : IVectorView, AbiInterfaceImpl {
    typealias T = String
    typealias Bridge = __x_ABI_C__FIVectorView_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> String {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: String, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableString! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<String>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1_UINT32: WindowsFoundation.IID {
    .init(Data1: 0xe5ce1a07, Data2: 0x8d33, Data3: 0x5007, Data4: ( 0xba,0x64,0x7d,0x25,0x08,0xcc,0xf8,0x5c ))// e5ce1a07-8d33-5007-ba64-7d2508ccf85c
}

internal var __x_ABI_C__FIVectorView_1_UINT32VTable: __x_ABI_C__FIVectorView_1_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1_UINT32Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1_UINT32Wrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1_UINT32Wrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<UInt32>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UInt32 = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1_UINT32Bridge>
internal class IVectorViewUInt32: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1_UINT32 }

    internal func GetAtImpl(_ index: UInt32) throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UInt32, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1_UINT32Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1_UINT32
    internal typealias SwiftABI = IVectorViewUInt32
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UInt32>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1_UINT32Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1_UINT32VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1_UINT32Impl : IVectorView, AbiInterfaceImpl {
    typealias T = UInt32
    typealias Bridge = __x_ABI_C__FIVectorView_1_UINT32Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UInt32 {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UInt32, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableUInt32! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UInt32>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo: WindowsFoundation.IID {
    .init(Data1: 0x8246ed12, Data2: 0x33e8, Data3: 0x52b3, Data4: ( 0xa5,0xc5,0x19,0x77,0x9d,0xe9,0x99,0x9e ))// 8246ed12-33e8-52b3-a5c5-19779de9999e
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.ApplicationModel.AppInfo>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AppInfo? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge>
internal class IVectorViewAppInfo: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AppInfo? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AppInfo?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo
    internal typealias SwiftABI = IVectorViewAppInfo
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AppInfo?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AppInfo?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AppInfo? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AppInfo?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAppInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AppInfo?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry: WindowsFoundation.IID {
    .init(Data1: 0x920c8b92, Data2: 0xd5ef, Data3: 0x5899, Data4: ( 0x87,0x76,0x2a,0xd9,0x7a,0xca,0x6e,0x1d ))// 920c8b92-d5ef-5899-8776-2ad97aca6e1d
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.ApplicationModel.Core.AppListEntry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AppListEntry? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge>
internal class IVectorViewAppListEntry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AppListEntry? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AppListEntry?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry
    internal typealias SwiftABI = IVectorViewAppListEntry
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AppListEntry?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AppListEntry? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AppListEntry?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAppListEntry! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AppListEntry?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem: WindowsFoundation.IID {
    .init(Data1: 0xc91de16d, Data2: 0x13ff, Data3: 0x55b0, Data4: ( 0x89,0x7d,0x18,0xa1,0x31,0xd5,0x7a,0xc9 ))// c91de16d-13ff-55b0-897d-18a131d57ac9
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.ApplicationModel.DataTransfer.ClipboardHistoryItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ClipboardHistoryItem? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge>
internal class IVectorViewClipboardHistoryItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ClipboardHistoryItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.ClipboardHistoryItem?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItem
    internal typealias SwiftABI = IVectorViewClipboardHistoryItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.ClipboardHistoryItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.ClipboardHistoryItem?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ClipboardHistoryItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.ClipboardHistoryItem?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableClipboardHistoryItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ClipboardHistoryItem?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider: WindowsFoundation.IID {
    .init(Data1: 0x946537a2, Data2: 0x932c, Data3: 0x5b77, Data4: ( 0xab,0x36,0xb7,0x06,0x50,0xf0,0xbc,0xd5 ))// 946537a2-932c-5b77-ab36-b70650f0bcd5
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.ApplicationModel.DataTransfer.ShareProvider>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ShareProvider? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge>
internal class IVectorViewShareProvider: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ShareProvider? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.ShareProvider?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider
    internal typealias SwiftABI = IVectorViewShareProvider
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.ShareProvider?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.ShareProvider?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ShareProvider? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.ShareProvider?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableShareProvider! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ShareProvider?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackage: WindowsFoundation.IID {
    .init(Data1: 0x0263c4d4, Data2: 0x195c, Data3: 0x5dc5, Data4: ( 0xa7,0xca,0x68,0x06,0xce,0xca,0x42,0x0b ))// 0263c4d4-195c-5dc5-a7ca-6806ceca420b
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.ApplicationModel.Package>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Package? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageBridge>
internal class IVectorViewPackage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackage }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.Package? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.Package?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackage
    internal typealias SwiftABI = IVectorViewPackage
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.Package?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.Package?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.Package? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.Package?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePackage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Package?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup: WindowsFoundation.IID {
    .init(Data1: 0xdeae10f1, Data2: 0x0546, Data3: 0x5e61, Data4: ( 0xbd,0x3f,0xe0,0x5d,0xa3,0x00,0x78,0xac ))// deae10f1-0546-5e61-bd3f-e05da30078ac
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.ApplicationModel.PackageContentGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PackageContentGroup? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge>
internal class IVectorViewPackageContentGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.PackageContentGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.PackageContentGroup?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup
    internal typealias SwiftABI = IVectorViewPackageContentGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.PackageContentGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.PackageContentGroup?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.PackageContentGroup? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.PackageContentGroup?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePackageContentGroup! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PackageContentGroup?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment: WindowsFoundation.IID {
    .init(Data1: 0x2f245f9d, Data2: 0xeb5f, Data3: 0x5641, Data4: ( 0x9d,0xcc,0x6a,0xb1,0x94,0x6c,0xc7,0xe6 ))// 2f245f9d-eb5f-5641-9dcc-6ab1946cc7e6
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Data.Text.TextSegment>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.TextSegment = .from(abi: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge>
internal class IVectorViewTextSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.TextSegment {
        var result: __x_ABI_CWindows_CData_CText_CTextSegment = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.TextSegment, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegment
    internal typealias SwiftABI = IVectorViewTextSegment
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.TextSegment>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.TextSegment
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CData__CText__CTextSegmentBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.TextSegment {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.TextSegment, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTextSegment! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TextSegment>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation: WindowsFoundation.IID {
    .init(Data1: 0xe170688f, Data2: 0x3495, Data3: 0x5bf6, Data4: ( 0xaa,0xb5,0x9c,0xac,0x17,0xe0,0xf1,0x0f ))// e170688f-3495-5bf6-aab5-9cac17e0f10f
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Enumeration.DeviceInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.DeviceInformation? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge>
internal class IVectorViewDeviceInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.DeviceInformation? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.DeviceInformation?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation
    internal typealias SwiftABI = IVectorViewDeviceInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.DeviceInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.DeviceInformation?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.DeviceInformation? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.DeviceInformation?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableDeviceInformation! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.DeviceInformation?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice: WindowsFoundation.IID {
    .init(Data1: 0xcf5674f1, Data2: 0x9808, Data3: 0x5a2b, Data4: ( 0x80,0xb8,0x56,0x84,0xed,0x0e,0xa8,0x16 ))// cf5674f1-9808-5a2b-80b8-5684ed0ea816
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Input.PointerDevice>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PointerDevice? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge>
internal class IVectorViewPointerDevice: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.PointerDevice? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.PointerDevice?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDevice
    internal typealias SwiftABI = IVectorViewPointerDevice
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.PointerDevice?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.PointerDevice?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.PointerDevice? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.PointerDevice?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointerDevice! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PointerDevice?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage: WindowsFoundation.IID {
    .init(Data1: 0x8e5a2c7e, Data2: 0x3830, Data3: 0x50d5, Data4: ( 0x92,0xba,0x31,0x63,0xc8,0x9c,0xbb,0xd0 ))// 8e5a2c7e-3830-50d5-92ba-3163c89cbbd0
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Input.PointerDeviceUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PointerDeviceUsage = .from(abi: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge>
internal class IVectorViewPointerDeviceUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.PointerDeviceUsage {
        var result: __x_ABI_CWindows_CDevices_CInput_CPointerDeviceUsage = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.PointerDeviceUsage, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsage
    internal typealias SwiftABI = IVectorViewPointerDeviceUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.PointerDeviceUsage>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.PointerDeviceUsage
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CInput__CPointerDeviceUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.PointerDeviceUsage {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.PointerDeviceUsage, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointerDeviceUsage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PointerDeviceUsage>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguage: WindowsFoundation.IID {
    .init(Data1: 0x144b0f3d, Data2: 0x2d59, Data3: 0x5dd2, Data4: ( 0xb0,0x12,0x90,0x8e,0xc3,0xe0,0x64,0x35 ))// 144b0f3d-2d59-5dd2-b012-908ec3e06435
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Globalization.Language>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Language? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageBridge>
internal class IVectorViewLanguage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguage }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.Language? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.Language?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguage
    internal typealias SwiftABI = IVectorViewLanguage
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.Language?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.Language?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.Language? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.Language?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableLanguage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Language?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation: WindowsFoundation.IID {
    .init(Data1: 0x97dfde96, Data2: 0xff1d, Data3: 0x5aa1, Data4: ( 0x86,0x3a,0x90,0x11,0x6a,0x31,0xb8,0x6b ))// 97dfde96-ff1d-5aa1-863a-90116a31b86b
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Graphics.Imaging.BitmapCodecInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.BitmapCodecInformation? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge>
internal class IVectorViewBitmapCodecInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.BitmapCodecInformation? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.BitmapCodecInformation?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformation
    internal typealias SwiftABI = IVectorViewBitmapCodecInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.BitmapCodecInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.BitmapCodecInformation?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapCodecInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.BitmapCodecInformation? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.BitmapCodecInformation?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableBitmapCodecInformation! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.BitmapCodecInformation?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume: WindowsFoundation.IID {
    .init(Data1: 0x50b5715a, Data2: 0xf077, Data3: 0x53d1, Data4: ( 0x89,0x6d,0xb1,0x32,0xc4,0x87,0x01,0xf4 ))// 50b5715a-f077-53d1-896d-b132c48701f4
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Management.Deployment.PackageVolume>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PackageVolume? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge>
internal class IVectorViewPackageVolume: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.PackageVolume? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.PackageVolume?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume
    internal typealias SwiftABI = IVectorViewPackageVolume
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.PackageVolume?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.PackageVolume? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.PackageVolume?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePackageVolume! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PackageVolume?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat: WindowsFoundation.IID {
    .init(Data1: 0xbae2547d, Data2: 0x3fae, Data3: 0x55cd, Data4: ( 0xb2,0x09,0x45,0xc3,0xb5,0xb2,0xf8,0x16 ))// bae2547d-3fae-55cd-b209-45c3b5b2f816
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Capture.Frames.MediaFrameFormat>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaFrameFormat? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge>
internal class IVectorViewMediaFrameFormat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MediaFrameFormat? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MediaFrameFormat?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormat
    internal typealias SwiftABI = IVectorViewMediaFrameFormat
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MediaFrameFormat?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameFormat?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameFormatBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaFrameFormat? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaFrameFormat?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaFrameFormat! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaFrameFormat?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup: WindowsFoundation.IID {
    .init(Data1: 0xd01148ae, Data2: 0xcccd, Data3: 0x56eb, Data4: ( 0xb2,0xb4,0xa7,0xd2,0xac,0xce,0x14,0xec ))// d01148ae-cccd-56eb-b2b4-a7d2acce14ec
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Capture.Frames.MediaFrameSourceGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaFrameSourceGroup? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge>
internal class IVectorViewMediaFrameSourceGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MediaFrameSourceGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MediaFrameSourceGroup?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup
    internal typealias SwiftABI = IVectorViewMediaFrameSourceGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameSourceGroup?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaFrameSourceGroup? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaFrameSourceGroup?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaFrameSourceGroup! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaFrameSourceGroup?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo: WindowsFoundation.IID {
    .init(Data1: 0xdbdb7946, Data2: 0x9b30, Data3: 0x51d0, Data4: ( 0x9c,0x8c,0xc7,0x10,0x5a,0xf6,0x90,0xe0 ))// dbdb7946-9b30-51d0-9c8c-c7105af690e0
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Capture.Frames.MediaFrameSourceInfo>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaFrameSourceInfo? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge>
internal class IVectorViewMediaFrameSourceInfo: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MediaFrameSourceInfo? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MediaFrameSourceInfo?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfo
    internal typealias SwiftABI = IVectorViewMediaFrameSourceInfo
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceInfo?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MediaFrameSourceInfo?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceInfoBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaFrameSourceInfo? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaFrameSourceInfo?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaFrameSourceInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaFrameSourceInfo?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription: WindowsFoundation.IID {
    .init(Data1: 0x726c7c8c, Data2: 0x789e, Data3: 0x5fcb, Data4: ( 0xb3,0x1f,0xf9,0xd9,0xd4,0xa3,0xac,0x42 ))// 726c7c8c-789e-5fcb-b31f-f9d9d4a3ac42
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaCaptureVideoProfileMediaDescription? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge>
internal class IVectorViewMediaCaptureVideoProfileMediaDescription: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MediaCaptureVideoProfileMediaDescription? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MediaCaptureVideoProfileMediaDescription?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescription
    internal typealias SwiftABI = IVectorViewMediaCaptureVideoProfileMediaDescription
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MediaCaptureVideoProfileMediaDescription?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MediaCaptureVideoProfileMediaDescription?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CMediaCaptureVideoProfileMediaDescriptionBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaCaptureVideoProfileMediaDescription? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaCaptureVideoProfileMediaDescription?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaCaptureVideoProfileMediaDescription! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaCaptureVideoProfileMediaDescription?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack: WindowsFoundation.IID {
    .init(Data1: 0xe71ffa4a, Data2: 0x14a7, Data3: 0x5068, Data4: ( 0x89,0x1c,0x6e,0x71,0x7a,0xf8,0xbf,0x8d ))// e71ffa4a-14a7-5068-891c-6e717af8bf8d
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Core.AudioTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AudioTrack? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge>
internal class IVectorViewAudioTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AudioTrack? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AudioTrack?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack
    internal typealias SwiftABI = IVectorViewAudioTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AudioTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AudioTrack?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AudioTrack? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AudioTrack?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAudioTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AudioTrack?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue: WindowsFoundation.IID {
    .init(Data1: 0x996421a1, Data2: 0x625c, Data3: 0x5d92, Data4: ( 0xad,0x68,0x8b,0x39,0x11,0xd2,0x94,0xb0 ))// 996421a1-625c-5d92-ad68-8b3911d294b0
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Core.IMediaCue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        let resultWrapper = __ABI_Windows_Media_Core.IMediaCueWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AnyIMediaCue? = __ABI_Windows_Media_Core.IMediaCueWrapper.unwrapFrom(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge>
internal class IVectorViewIMediaCue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AnyIMediaCue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return __ABI_Windows_Media_Core.IMediaCueWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AnyIMediaCue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        let valueWrapper = __ABI_Windows_Media_Core.IMediaCueWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCue
    internal typealias SwiftABI = IVectorViewIMediaCue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AnyIMediaCue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AnyIMediaCue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CIMediaCueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AnyIMediaCue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AnyIMediaCue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIMediaCue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AnyIMediaCue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer: WindowsFoundation.IID {
    .init(Data1: 0x85318263, Data2: 0x1360, Data3: 0x5c78, Data4: ( 0xb0,0xad,0x52,0xd6,0xb4,0x5b,0x19,0xf3 ))// 85318263-1360-5c78-b0ad-52d6b45b19f3
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Core.MseSourceBuffer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MseSourceBuffer? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge>
internal class IVectorViewMseSourceBuffer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MseSourceBuffer? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MseSourceBuffer?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer
    internal typealias SwiftABI = IVectorViewMseSourceBuffer
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MseSourceBuffer?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MseSourceBuffer?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MseSourceBuffer? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MseSourceBuffer?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMseSourceBuffer! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MseSourceBuffer?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange: WindowsFoundation.IID {
    .init(Data1: 0x87ff1dd1, Data2: 0x7ec3, Data3: 0x5bc5, Data4: ( 0xb5,0x58,0x04,0x25,0xd8,0x06,0xbf,0x4b ))// 87ff1dd1-7ec3-5bc5-b558-0425d806bf4b
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Core.MseTimeRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MseTimeRange = .from(abi: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge>
internal class IVectorViewMseTimeRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MseTimeRange {
        var result: __x_ABI_CWindows_CMedia_CCore_CMseTimeRange = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MseTimeRange, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange
    internal typealias SwiftABI = IVectorViewMseTimeRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MseTimeRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MseTimeRange
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MseTimeRange {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MseTimeRange, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMseTimeRange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MseTimeRange>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack: WindowsFoundation.IID {
    .init(Data1: 0x0313ae7a, Data2: 0x2803, Data3: 0x5d45, Data4: ( 0xb5,0xa1,0xa0,0xfc,0x5c,0xd5,0x5e,0x7c ))// 0313ae7a-2803-5d45-b5a1-a0fc5cd55e7c
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Core.TimedMetadataTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.TimedMetadataTrack? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge>
internal class IVectorViewTimedMetadataTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.TimedMetadataTrack? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.TimedMetadataTrack?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack
    internal typealias SwiftABI = IVectorViewTimedMetadataTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.TimedMetadataTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.TimedMetadataTrack?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.TimedMetadataTrack? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.TimedMetadataTrack?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimedMetadataTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TimedMetadataTrack?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource: WindowsFoundation.IID {
    .init(Data1: 0xedcd634e, Data2: 0xb7e4, Data3: 0x5ff8, Data4: ( 0xb8,0xc2,0x84,0x93,0x84,0x9b,0x2c,0x0d ))// edcd634e-b7e4-5ff8-b8c2-8493849b2c0d
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Core.TimedTextSource>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.TimedTextSource? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge>
internal class IVectorViewTimedTextSource: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.TimedTextSource? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.TimedTextSource?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource
    internal typealias SwiftABI = IVectorViewTimedTextSource
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.TimedTextSource?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.TimedTextSource?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.TimedTextSource? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.TimedTextSource?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimedTextSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TimedTextSource?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack: WindowsFoundation.IID {
    .init(Data1: 0x200c6224, Data2: 0x0b43, Data3: 0x54fb, Data4: ( 0x99,0x5f,0xfd,0x86,0x88,0xbf,0x24,0xde ))// 200c6224-0b43-54fb-995f-fd8688bf24de
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Core.VideoTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.VideoTrack? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge>
internal class IVectorViewVideoTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.VideoTrack? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.VideoTrack?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack
    internal typealias SwiftABI = IVectorViewVideoTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.VideoTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.VideoTrack?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.VideoTrack? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.VideoTrack?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableVideoTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.VideoTrack?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode: WindowsFoundation.IID {
    .init(Data1: 0xd05843b6, Data2: 0x03c8, Data3: 0x523e, Data4: ( 0xb6,0xfb,0x1f,0xcb,0x03,0x21,0x8a,0x54 ))// d05843b6-03c8-523e-b6fb-1fcb03218a54
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.AdvancedPhotoMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AdvancedPhotoMode = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge>
internal class IVectorViewAdvancedPhotoMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AdvancedPhotoMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CAdvancedPhotoMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AdvancedPhotoMode, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoMode
    internal typealias SwiftABI = IVectorViewAdvancedPhotoMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AdvancedPhotoMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AdvancedPhotoMode
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAdvancedPhotoModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AdvancedPhotoMode {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AdvancedPhotoMode, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAdvancedPhotoMode! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AdvancedPhotoMode>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange: WindowsFoundation.IID {
    .init(Data1: 0x5df64825, Data2: 0xc9e1, Data3: 0x525f, Data4: ( 0x9a,0xeb,0x3c,0x0f,0x5f,0x80,0x5f,0x26 ))// 5df64825-c9e1-525f-9aeb-3c0f5f805f26
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.AutoFocusRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AutoFocusRange = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge>
internal class IVectorViewAutoFocusRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AutoFocusRange {
        var result: __x_ABI_CWindows_CMedia_CDevices_CAutoFocusRange = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AutoFocusRange, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRange
    internal typealias SwiftABI = IVectorViewAutoFocusRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AutoFocusRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AutoFocusRange
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CAutoFocusRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AutoFocusRange {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AutoFocusRange, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAutoFocusRange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AutoFocusRange>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode: WindowsFoundation.IID {
    .init(Data1: 0x9b915d69, Data2: 0xe718, Data3: 0x5b48, Data4: ( 0xbb,0x94,0x54,0xbd,0xf3,0x73,0x7e,0xa5 ))// 9b915d69-e718-5b48-bb94-54bdf3737ea5
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.CaptureSceneMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.CaptureSceneMode = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge>
internal class IVectorViewCaptureSceneMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.CaptureSceneMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.CaptureSceneMode, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneMode
    internal typealias SwiftABI = IVectorViewCaptureSceneMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.CaptureSceneMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.CaptureSceneMode
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCaptureSceneModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.CaptureSceneMode {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.CaptureSceneMode, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableCaptureSceneMode! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CaptureSceneMode>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController: WindowsFoundation.IID {
    .init(Data1: 0xfcd6a2a3, Data2: 0xb6ff, Data3: 0x5572, Data4: ( 0x91,0x2b,0x99,0xeb,0xaf,0x95,0x16,0x5d ))// fcd6a2a3-b6ff-5572-912b-99ebaf95165d
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.Core.FrameController>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.FrameController? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge>
internal class IVectorViewFrameController: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.FrameController? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.FrameController?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController
    internal typealias SwiftABI = IVectorViewFrameController
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.FrameController?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.FrameController?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.FrameController? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.FrameController?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableFrameController! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.FrameController?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode: WindowsFoundation.IID {
    .init(Data1: 0xc877975c, Data2: 0xf3c3, Data3: 0x5b3d, Data4: ( 0x93,0xe4,0x57,0x87,0xbe,0x9b,0x7f,0x58 ))// c877975c-f3c3-5b3d-93e4-5787be9b7f58
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.FocusMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.FocusMode = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge>
internal class IVectorViewFocusMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.FocusMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CFocusMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.FocusMode, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusMode
    internal typealias SwiftABI = IVectorViewFocusMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.FocusMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.FocusMode
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.FocusMode {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.FocusMode, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableFocusMode! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.FocusMode>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset: WindowsFoundation.IID {
    .init(Data1: 0xd8a495e3, Data2: 0xd7d4, Data3: 0x5e9f, Data4: ( 0xa9,0xc2,0x6b,0x25,0x06,0x55,0xa2,0xe0 ))// d8a495e3-d7d4-5e9f-a9c2-6b250655a2e0
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.FocusPreset>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.FocusPreset = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge>
internal class IVectorViewFocusPreset: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.FocusPreset {
        var result: __x_ABI_CWindows_CMedia_CDevices_CFocusPreset = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.FocusPreset, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPreset
    internal typealias SwiftABI = IVectorViewFocusPreset
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.FocusPreset>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.FocusPreset
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CFocusPresetBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.FocusPreset {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.FocusPreset, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableFocusPreset! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.FocusPreset>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode: WindowsFoundation.IID {
    .init(Data1: 0xad0a4bbd, Data2: 0x7630, Data3: 0x53a4, Data4: ( 0xaa,0x9b,0x35,0xa8,0xc7,0xd4,0x95,0x8c ))// ad0a4bbd-7630-53a4-aa9b-35a8c7d4958c
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.HdrVideoMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HdrVideoMode = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge>
internal class IVectorViewHdrVideoMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HdrVideoMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CHdrVideoMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HdrVideoMode, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoMode
    internal typealias SwiftABI = IVectorViewHdrVideoMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HdrVideoMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HdrVideoMode
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CHdrVideoModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HdrVideoMode {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HdrVideoMode, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHdrVideoMode! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HdrVideoMode>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode: WindowsFoundation.IID {
    .init(Data1: 0xb5af65de, Data2: 0xbdf4, Data3: 0x5155, Data4: ( 0xb2,0xb6,0x31,0x39,0x97,0x8e,0x9c,0x24 ))// b5af65de-bdf4-5155-b2b6-3139978e9c24
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.InfraredTorchMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.InfraredTorchMode = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge>
internal class IVectorViewInfraredTorchMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.InfraredTorchMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CInfraredTorchMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.InfraredTorchMode, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchMode
    internal typealias SwiftABI = IVectorViewInfraredTorchMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.InfraredTorchMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.InfraredTorchMode
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CInfraredTorchModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.InfraredTorchMode {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.InfraredTorchMode, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableInfraredTorchMode! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.InfraredTorchMode>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset: WindowsFoundation.IID {
    .init(Data1: 0xef6c9fe3, Data2: 0x06f9, Data3: 0x5eff, Data4: ( 0x98,0xa8,0x91,0x7d,0x96,0x44,0xc9,0x46 ))// ef6c9fe3-06f9-5eff-98a8-917d9644c946
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.IsoSpeedPreset>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.IsoSpeedPreset = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge>
internal class IVectorViewIsoSpeedPreset: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.IsoSpeedPreset {
        var result: __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.IsoSpeedPreset, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPreset
    internal typealias SwiftABI = IVectorViewIsoSpeedPreset
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.IsoSpeedPreset>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.IsoSpeedPreset
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CIsoSpeedPresetBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.IsoSpeedPreset {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.IsoSpeedPreset, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIsoSpeedPreset! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.IsoSpeedPreset>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance: WindowsFoundation.IID {
    .init(Data1: 0x85f7663b, Data2: 0x5467, Data3: 0x5736, Data4: ( 0x8d,0x34,0x34,0x39,0x5a,0xa6,0xd1,0x23 ))// 85f7663b-5467-5736-8d34-34395aa6d123
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.ManualFocusDistance>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ManualFocusDistance = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge>
internal class IVectorViewManualFocusDistance: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ManualFocusDistance {
        var result: __x_ABI_CWindows_CMedia_CDevices_CManualFocusDistance = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.ManualFocusDistance, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance
    internal typealias SwiftABI = IVectorViewManualFocusDistance
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.ManualFocusDistance>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.ManualFocusDistance
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ManualFocusDistance {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.ManualFocusDistance, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableManualFocusDistance! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ManualFocusDistance>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode: WindowsFoundation.IID {
    .init(Data1: 0x8c2658d8, Data2: 0xacaa, Data3: 0x5a80, Data4: ( 0xb2,0x59,0x1b,0xa0,0x69,0x7c,0x61,0x38 ))// 8c2658d8-acaa-5a80-b259-1ba0697c6138
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.OpticalImageStabilizationMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.OpticalImageStabilizationMode = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge>
internal class IVectorViewOpticalImageStabilizationMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.OpticalImageStabilizationMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_COpticalImageStabilizationMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.OpticalImageStabilizationMode, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationMode
    internal typealias SwiftABI = IVectorViewOpticalImageStabilizationMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.OpticalImageStabilizationMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.OpticalImageStabilizationMode
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__COpticalImageStabilizationModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.OpticalImageStabilizationMode {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.OpticalImageStabilizationMode, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableOpticalImageStabilizationMode! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.OpticalImageStabilizationMode>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode: WindowsFoundation.IID {
    .init(Data1: 0x094d5da9, Data2: 0x91cc, Data3: 0x55d8, Data4: ( 0xb7,0xb7,0x52,0xe5,0x97,0x15,0x69,0x87 ))// 094d5da9-91cc-55d8-b7b7-52e597156987
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.VideoTemporalDenoisingMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.VideoTemporalDenoisingMode = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge>
internal class IVectorViewVideoTemporalDenoisingMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.VideoTemporalDenoisingMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CVideoTemporalDenoisingMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.VideoTemporalDenoisingMode, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingMode
    internal typealias SwiftABI = IVectorViewVideoTemporalDenoisingMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.VideoTemporalDenoisingMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.VideoTemporalDenoisingMode
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CVideoTemporalDenoisingModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.VideoTemporalDenoisingMode {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.VideoTemporalDenoisingMode, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableVideoTemporalDenoisingMode! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.VideoTemporalDenoisingMode>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode: WindowsFoundation.IID {
    .init(Data1: 0x4d556155, Data2: 0xd021, Data3: 0x5a46, Data4: ( 0x9a,0x1c,0xf4,0x01,0xd6,0x1b,0x85,0x29 ))// 4d556155-d021-5a46-9a1c-f401d61b8529
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Devices.ZoomTransitionMode>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ZoomTransitionMode = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge>
internal class IVectorViewZoomTransitionMode: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ZoomTransitionMode {
        var result: __x_ABI_CWindows_CMedia_CDevices_CZoomTransitionMode = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.ZoomTransitionMode, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionMode
    internal typealias SwiftABI = IVectorViewZoomTransitionMode
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.ZoomTransitionMode>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.ZoomTransitionMode
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CZoomTransitionModeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ZoomTransitionMode {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.ZoomTransitionMode, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableZoomTransitionMode! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ZoomTransitionMode>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties: WindowsFoundation.IID {
    .init(Data1: 0x0f6c3b8b, Data2: 0x5818, Data3: 0x5cbf, Data4: ( 0xbf,0x26,0x66,0x16,0xbf,0xc3,0x08,0xc4 ))// 0f6c3b8b-5818-5cbf-bf26-6616bfc308c4
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.MediaProperties.IMediaEncodingProperties>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        let resultWrapper = __ABI_Windows_Media_MediaProperties.IMediaEncodingPropertiesWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AnyIMediaEncodingProperties? = __ABI_Windows_Media_MediaProperties.IMediaEncodingPropertiesWrapper.unwrapFrom(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge>
internal class IVectorViewIMediaEncodingProperties: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AnyIMediaEncodingProperties? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return __ABI_Windows_Media_MediaProperties.IMediaEncodingPropertiesWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AnyIMediaEncodingProperties?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        let valueWrapper = __ABI_Windows_Media_MediaProperties.IMediaEncodingPropertiesWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingProperties
    internal typealias SwiftABI = IVectorViewIMediaEncodingProperties
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AnyIMediaEncodingProperties?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AnyIMediaEncodingProperties?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaProperties__CIMediaEncodingPropertiesBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AnyIMediaEncodingProperties? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AnyIMediaEncodingProperties?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIMediaEncodingProperties! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AnyIMediaEncodingProperties?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRange: WindowsFoundation.IID {
    .init(Data1: 0x2628205b, Data2: 0xa57a, Data3: 0x5179, Data4: ( 0x92,0xe6,0x9b,0x6e,0x13,0xcb,0x8d,0x0d ))// 2628205b-a57a-5179-92e6-9b6e13cb8d0d
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.MediaTimeRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaTimeRange = .from(abi: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge>
internal class IVectorViewMediaTimeRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRange }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MediaTimeRange {
        var result: __x_ABI_CWindows_CMedia_CMediaTimeRange = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MediaTimeRange, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRange
    internal typealias SwiftABI = IVectorViewMediaTimeRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MediaTimeRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MediaTimeRange
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CMediaTimeRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaTimeRange {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaTimeRange, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaTimeRange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaTimeRange>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak: WindowsFoundation.IID {
    .init(Data1: 0xc296f3f9, Data2: 0x1268, Data3: 0x59a2, Data4: ( 0xb7,0xc3,0x2f,0x58,0x8e,0xd4,0xa0,0x17 ))// c296f3f9-1268-59a2-b7c3-2f588ed4a017
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Playback.MediaBreak>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaBreak? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge>
internal class IVectorViewMediaBreak: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MediaBreak? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MediaBreak?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreak
    internal typealias SwiftABI = IVectorViewMediaBreak
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MediaBreak?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MediaBreak?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaBreak? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaBreak?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaBreak! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaBreak?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem: WindowsFoundation.IID {
    .init(Data1: 0xb6a4c9fe, Data2: 0xc73d, Data3: 0x5eba, Data4: ( 0xb5,0xab,0x6f,0x8d,0xea,0xca,0x30,0xb9 ))// b6a4c9fe-c73d-5eba-b5ab-6f8deaca30b9
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Playback.MediaPlaybackItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaPlaybackItem? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge>
internal class IVectorViewMediaPlaybackItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MediaPlaybackItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.MediaPlaybackItem?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem
    internal typealias SwiftABI = IVectorViewMediaPlaybackItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.MediaPlaybackItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.MediaPlaybackItem?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaPlaybackItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaPlaybackItem?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaPlaybackItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaPlaybackItem?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem: WindowsFoundation.IID {
    .init(Data1: 0x4a8793e2, Data2: 0x33b8, Data3: 0x5850, Data4: ( 0x99,0x43,0x6a,0x94,0x37,0x5c,0xaa,0x89 ))// 4a8793e2-33b8-5850-9943-6a94375caa89
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Media.Protection.RevocationAndRenewalItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.RevocationAndRenewalItem? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge>
internal class IVectorViewRevocationAndRenewalItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.RevocationAndRenewalItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.RevocationAndRenewalItem?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem
    internal typealias SwiftABI = IVectorViewRevocationAndRenewalItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.RevocationAndRenewalItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.RevocationAndRenewalItem?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.RevocationAndRenewalItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.RevocationAndRenewalItem?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableRevocationAndRenewalItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.RevocationAndRenewalItem?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange: WindowsFoundation.IID {
    .init(Data1: 0x5be7934b, Data2: 0xd9fc, Data3: 0x540a, Data4: ( 0x8f,0xfe,0x5f,0xb9,0xc8,0x8c,0x65,0x58 ))// 5be7934b-d9fc-540a-8ffe-5fb9c88c6558
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Networking.BackgroundTransfer.BackgroundTransferFileRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.BackgroundTransferFileRange = .from(abi: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge>
internal class IVectorViewBackgroundTransferFileRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.BackgroundTransferFileRange {
        var result: __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferFileRange = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.BackgroundTransferFileRange, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange
    internal typealias SwiftABI = IVectorViewBackgroundTransferFileRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.BackgroundTransferFileRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.BackgroundTransferFileRange
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.BackgroundTransferFileRange {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.BackgroundTransferFileRange, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableBackgroundTransferFileRange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.BackgroundTransferFileRange>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0x6e7c44ad, Data2: 0x7753, Data3: 0x5437, Data4: ( 0x9f,0x79,0x97,0x0d,0x39,0x1f,0xf7,0xc4 ))// 6e7c44ad-7753-5437-9f79-970d391ff7c4
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Networking.Connectivity.AttributedNetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AttributedNetworkUsage? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge>
internal class IVectorViewAttributedNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AttributedNetworkUsage? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AttributedNetworkUsage?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage
    internal typealias SwiftABI = IVectorViewAttributedNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AttributedNetworkUsage?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AttributedNetworkUsage? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AttributedNetworkUsage?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAttributedNetworkUsage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AttributedNetworkUsage?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval: WindowsFoundation.IID {
    .init(Data1: 0xa3d0d117, Data2: 0x9e21, Data3: 0x5919, Data4: ( 0xb7,0xa0,0xc8,0x19,0x0b,0xd5,0x5a,0xc5 ))// a3d0d117-9e21-5919-b7a0-c8190bd55ac5
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Networking.Connectivity.ConnectivityInterval>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ConnectivityInterval? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge>
internal class IVectorViewConnectivityInterval: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ConnectivityInterval? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.ConnectivityInterval?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval
    internal typealias SwiftABI = IVectorViewConnectivityInterval
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.ConnectivityInterval?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ConnectivityInterval? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.ConnectivityInterval?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableConnectivityInterval! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ConnectivityInterval?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0xb3853391, Data2: 0x40b6, Data3: 0x5cf5, Data4: ( 0x8f,0x46,0x48,0x82,0x69,0x1d,0x1f,0xf7 ))// b3853391-40b6-5cf5-8f46-4882691d1ff7
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Networking.Connectivity.NetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.NetworkUsage? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge>
internal class IVectorViewNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.NetworkUsage? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.NetworkUsage?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage
    internal typealias SwiftABI = IVectorViewNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.NetworkUsage?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.NetworkUsage? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.NetworkUsage?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableNetworkUsage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.NetworkUsage?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0xe66ad09c, Data2: 0xeb37, Data3: 0x54c7, Data4: ( 0x9b,0x2d,0x73,0x4e,0x0e,0x93,0x93,0x05 ))// e66ad09c-eb37-54c7-9b2d-734e0e939305
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Networking.Connectivity.ProviderNetworkUsage>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ProviderNetworkUsage? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge>
internal class IVectorViewProviderNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ProviderNetworkUsage? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.ProviderNetworkUsage?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage
    internal typealias SwiftABI = IVectorViewProviderNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.ProviderNetworkUsage?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ProviderNetworkUsage? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.ProviderNetworkUsage?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableProviderNetworkUsage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ProviderNetworkUsage?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate: WindowsFoundation.IID {
    .init(Data1: 0x963f7013, Data2: 0x77c2, Data3: 0x51c5, Data4: ( 0x80,0x38,0xb5,0xbc,0xef,0x63,0x3e,0xdb ))// 963f7013-77c2-51c5-8038-b5bcef633edb
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Security.Cryptography.Certificates.Certificate>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Certificate? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge>
internal class IVectorViewCertificate: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.Certificate? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.Certificate?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate
    internal typealias SwiftABI = IVectorViewCertificate
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.Certificate?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.Certificate?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.Certificate? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.Certificate?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableCertificate! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Certificate?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult: WindowsFoundation.IID {
    .init(Data1: 0xcb383486, Data2: 0xc2bc, Data3: 0x5756, Data4: ( 0x91,0x2d,0x6a,0x70,0x8a,0x07,0xe5,0xbd ))// cb383486-c2bc-5756-912d-6a708a07e5bd
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Security.Cryptography.Certificates.ChainValidationResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ChainValidationResult = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge>
internal class IVectorViewChainValidationResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ChainValidationResult {
        var result: __x_ABI_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.ChainValidationResult, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResult
    internal typealias SwiftABI = IVectorViewChainValidationResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.ChainValidationResult>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.ChainValidationResult
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CChainValidationResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ChainValidationResult {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.ChainValidationResult, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableChainValidationResult! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ChainValidationResult>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0x85575a41, Data2: 0x06cb, Data3: 0x58d0, Data4: ( 0xb9,0x8a,0x7c,0x8f,0x06,0xe6,0xe9,0xd7 ))// 85575a41-06cb-58d0-b98a-7c8f06e6e9d7
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Storage.IStorageItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        let resultWrapper = __ABI_Windows_Storage.IStorageItemWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AnyIStorageItem? = __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemBridge>
internal class IVectorViewIStorageItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AnyIStorageItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.AnyIStorageItem?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        let valueWrapper = __ABI_Windows_Storage.IStorageItemWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem
    internal typealias SwiftABI = IVectorViewIStorageItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.AnyIStorageItem?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AnyIStorageItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.AnyIStorageItem?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIStorageItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AnyIStorageItem?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry: WindowsFoundation.IID {
    .init(Data1: 0x823c7604, Data2: 0xb37b, Data3: 0x5465, Data4: ( 0xa1,0x69,0x29,0x49,0x78,0x93,0xcd,0xb9 ))// 823c7604-b37b-5465-a169-29497893cdb9
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Storage.Search.SortEntry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        let _result = __ABI_Windows_Storage_Search._ABI_SortEntry(from: result)
        	$2?.initialize(to: _result.detach())
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.SortEntry = .from(abi: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge>
internal class IVectorViewSortEntry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.SortEntry {
        var result: __x_ABI_CWindows_CStorage_CSearch_CSortEntry = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.SortEntry, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        let _value = __ABI_Windows_Storage_Search._ABI_SortEntry(from: value)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value.val, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry
    internal typealias SwiftABI = IVectorViewSortEntry
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.SortEntry>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.SortEntry
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.SortEntry {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.SortEntry, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableSortEntry! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.SortEntry>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile: WindowsFoundation.IID {
    .init(Data1: 0x80646519, Data2: 0x5e2a, Data3: 0x595d, Data4: ( 0xa8,0xcd,0x2a,0x24,0xb4,0x06,0x7f,0x1b ))// 80646519-5e2a-595d-a8cd-2a24b4067f1b
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Storage.StorageFile>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.StorageFile? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileBridge>
internal class IVectorViewStorageFile: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.StorageFile? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.StorageFile?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile
    internal typealias SwiftABI = IVectorViewStorageFile
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.StorageFile?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.StorageFile?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.StorageFile? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.StorageFile?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableStorageFile! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.StorageFile?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder: WindowsFoundation.IID {
    .init(Data1: 0xe20debc6, Data2: 0xdc4e, Data3: 0x542e, Data4: ( 0xa2,0xe7,0xa2,0x4d,0x19,0xc8,0xdd,0x62 ))// e20debc6-dc4e-542e-a2e7-a24d19c8dd62
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Storage.StorageFolder>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.StorageFolder? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderBridge>
internal class IVectorViewStorageFolder: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.StorageFolder? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.StorageFolder?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder
    internal typealias SwiftABI = IVectorViewStorageFolder
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.StorageFolder?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.StorageFolder? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.StorageFolder?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableStorageFolder! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.StorageFolder?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange: WindowsFoundation.IID {
    .init(Data1: 0x0d3879e2, Data2: 0x5c7e, Data3: 0x5b6c, Data4: ( 0x95,0x4d,0x10,0xc6,0xda,0x95,0xfb,0xff ))// 0d3879e2-5c7e-5b6c-954d-10c6da95fbff
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Storage.StorageLibraryChange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.StorageLibraryChange? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge>
internal class IVectorViewStorageLibraryChange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.StorageLibraryChange? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.StorageLibraryChange?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange
    internal typealias SwiftABI = IVectorViewStorageLibraryChange
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.StorageLibraryChange?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.StorageLibraryChange? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.StorageLibraryChange?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableStorageLibraryChange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.StorageLibraryChange?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser: WindowsFoundation.IID {
    .init(Data1: 0x8cbd762a, Data2: 0x1222, Data3: 0x5ee5, Data4: ( 0xb7,0x45,0x48,0x9e,0x7a,0x42,0xc6,0xec ))// 8cbd762a-1222-5ee5-b745-489e7a42c6ec
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSystem__CUserWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.System.User>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.User? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserBridge>
internal class IVectorViewUser: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.User? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.User?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser
    internal typealias SwiftABI = IVectorViewUser
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.User?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.User?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.User? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.User?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableUser! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.User?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop: WindowsFoundation.IID {
    .init(Data1: 0x801d95c7, Data2: 0x7ce2, Data3: 0x55d7, Data4: ( 0xa6,0x2f,0x2f,0xf9,0x4c,0x54,0x40,0x34 ))// 801d95c7-7ce2-55d7-a62f-2ff94c544034
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.UI.Composition.CompositionColorGradientStop>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.CompositionColorGradientStop? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge>
internal class IVectorViewCompositionColorGradientStop: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.CompositionColorGradientStop? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.CompositionColorGradientStop?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop
    internal typealias SwiftABI = IVectorViewCompositionColorGradientStop
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.CompositionColorGradientStop?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.CompositionColorGradientStop?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.CompositionColorGradientStop? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.CompositionColorGradientStop?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableCompositionColorGradientStop! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionColorGradientStop?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape: WindowsFoundation.IID {
    .init(Data1: 0xe7e27ef4, Data2: 0x4ec6, Data3: 0x5b8a, Data4: ( 0xa8,0x58,0x56,0x1b,0x95,0x34,0xa8,0x85 ))// e7e27ef4-4ec6-5b8a-a858-561b9534a885
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.UI.Composition.CompositionShape>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.CompositionShape? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge>
internal class IVectorViewCompositionShape: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.CompositionShape? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.CompositionShape?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape
    internal typealias SwiftABI = IVectorViewCompositionShape
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.CompositionShape?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.CompositionShape?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.CompositionShape? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.CompositionShape?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableCompositionShape! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionShape?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPoint: WindowsFoundation.IID {
    .init(Data1: 0xf0f57411, Data2: 0x7786, Data3: 0x5174, Data4: ( 0x87,0x52,0x4c,0x5e,0x83,0x4b,0x6d,0xa2 ))// f0f57411-7786-5174-8752-4c5e834b6da2
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.UI.Input.PointerPoint>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PointerPoint? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge>
internal class IVectorViewPointerPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPoint }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.PointerPoint? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.PointerPoint?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPoint
    internal typealias SwiftABI = IVectorViewPointerPoint
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.PointerPoint?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.PointerPoint?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.PointerPoint? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.PointerPoint?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointerPoint! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PointerPoint?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification: WindowsFoundation.IID {
    .init(Data1: 0x2b23baa9, Data2: 0x1d54, Data3: 0x5440, Data4: ( 0xbd,0x32,0x86,0xed,0x70,0xf1,0x5c,0x9e ))// 2b23baa9-1d54-5440-bd32-86ed70f15c9e
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.UI.Notifications.ShownTileNotification>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ShownTileNotification? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge>
internal class IVectorViewShownTileNotification: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ShownTileNotification? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.ShownTileNotification?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotification
    internal typealias SwiftABI = IVectorViewShownTileNotification
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.ShownTileNotification?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.ShownTileNotification?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CNotifications__CShownTileNotificationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ShownTileNotification? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.ShownTileNotification?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableShownTileNotification! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ShownTileNotification?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x8b79423f, Data2: 0xb4a3, Data3: 0x501d, Data4: ( 0xba,0xc2,0xb8,0x8e,0x78,0xe1,0x3a,0x21 ))// 8b79423f-b4a3-501d-bac2-b88e78e13a21
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpChallengeHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpChallengeHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge>
internal class IVectorViewHttpChallengeHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpChallengeHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpChallengeHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue
    internal typealias SwiftABI = IVectorViewHttpChallengeHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpChallengeHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpChallengeHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpChallengeHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpChallengeHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpChallengeHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpChallengeHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x1beae481, Data2: 0x9d30, Data3: 0x5ac8, Data4: ( 0x94,0x2c,0x49,0xa5,0xf8,0x73,0x7a,0xdf ))// 1beae481-9d30-5ac8-942c-49a5f8737adf
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpConnectionOptionHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge>
internal class IVectorViewHttpConnectionOptionHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpConnectionOptionHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpConnectionOptionHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue
    internal typealias SwiftABI = IVectorViewHttpConnectionOptionHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpConnectionOptionHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpConnectionOptionHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpConnectionOptionHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpConnectionOptionHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpConnectionOptionHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpConnectionOptionHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xdcdf2620, Data2: 0xb6d0, Data3: 0x5835, Data4: ( 0x8b,0xec,0xd3,0xb9,0x46,0xa5,0x0f,0x55 ))// dcdf2620-b6d0-5835-8bec-d3b946a50f55
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpContentCodingHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpContentCodingHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge>
internal class IVectorViewHttpContentCodingHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpContentCodingHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpContentCodingHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue
    internal typealias SwiftABI = IVectorViewHttpContentCodingHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpContentCodingHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpContentCodingHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpContentCodingHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpContentCodingHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpContentCodingHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpContentCodingHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xeb18569b, Data2: 0xa7ab, Data3: 0x58bb, Data4: ( 0x88,0x80,0xdd,0x02,0x2f,0x75,0x5b,0x51 ))// eb18569b-a7ab-58bb-8880-dd022f755b51
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpContentCodingWithQualityHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge>
internal class IVectorViewHttpContentCodingWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpContentCodingWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpContentCodingWithQualityHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue
    internal typealias SwiftABI = IVectorViewHttpContentCodingWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpContentCodingWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpContentCodingWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpContentCodingWithQualityHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpContentCodingWithQualityHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpContentCodingWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpContentCodingWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xad89192d, Data2: 0x6ef8, Data3: 0x56b5, Data4: ( 0xa4,0xdc,0xe4,0x8d,0x0e,0x85,0xd5,0x69 ))// ad89192d-6ef8-56b5-a4dc-e48d0e85d569
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpCookiePairHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpCookiePairHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge>
internal class IVectorViewHttpCookiePairHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpCookiePairHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpCookiePairHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue
    internal typealias SwiftABI = IVectorViewHttpCookiePairHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpCookiePairHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpCookiePairHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpCookiePairHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpCookiePairHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpCookiePairHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpCookiePairHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x71a22f32, Data2: 0xa3c0, Data3: 0x574b, Data4: ( 0x87,0xb4,0x12,0x71,0x99,0xcc,0x7d,0x5e ))// 71a22f32-a3c0-574b-87b4-127199cc7d5e
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpExpectationHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpExpectationHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge>
internal class IVectorViewHttpExpectationHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpExpectationHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpExpectationHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue
    internal typealias SwiftABI = IVectorViewHttpExpectationHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpExpectationHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpExpectationHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpExpectationHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpExpectationHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpExpectationHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpExpectationHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x551fb7fb, Data2: 0xce42, Data3: 0x5ffd, Data4: ( 0xa2,0xe0,0x2a,0x6c,0xe1,0x69,0x80,0x70 ))// 551fb7fb-ce42-5ffd-a2e0-2a6ce1698070
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpLanguageRangeWithQualityHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge>
internal class IVectorViewHttpLanguageRangeWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpLanguageRangeWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpLanguageRangeWithQualityHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue
    internal typealias SwiftABI = IVectorViewHttpLanguageRangeWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpLanguageRangeWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpLanguageRangeWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpLanguageRangeWithQualityHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpLanguageRangeWithQualityHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpLanguageRangeWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpLanguageRangeWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xf1c1e9bd, Data2: 0x01a6, Data3: 0x5bd3, Data4: ( 0xaf,0x7b,0xc1,0x42,0x20,0xa6,0x45,0xc0 ))// f1c1e9bd-01a6-5bd3-af7b-c14220a645c0
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpMediaTypeWithQualityHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge>
internal class IVectorViewHttpMediaTypeWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpMediaTypeWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpMediaTypeWithQualityHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue
    internal typealias SwiftABI = IVectorViewHttpMediaTypeWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpMediaTypeWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpMediaTypeWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpMediaTypeWithQualityHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpMediaTypeWithQualityHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpMediaTypeWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpMediaTypeWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x1ef903c8, Data2: 0x8eef, Data3: 0x5e9e, Data4: ( 0xb9,0x38,0xb9,0xe4,0x28,0xa7,0x76,0x72 ))// 1ef903c8-8eef-5e9e-b938-b9e428a77672
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpNameValueHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpNameValueHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge>
internal class IVectorViewHttpNameValueHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpNameValueHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpNameValueHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue
    internal typealias SwiftABI = IVectorViewHttpNameValueHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpNameValueHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpNameValueHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpNameValueHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpNameValueHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpNameValueHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpNameValueHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x82fef9f0, Data2: 0xe283, Data3: 0x5279, Data4: ( 0xaa,0x50,0xf0,0xb3,0xe5,0x72,0x6a,0x86 ))// 82fef9f0-e283-5279-aa50-f0b3e5726a86
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpProductInfoHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpProductInfoHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge>
internal class IVectorViewHttpProductInfoHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpProductInfoHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpProductInfoHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue
    internal typealias SwiftABI = IVectorViewHttpProductInfoHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpProductInfoHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpProductInfoHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpProductInfoHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpProductInfoHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpProductInfoHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpProductInfoHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x25c1a8d6, Data2: 0x229b, Data3: 0x5421, Data4: ( 0xb3,0xb3,0xb7,0xef,0x07,0x8f,0xad,0x7f ))// 25c1a8d6-229b-5421-b3b3-b7ef078fad7f
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.Headers.HttpTransferCodingHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpTransferCodingHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge>
internal class IVectorViewHttpTransferCodingHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpTransferCodingHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpTransferCodingHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue
    internal typealias SwiftABI = IVectorViewHttpTransferCodingHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpTransferCodingHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpTransferCodingHeaderValue?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpTransferCodingHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpTransferCodingHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpTransferCodingHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpTransferCodingHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod: WindowsFoundation.IID {
    .init(Data1: 0xef132fb7, Data2: 0xd286, Data3: 0x5327, Data4: ( 0xb3,0x8a,0xbe,0x7d,0x00,0x83,0x28,0xfe ))// ef132fb7-d286-5327-b38a-be7d008328fe
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.Http.HttpMethod>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpMethod? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge>
internal class IVectorViewHttpMethod: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpMethod? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.HttpMethod?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod
    internal typealias SwiftABI = IVectorViewHttpMethod
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.HttpMethod?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.HttpMethod?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpMethod? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpMethod?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpMethod! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpMethod?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatus: WindowsFoundation.IID {
    .init(Data1: 0xf5d10d42, Data2: 0xa776, Data3: 0x533a, Data4: ( 0x8f,0x4b,0x2e,0x1c,0x6e,0x5b,0xbf,0x24 ))// f5d10d42-a776-533a-8f4b-2e1c6e5bbf24
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Web.WebErrorStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.WebErrorStatus = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge>
internal class IVectorViewWebErrorStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatus }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.WebErrorStatus {
        var result: __x_ABI_CWindows_CWeb_CWebErrorStatus = .init(0)
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func IndexOfImpl(_ value: UWP.WebErrorStatus, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatus
    internal typealias SwiftABI = IVectorViewWebErrorStatus
    internal typealias SwiftProjection = WindowsFoundation.AnyIVectorView<UWP.WebErrorStatus>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusImpl : IVectorView, AbiInterfaceImpl {
    typealias T = UWP.WebErrorStatus
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }

    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.WebErrorStatus {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate func indexOf(_ value: UWP.WebErrorStatus, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableWebErrorStatus! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.WebErrorStatus>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1_float: WindowsFoundation.IID {
    .init(Data1: 0x61cf693f, Data2: 0xdb4c, Data3: 0x579f, Data4: ( 0xb9,0x05,0x5d,0xd3,0xd2,0x3c,0xfd,0x4d ))// 61cf693f-db4c-579f-b905-5dd3d23cfd4d
}

internal var __x_ABI_C__FIVector_1_floatVTable: __x_ABI_C__FIVector_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1_floatWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1_floatWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1_floatWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1_floatWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: Float = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: Float = $2
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: Float = $2
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: Float = $1
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1_floatWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1_floatBridge>
internal class IVectorFloat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1_float }

    internal func GetAtImpl(_ index: UInt32) throws -> Float {
        var result: FLOAT = 0.0
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<Float>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1_floatWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: Float, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: Float) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, value))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: Float) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, value))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: Float) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, value))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1_floatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1_float
    internal typealias SwiftABI = IVectorFloat
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<Float>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1_floatImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1_floatImpl : IVector, AbiInterfaceImpl {
    typealias T = Float
    typealias Bridge = __x_ABI_C__FIVector_1_floatBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> Float {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<Float>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: Float, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: Float) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: Float) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: Float) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableFloat! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<Float>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x98b9acc1, Data2: 0x4b56, Data3: 0x532e, Data4: ( 0xac,0x73,0x03,0xd5,0x29,0x1c,0xca,0x90 ))// 98b9acc1-4b56-532e-ac73-03d5291cca90
}

internal var __x_ABI_C__FIVector_1_HSTRINGVTable: __x_ABI_C__FIVector_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1_HSTRINGWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1_HSTRINGWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: String = .init(from: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: String = .init(from: $2)
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: String = .init(from: $2)
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: String = .init(from: $1)
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1_HSTRINGBridge>
internal class IVectorString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1_HSTRING }

    internal func GetAtImpl(_ index: UInt32) throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .init(from: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: String, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        let _value = try! HString(value)
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value.get(), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: String) throws {
        let _value = try! HString(value)
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, _value.get()))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: String) throws {
        let _value = try! HString(value)
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, _value.get()))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: String) throws {
        let _value = try! HString(value)
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, _value.get()))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1_HSTRING
    internal typealias SwiftABI = IVectorString
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1_HSTRINGImpl : IVector, AbiInterfaceImpl {
    typealias T = String
    typealias Bridge = __x_ABI_C__FIVector_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> String {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<String>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: String, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: String) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: String) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: String) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableString! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<String>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider: WindowsFoundation.IID {
    .init(Data1: 0xa1687865, Data2: 0x31e2, Data3: 0x5536, Data4: ( 0x97,0xec,0x29,0x22,0x69,0xa7,0x80,0x46 ))// a1687865-31e2-5536-97ec-292269a78046
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.ApplicationModel.DataTransfer.ShareProvider>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ShareProvider? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.ShareProvider? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.ShareProvider? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.ShareProvider? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge>
internal class IVectorShareProvider: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.ShareProvider? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.ShareProvider?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.ShareProvider?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.ShareProvider?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.ShareProvider?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.ShareProvider?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvider
    internal typealias SwiftABI = IVectorShareProvider
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.ShareProvider?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.ShareProvider?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProviderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.ShareProvider? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.ShareProvider?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.ShareProvider?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.ShareProvider?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.ShareProvider?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.ShareProvider?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableShareProvider! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.ShareProvider?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage: WindowsFoundation.IID {
    .init(Data1: 0xd1bb509e, Data2: 0x6989, Data3: 0x5c69, Data4: ( 0xb1,0xff,0xd1,0x70,0x2f,0xe8,0xac,0xa3 ))// d1bb509e-6989-5c69-b1ff-d1702fe8aca3
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.ApplicationModel.Package>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Package? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.Package? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.Package? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Package? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageBridge>
internal class IVectorPackage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.Package? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.Package?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.Package?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.Package?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.Package?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.Package?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackage
    internal typealias SwiftABI = IVectorPackage
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.Package?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.Package?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.Package? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.Package?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.Package?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.Package?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.Package?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.Package?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePackage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Package?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup: WindowsFoundation.IID {
    .init(Data1: 0x29adc699, Data2: 0x5848, Data3: 0x5a98, Data4: ( 0xa5,0x16,0x23,0xfe,0xb0,0xfa,0x2c,0x4b ))// 29adc699-5848-5a98-a516-23feb0fa2c4b
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.ApplicationModel.PackageContentGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PackageContentGroup? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.PackageContentGroup? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.PackageContentGroup? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PackageContentGroup? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge>
internal class IVectorPackageContentGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.PackageContentGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.PackageContentGroup?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.PackageContentGroup?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.PackageContentGroup?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.PackageContentGroup?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.PackageContentGroup?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup
    internal typealias SwiftABI = IVectorPackageContentGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.PackageContentGroup?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.PackageContentGroup? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.PackageContentGroup?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.PackageContentGroup?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.PackageContentGroup?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.PackageContentGroup?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.PackageContentGroup?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePackageContentGroup! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PackageContentGroup?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage: WindowsFoundation.IID {
    .init(Data1: 0xdcf2525a, Data2: 0x42c0, Data3: 0x501d, Data4: ( 0x9f,0xcb,0x47,0x1f,0xae,0x06,0x03,0x96 ))// dcf2525a-42c0-501d-9fcb-471fae060396
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Globalization.Language>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Language? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.Language? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.Language? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Language? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageBridge>
internal class IVectorLanguage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.Language? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.Language?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CGlobalization__CLanguageWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.Language?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.Language?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.Language?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.Language?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguage
    internal typealias SwiftABI = IVectorLanguage
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.Language?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.Language?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CGlobalization__CLanguageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.Language? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.Language?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.Language?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.Language?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.Language?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.Language?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableLanguage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Language?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack: WindowsFoundation.IID {
    .init(Data1: 0xc46d9e34, Data2: 0xea11, Data3: 0x5bb2, Data4: ( 0x97,0x44,0x16,0x17,0x41,0x7e,0xf0,0x16 ))// c46d9e34-ea11-5bb2-9744-1617417ef016
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Media.Core.TimedMetadataTrack>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.TimedMetadataTrack? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.TimedMetadataTrack? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.TimedMetadataTrack? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.TimedMetadataTrack? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge>
internal class IVectorTimedMetadataTrack: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.TimedMetadataTrack? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.TimedMetadataTrack?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.TimedMetadataTrack?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.TimedMetadataTrack?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.TimedMetadataTrack?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.TimedMetadataTrack?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack
    internal typealias SwiftABI = IVectorTimedMetadataTrack
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.TimedMetadataTrack?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.TimedMetadataTrack?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.TimedMetadataTrack? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.TimedMetadataTrack?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.TimedMetadataTrack?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.TimedMetadataTrack?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.TimedMetadataTrack?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.TimedMetadataTrack?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimedMetadataTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TimedMetadataTrack?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource: WindowsFoundation.IID {
    .init(Data1: 0xd0a72378, Data2: 0x5432, Data3: 0x50bf, Data4: ( 0x93,0xc3,0xc5,0xf3,0x5f,0xc9,0x35,0x17 ))// d0a72378-5432-50bf-93c3-c5f35fc93517
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Media.Core.TimedTextSource>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.TimedTextSource? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.TimedTextSource? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.TimedTextSource? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.TimedTextSource? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge>
internal class IVectorTimedTextSource: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.TimedTextSource? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.TimedTextSource?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.TimedTextSource?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.TimedTextSource?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.TimedTextSource?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.TimedTextSource?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource
    internal typealias SwiftABI = IVectorTimedTextSource
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.TimedTextSource?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.TimedTextSource?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.TimedTextSource? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.TimedTextSource?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.TimedTextSource?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.TimedTextSource?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.TimedTextSource?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.TimedTextSource?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimedTextSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.TimedTextSource?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController: WindowsFoundation.IID {
    .init(Data1: 0x1c8f8276, Data2: 0xb89a, Data3: 0x5093, Data4: ( 0xa1,0xed,0xaf,0x49,0xdf,0xb7,0x2a,0x89 ))// 1c8f8276-b89a-5093-a1ed-af49dfb72a89
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Media.Devices.Core.FrameController>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.FrameController? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.FrameController? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.FrameController? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.FrameController? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge>
internal class IVectorFrameController: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.FrameController? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.FrameController?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.FrameController?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.FrameController?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.FrameController?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.FrameController?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameController
    internal typealias SwiftABI = IVectorFrameController
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.FrameController?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.FrameController?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CDevices__CCore__CFrameControllerBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.FrameController? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.FrameController?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.FrameController?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.FrameController?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.FrameController?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.FrameController?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableFrameController! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.FrameController?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem: WindowsFoundation.IID {
    .init(Data1: 0xe1504f46, Data2: 0xc4a6, Data3: 0x5a29, Data4: ( 0x8f,0xc9,0xa9,0x34,0xd1,0x2d,0x72,0x42 ))// e1504f46-c4a6-5a29-8fc9-a934d12d7242
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Media.Playback.MediaPlaybackItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaPlaybackItem? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.MediaPlaybackItem? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.MediaPlaybackItem? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.MediaPlaybackItem? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge>
internal class IVectorMediaPlaybackItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.MediaPlaybackItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.MediaPlaybackItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.MediaPlaybackItem?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.MediaPlaybackItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.MediaPlaybackItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.MediaPlaybackItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem
    internal typealias SwiftABI = IVectorMediaPlaybackItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.MediaPlaybackItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.MediaPlaybackItem?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.MediaPlaybackItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.MediaPlaybackItem?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.MediaPlaybackItem?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.MediaPlaybackItem?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.MediaPlaybackItem?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.MediaPlaybackItem?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMediaPlaybackItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.MediaPlaybackItem?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem: WindowsFoundation.IID {
    .init(Data1: 0x3623cc0c, Data2: 0xc765, Data3: 0x57fb, Data4: ( 0x96,0x7d,0xc7,0xcb,0x60,0x97,0xbd,0x78 ))// 3623cc0c-c765-57fb-967d-c7cb6097bd78
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Media.Protection.RevocationAndRenewalItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.RevocationAndRenewalItem? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.RevocationAndRenewalItem? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.RevocationAndRenewalItem? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.RevocationAndRenewalItem? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge>
internal class IVectorRevocationAndRenewalItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.RevocationAndRenewalItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.RevocationAndRenewalItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.RevocationAndRenewalItem?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.RevocationAndRenewalItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.RevocationAndRenewalItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.RevocationAndRenewalItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItem
    internal typealias SwiftABI = IVectorRevocationAndRenewalItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.RevocationAndRenewalItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.RevocationAndRenewalItem?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CMedia__CProtection__CRevocationAndRenewalItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.RevocationAndRenewalItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.RevocationAndRenewalItem?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.RevocationAndRenewalItem?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.RevocationAndRenewalItem?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.RevocationAndRenewalItem?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.RevocationAndRenewalItem?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableRevocationAndRenewalItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.RevocationAndRenewalItem?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange: WindowsFoundation.IID {
    .init(Data1: 0xc73ceef0, Data2: 0x854a, Data3: 0x5947, Data4: ( 0x9e,0x7c,0x52,0x7e,0x39,0x15,0xd3,0x35 ))// c73ceef0-854a-5947-9e7c-527e3915d335
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Networking.BackgroundTransfer.BackgroundTransferFileRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.BackgroundTransferFileRange = .from(abi: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.BackgroundTransferFileRange = .from(abi: $2)
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.BackgroundTransferFileRange = .from(abi: $2)
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.BackgroundTransferFileRange = .from(abi: $1)
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge>
internal class IVectorBackgroundTransferFileRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.BackgroundTransferFileRange {
        var result: __x_ABI_CWindows_CNetworking_CBackgroundTransfer_CBackgroundTransferFileRange = .init()
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.BackgroundTransferFileRange>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.BackgroundTransferFileRange, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.BackgroundTransferFileRange) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, .from(swift: value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.BackgroundTransferFileRange) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, .from(swift: value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.BackgroundTransferFileRange) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, .from(swift: value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRange
    internal typealias SwiftABI = IVectorBackgroundTransferFileRange
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.BackgroundTransferFileRange>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.BackgroundTransferFileRange
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferFileRangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.BackgroundTransferFileRange {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.BackgroundTransferFileRange>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.BackgroundTransferFileRange, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.BackgroundTransferFileRange) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.BackgroundTransferFileRange) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.BackgroundTransferFileRange) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableBackgroundTransferFileRange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.BackgroundTransferFileRange>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate: WindowsFoundation.IID {
    .init(Data1: 0x36282c0f, Data2: 0x2f1f, Data3: 0x57f4, Data4: ( 0xb2,0xb1,0x86,0x7a,0xf9,0x0c,0x3d,0x13 ))// 36282c0f-2f1f-57f4-b2b1-867af90c3d13
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Security.Cryptography.Certificates.Certificate>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Certificate? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.Certificate? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.Certificate? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.Certificate? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge>
internal class IVectorCertificate: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.Certificate? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.Certificate?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.Certificate?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.Certificate?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.Certificate?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.Certificate?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificate
    internal typealias SwiftABI = IVectorCertificate
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.Certificate?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.Certificate?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.Certificate? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.Certificate?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.Certificate?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.Certificate?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.Certificate?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.Certificate?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableCertificate! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.Certificate?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0x802508e2, Data2: 0x9c2c, Data3: 0x5b91, Data4: ( 0x89,0xa8,0x39,0xbc,0xf7,0x22,0x33,0x44 ))// 802508e2-9c2c-5b91-89a8-39bcf7223344
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Storage.IStorageItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        let resultWrapper = __ABI_Windows_Storage.IStorageItemWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AnyIStorageItem? = __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.AnyIStorageItem? = __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.AnyIStorageItem? = __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.AnyIStorageItem? = __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemBridge>
internal class IVectorIStorageItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.AnyIStorageItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.AnyIStorageItem?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        let valueWrapper = __ABI_Windows_Storage.IStorageItemWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value, &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.AnyIStorageItem?) throws {
        let valueWrapper = __ABI_Windows_Storage.IStorageItemWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, _value))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.AnyIStorageItem?) throws {
        let valueWrapper = __ABI_Windows_Storage.IStorageItemWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, _value))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.AnyIStorageItem?) throws {
        let valueWrapper = __ABI_Windows_Storage.IStorageItemWrapper(value)
        let _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, _value))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItem
    internal typealias SwiftABI = IVectorIStorageItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.AnyIStorageItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.AnyIStorageItem?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CIStorageItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.AnyIStorageItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.AnyIStorageItem?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.AnyIStorageItem?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.AnyIStorageItem?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.AnyIStorageItem?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIStorageItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.AnyIStorageItem?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry: WindowsFoundation.IID {
    .init(Data1: 0xd8ea401b, Data2: 0x47b3, Data3: 0x5254, Data4: ( 0x84,0xf4,0xee,0xa1,0x0c,0x4c,0xf0,0x68 ))// d8ea401b-47b3-5254-84f4-eea10c4cf068
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Storage.Search.SortEntry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        let _result = __ABI_Windows_Storage_Search._ABI_SortEntry(from: result)
        	$2?.initialize(to: _result.detach())
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.SortEntry = .from(abi: $1)
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.SortEntry = .from(abi: $2)
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.SortEntry = .from(abi: $2)
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.SortEntry = .from(abi: $1)
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge>
internal class IVectorSortEntry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.SortEntry {
        var result: __x_ABI_CWindows_CStorage_CSearch_CSortEntry = .init()
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.SortEntry>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.SortEntry, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        let _value = __ABI_Windows_Storage_Search._ABI_SortEntry(from: value)
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value.val, &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.SortEntry) throws {
        let _value = __ABI_Windows_Storage_Search._ABI_SortEntry(from: value)
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, _value.val))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.SortEntry) throws {
        let _value = __ABI_Windows_Storage_Search._ABI_SortEntry(from: value)
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, _value.val))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.SortEntry) throws {
        let _value = __ABI_Windows_Storage_Search._ABI_SortEntry(from: value)
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, _value.val))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntry
    internal typealias SwiftABI = IVectorSortEntry
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.SortEntry>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.SortEntry
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CStorage__CSearch__CSortEntryBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.SortEntry {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.SortEntry>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.SortEntry, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.SortEntry) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.SortEntry) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.SortEntry) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableSortEntry! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.SortEntry>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop: WindowsFoundation.IID {
    .init(Data1: 0xbf2e107e, Data2: 0xf3db, Data3: 0x56cd, Data4: ( 0x91,0xed,0xc1,0x12,0x94,0x06,0xd5,0x52 ))// bf2e107e-f3db-56cd-91ed-c1129406d552
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.UI.Composition.CompositionColorGradientStop>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.CompositionColorGradientStop? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.CompositionColorGradientStop? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.CompositionColorGradientStop? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.CompositionColorGradientStop? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge>
internal class IVectorCompositionColorGradientStop: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.CompositionColorGradientStop? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.CompositionColorGradientStop?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.CompositionColorGradientStop?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.CompositionColorGradientStop?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.CompositionColorGradientStop?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.CompositionColorGradientStop?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStop
    internal typealias SwiftABI = IVectorCompositionColorGradientStop
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.CompositionColorGradientStop?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.CompositionColorGradientStop?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionColorGradientStopBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.CompositionColorGradientStop? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.CompositionColorGradientStop?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.CompositionColorGradientStop?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.CompositionColorGradientStop?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.CompositionColorGradientStop?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.CompositionColorGradientStop?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableCompositionColorGradientStop! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionColorGradientStop?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape: WindowsFoundation.IID {
    .init(Data1: 0x42d4219a, Data2: 0xbe1b, Data3: 0x5091, Data4: ( 0x8f,0x1e,0x90,0x27,0x08,0x40,0xfc,0x2d ))// 42d4219a-be1b-5091-8f1e-90270840fc2d
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.UI.Composition.CompositionShape>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.CompositionShape? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.CompositionShape? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.CompositionShape? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.CompositionShape? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge>
internal class IVectorCompositionShape: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.CompositionShape? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.CompositionShape?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.CompositionShape?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.CompositionShape?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.CompositionShape?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.CompositionShape?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShape
    internal typealias SwiftABI = IVectorCompositionShape
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.CompositionShape?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.CompositionShape?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CComposition__CCompositionShapeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.CompositionShape? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.CompositionShape?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.CompositionShape?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.CompositionShape?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.CompositionShape?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.CompositionShape?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableCompositionShape! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.CompositionShape?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint: WindowsFoundation.IID {
    .init(Data1: 0xdfa655cf, Data2: 0xfde7, Data3: 0x5048, Data4: ( 0xb4,0xbf,0xc9,0x09,0x23,0x1b,0x7e,0xdb ))// dfa655cf-fde7-5048-b4bf-c909231b7edb
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.UI.Input.PointerPoint>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PointerPoint? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.PointerPoint? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.PointerPoint? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.PointerPoint? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge>
internal class IVectorPointerPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.PointerPoint? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.PointerPoint?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CUI__CInput__CPointerPointWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.PointerPoint?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.PointerPoint?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.PointerPoint?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.PointerPoint?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPoint
    internal typealias SwiftABI = IVectorPointerPoint
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.PointerPoint?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.PointerPoint?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CUI__CInput__CPointerPointBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.PointerPoint? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.PointerPoint?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.PointerPoint?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.PointerPoint?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.PointerPoint?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.PointerPoint?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointerPoint! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.PointerPoint?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x3737fc5e, Data2: 0x0b27, Data3: 0x52a3, Data4: ( 0x9e,0x40,0xcb,0xb9,0x84,0x4e,0x6a,0xb7 ))// 3737fc5e-0b27-52a3-9e40-cbb9844e6ab7
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpChallengeHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpChallengeHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpChallengeHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpChallengeHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpChallengeHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge>
internal class IVectorHttpChallengeHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpChallengeHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpChallengeHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpChallengeHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpChallengeHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpChallengeHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpChallengeHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValue
    internal typealias SwiftABI = IVectorHttpChallengeHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpChallengeHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpChallengeHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpChallengeHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpChallengeHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpChallengeHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpChallengeHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpChallengeHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpChallengeHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpChallengeHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpChallengeHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpChallengeHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xc312da8d, Data2: 0xc82f, Data3: 0x51c9, Data4: ( 0xb7,0x05,0x5a,0x26,0xd5,0x2f,0xbe,0xe6 ))// c312da8d-c82f-51c9-b705-5a26d52fbee6
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpConnectionOptionHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpConnectionOptionHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpConnectionOptionHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpConnectionOptionHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge>
internal class IVectorHttpConnectionOptionHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpConnectionOptionHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpConnectionOptionHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpConnectionOptionHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpConnectionOptionHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpConnectionOptionHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpConnectionOptionHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValue
    internal typealias SwiftABI = IVectorHttpConnectionOptionHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpConnectionOptionHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpConnectionOptionHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpConnectionOptionHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpConnectionOptionHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpConnectionOptionHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpConnectionOptionHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpConnectionOptionHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpConnectionOptionHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpConnectionOptionHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpConnectionOptionHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpConnectionOptionHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xb94e539f, Data2: 0x44b6, Data3: 0x54c6, Data4: ( 0x9a,0xd4,0xe2,0x84,0x4b,0x3e,0x0b,0xe1 ))// b94e539f-44b6-54c6-9ad4-e2844b3e0be1
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpContentCodingHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpContentCodingHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpContentCodingHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpContentCodingHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpContentCodingHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge>
internal class IVectorHttpContentCodingHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpContentCodingHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpContentCodingHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpContentCodingHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpContentCodingHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpContentCodingHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpContentCodingHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValue
    internal typealias SwiftABI = IVectorHttpContentCodingHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpContentCodingHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpContentCodingHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpContentCodingHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpContentCodingHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpContentCodingHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpContentCodingHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpContentCodingHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpContentCodingHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpContentCodingHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpContentCodingHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x33f9653d, Data2: 0x0eed, Data3: 0x5368, Data4: ( 0xa5,0x1e,0x98,0x38,0x51,0x91,0xf8,0x6f ))// 33f9653d-0eed-5368-a51e-98385191f86f
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpContentCodingWithQualityHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpContentCodingWithQualityHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpContentCodingWithQualityHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpContentCodingWithQualityHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge>
internal class IVectorHttpContentCodingWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpContentCodingWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpContentCodingWithQualityHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpContentCodingWithQualityHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpContentCodingWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpContentCodingWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpContentCodingWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValue
    internal typealias SwiftABI = IVectorHttpContentCodingWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpContentCodingWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpContentCodingWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpContentCodingWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpContentCodingWithQualityHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpContentCodingWithQualityHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpContentCodingWithQualityHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpContentCodingWithQualityHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpContentCodingWithQualityHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpContentCodingWithQualityHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpContentCodingWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpContentCodingWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xbc196ace, Data2: 0x8a56, Data3: 0x5fd0, Data4: ( 0x98,0x78,0xc8,0x07,0xed,0xd8,0x64,0x5a ))// bc196ace-8a56-5fd0-9878-c807edd8645a
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpCookiePairHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpCookiePairHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpCookiePairHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpCookiePairHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpCookiePairHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge>
internal class IVectorHttpCookiePairHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpCookiePairHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpCookiePairHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpCookiePairHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpCookiePairHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpCookiePairHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpCookiePairHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValue
    internal typealias SwiftABI = IVectorHttpCookiePairHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpCookiePairHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpCookiePairHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpCookiePairHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpCookiePairHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpCookiePairHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpCookiePairHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpCookiePairHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpCookiePairHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpCookiePairHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpCookiePairHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpCookiePairHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x18e138ee, Data2: 0xfec7, Data3: 0x527d, Data4: ( 0x86,0x93,0xde,0xeb,0xca,0x4f,0x3d,0xcd ))// 18e138ee-fec7-527d-8693-deebca4f3dcd
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpExpectationHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpExpectationHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpExpectationHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpExpectationHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpExpectationHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge>
internal class IVectorHttpExpectationHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpExpectationHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpExpectationHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpExpectationHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpExpectationHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpExpectationHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpExpectationHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValue
    internal typealias SwiftABI = IVectorHttpExpectationHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpExpectationHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpExpectationHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpExpectationHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpExpectationHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpExpectationHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpExpectationHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpExpectationHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpExpectationHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpExpectationHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpExpectationHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpExpectationHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xb6df6da2, Data2: 0x8d92, Data3: 0x5270, Data4: ( 0x95,0x84,0xd6,0xa9,0xa9,0x31,0x58,0x6d ))// b6df6da2-8d92-5270-9584-d6a9a931586d
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpLanguageRangeWithQualityHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpLanguageRangeWithQualityHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpLanguageRangeWithQualityHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpLanguageRangeWithQualityHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge>
internal class IVectorHttpLanguageRangeWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpLanguageRangeWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpLanguageRangeWithQualityHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpLanguageRangeWithQualityHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpLanguageRangeWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpLanguageRangeWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpLanguageRangeWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValue
    internal typealias SwiftABI = IVectorHttpLanguageRangeWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpLanguageRangeWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpLanguageRangeWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpLanguageRangeWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpLanguageRangeWithQualityHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpLanguageRangeWithQualityHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpLanguageRangeWithQualityHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpLanguageRangeWithQualityHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpLanguageRangeWithQualityHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpLanguageRangeWithQualityHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpLanguageRangeWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpLanguageRangeWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0xc18538f7, Data2: 0xc256, Data3: 0x5666, Data4: ( 0x88,0x68,0x22,0x25,0xaf,0x35,0x74,0xb6 ))// c18538f7-c256-5666-8868-2225af3574b6
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpMediaTypeWithQualityHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpMediaTypeWithQualityHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpMediaTypeWithQualityHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpMediaTypeWithQualityHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge>
internal class IVectorHttpMediaTypeWithQualityHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpMediaTypeWithQualityHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpMediaTypeWithQualityHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpMediaTypeWithQualityHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpMediaTypeWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpMediaTypeWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpMediaTypeWithQualityHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValue
    internal typealias SwiftABI = IVectorHttpMediaTypeWithQualityHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpMediaTypeWithQualityHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpMediaTypeWithQualityHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpMediaTypeWithQualityHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpMediaTypeWithQualityHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpMediaTypeWithQualityHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpMediaTypeWithQualityHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpMediaTypeWithQualityHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpMediaTypeWithQualityHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpMediaTypeWithQualityHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpMediaTypeWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpMediaTypeWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x2cf800d4, Data2: 0x35d0, Data3: 0x545c, Data4: ( 0xab,0x82,0xf6,0x79,0x3b,0xe7,0x4c,0xba ))// 2cf800d4-35d0-545c-ab82-f6793be74cba
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpNameValueHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpNameValueHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpNameValueHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpNameValueHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpNameValueHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge>
internal class IVectorHttpNameValueHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpNameValueHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpNameValueHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpNameValueHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpNameValueHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpNameValueHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpNameValueHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValue
    internal typealias SwiftABI = IVectorHttpNameValueHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpNameValueHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpNameValueHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpNameValueHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpNameValueHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpNameValueHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpNameValueHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpNameValueHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpNameValueHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpNameValueHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpNameValueHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpNameValueHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x69392060, Data2: 0x6c0f, Data3: 0x5de6, Data4: ( 0x8c,0xed,0xf1,0x4f,0xc1,0xb8,0x33,0x76 ))// 69392060-6c0f-5de6-8ced-f14fc1b83376
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpProductInfoHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpProductInfoHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpProductInfoHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpProductInfoHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpProductInfoHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge>
internal class IVectorHttpProductInfoHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpProductInfoHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpProductInfoHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpProductInfoHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpProductInfoHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpProductInfoHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpProductInfoHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValue
    internal typealias SwiftABI = IVectorHttpProductInfoHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpProductInfoHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpProductInfoHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpProductInfoHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpProductInfoHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpProductInfoHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpProductInfoHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpProductInfoHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpProductInfoHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpProductInfoHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpProductInfoHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpProductInfoHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue: WindowsFoundation.IID {
    .init(Data1: 0x38e72562, Data2: 0xe17c, Data3: 0x5d68, Data4: ( 0xaa,0xd1,0x8e,0x8a,0x86,0x0b,0x89,0x69 ))// 38e72562-e17c-5d68-aad1-8e8a860b8969
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.Headers.HttpTransferCodingHeaderValue>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpTransferCodingHeaderValue? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpTransferCodingHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpTransferCodingHeaderValue? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpTransferCodingHeaderValue? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge>
internal class IVectorHttpTransferCodingHeaderValue: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpTransferCodingHeaderValue? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpTransferCodingHeaderValue?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpTransferCodingHeaderValue?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpTransferCodingHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpTransferCodingHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpTransferCodingHeaderValue?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValue
    internal typealias SwiftABI = IVectorHttpTransferCodingHeaderValue
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpTransferCodingHeaderValue?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpTransferCodingHeaderValue?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHeaders__CHttpTransferCodingHeaderValueBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpTransferCodingHeaderValue? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpTransferCodingHeaderValue?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpTransferCodingHeaderValue?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpTransferCodingHeaderValue?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpTransferCodingHeaderValue?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpTransferCodingHeaderValue?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpTransferCodingHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpTransferCodingHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod: WindowsFoundation.IID {
    .init(Data1: 0x228a73a2, Data2: 0xa509, Data3: 0x5a78, Data4: ( 0xbd,0x7f,0xdb,0x94,0xba,0x0b,0xef,0x21 ))// 228a73a2-a509-5a78-bd7f-db94ba0bef21
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.Http.HttpMethod>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpMethod? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpMethod? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.HttpMethod? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.HttpMethod? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge>
internal class IVectorHttpMethod: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.HttpMethod? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.HttpMethod?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.HttpMethod?, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.HttpMethod?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.HttpMethod?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.HttpMethod?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethod
    internal typealias SwiftABI = IVectorHttpMethod
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.HttpMethod?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.HttpMethod?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CHttp__CHttpMethodBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.HttpMethod? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpMethod?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.HttpMethod?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.HttpMethod?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.HttpMethod?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.HttpMethod?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpMethod! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.HttpMethod?>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus: WindowsFoundation.IID {
    .init(Data1: 0x61bc06e3, Data2: 0xb752, Data3: 0x5b56, Data4: ( 0x83,0x74,0x3b,0x45,0xa2,0x14,0x69,0x3f ))// 61bc06e3-b752-5b56-8374-3b45a214693f
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.IID
        iids[3] = UWP.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Web.WebErrorStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.getView()
        let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.WebErrorStatus = $1
        var index: UInt32 = 0
        let result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.WebErrorStatus = $2
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        let value: UWP.WebErrorStatus = $2
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let value: UWP.WebErrorStatus = $1
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard let __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge>
internal class IVectorWebErrorStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus }

    internal func GetAtImpl(_ index: UInt32) throws -> UWP.WebErrorStatus {
        var result: __x_ABI_CWindows_CWeb_CWebErrorStatus = .init(0)
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal func get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal func GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.WebErrorStatus>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.unwrapFrom(abi: result)
    }

    internal func IndexOfImpl(_ value: UWP.WebErrorStatus, _ index: inout UInt32) throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

    internal func SetAtImpl(_ index: UInt32, _ value: UWP.WebErrorStatus) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, value))
        }
    }

    internal func InsertAtImpl(_ index: UInt32, _ value: UWP.WebErrorStatus) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, value))
        }
    }

    internal func RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal func AppendImpl(_ value: UWP.WebErrorStatus) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, value))
        }
    }

    internal func RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal func ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatus
    internal typealias SwiftABI = IVectorWebErrorStatus
    internal typealias SwiftProjection = WindowsFoundation.AnyIVector<UWP.WebErrorStatus>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusImpl : IVector, AbiInterfaceImpl {
    typealias T = UWP.WebErrorStatus
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Int { 0 }
    var endIndex: Int { Int(size) }
    func index(after i: Int) -> Int {
        i+1
    }

    func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    var count: Int { Int(size) }


    subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    func removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate func getAt(_ index: UInt32) -> UWP.WebErrorStatus {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate func getView() -> WindowsFoundation.AnyIVectorView<UWP.WebErrorStatus>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate func indexOf(_ value: UWP.WebErrorStatus, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate func setAt(_ index: UInt32, _ value: UWP.WebErrorStatus) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate func insertAt(_ index: UInt32, _ value: UWP.WebErrorStatus) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate func removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate func append(_ value: UWP.WebErrorStatus) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate func removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate func clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableWebErrorStatus! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate func first() -> WindowsFoundation.AnyIIterator<UWP.WebErrorStatus>? {
        try! _IIterable.FirstImpl()
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x24f981e5, Data2: 0xddca, Data3: 0x538d, Data4: ( 0xaa,0xda,0xa5,0x99,0x06,0x08,0x4c,0xf1 ))// 24f981e5-ddca-538d-aada-a59906084cf1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableVTable: __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: WindowsFoundation.AnyIObservableMap<String, Any?>? = UWP.__x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: ComPtr($1))
        let event: WindowsFoundation.AnyIMapChangedEventArgs<String>? = UWP.__x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, event)
        return S_OK
    }
)
typealias __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableBridge>
internal class MapChangedEventHandlerString_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectable }

    internal func InvokeImpl(_ sender: WindowsFoundation.AnyIObservableMap<String, Any?>?, _ event: WindowsFoundation.AnyIMapChangedEventArgs<String>?) throws {
        let senderWrapper = UWP.__x_ABI_C__FIObservableMap_2_HSTRING_IInspectableWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        let eventWrapper = UWP.__x_ABI_C__FIMapChangedEventArgs_1_HSTRINGWrapper(event)
        let _event = try! eventWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _event))
        }
    }

}

internal class __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.MapChangedEventHandler<String, Any?>
    internal typealias CABI = __x_ABI_C__FMapChangedEventHandler_2_HSTRING_IInspectable
    internal typealias SwiftABI = UWP.MapChangedEventHandlerString_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, event) in
            try! _default.InvokeImpl(sender, event)
        }
        return handler
    }
}
private var IID___x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack: WindowsFoundation.IID {
    .init(Data1: 0xbd1dc81c, Data2: 0x23c4, Data3: 0x5b4b, Data4: ( 0xac,0x38,0xc5,0xd3,0x4c,0xdf,0x34,0xe4 ))// bd1dc81c-23c4-5b4b-ac38-c5d34cdf34e4
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVTable: __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackVtbl = .init(
    QueryInterface: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.addRef($0) },
    Release: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: WindowsFoundation.AnyIObservableVector<UWP.TimedMetadataTrack?>? = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper.unwrapFrom(abi: ComPtr($1))
        let event: WindowsFoundation.AnyIVectorChangedEventArgs? = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, event)
        return S_OK
    }
)
typealias __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge>
internal class VectorChangedEventHandlerTimedMetadataTrack: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack }

    internal func InvokeImpl(_ sender: WindowsFoundation.AnyIObservableVector<UWP.TimedMetadataTrack?>?, _ event: WindowsFoundation.AnyIVectorChangedEventArgs?) throws {
        let senderWrapper = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        let eventWrapper = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper(event)
        let _event = try! eventWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _event))
        }
    }

}

internal class __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.VectorChangedEventHandler<UWP.TimedMetadataTrack?>
    internal typealias CABI = __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack
    internal typealias SwiftABI = UWP.VectorChangedEventHandlerTimedMetadataTrack

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, event) in
            try! _default.InvokeImpl(sender, event)
        }
        return handler
    }
}
private var IID___x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource: WindowsFoundation.IID {
    .init(Data1: 0xe12e6261, Data2: 0xb198, Data3: 0x56e0, Data4: ( 0x98,0x22,0xba,0x2d,0x3b,0xb6,0xf8,0xfe ))// e12e6261-b198-56e0-9822-ba2d3bb6f8fe
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVTable: __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceVtbl = .init(
    QueryInterface: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.addRef($0) },
    Release: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: WindowsFoundation.AnyIObservableVector<UWP.TimedTextSource?>? = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper.unwrapFrom(abi: ComPtr($1))
        let event: WindowsFoundation.AnyIVectorChangedEventArgs? = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, event)
        return S_OK
    }
)
typealias __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge>
internal class VectorChangedEventHandlerTimedTextSource: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource }

    internal func InvokeImpl(_ sender: WindowsFoundation.AnyIObservableVector<UWP.TimedTextSource?>?, _ event: WindowsFoundation.AnyIVectorChangedEventArgs?) throws {
        let senderWrapper = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        let eventWrapper = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper(event)
        let _event = try! eventWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _event))
        }
    }

}

internal class __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.VectorChangedEventHandler<UWP.TimedTextSource?>
    internal typealias CABI = __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CCore__CTimedTextSource
    internal typealias SwiftABI = UWP.VectorChangedEventHandlerTimedTextSource

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, event) in
            try! _default.InvokeImpl(sender, event)
        }
        return handler
    }
}
private var IID___x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem: WindowsFoundation.IID {
    .init(Data1: 0x891bddde, Data2: 0x6bf3, Data3: 0x5d1f, Data4: ( 0x80,0xab,0x5a,0x34,0x2a,0x16,0xa0,0xbb ))// 891bddde-6bf3-5d1f-80ab-5a342a16a0bb
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVTable: __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: WindowsFoundation.AnyIObservableVector<UWP.MediaPlaybackItem?>? = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper.unwrapFrom(abi: ComPtr($1))
        let event: WindowsFoundation.AnyIVectorChangedEventArgs? = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, event)
        return S_OK
    }
)
typealias __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge>
internal class VectorChangedEventHandlerMediaPlaybackItem: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem }

    internal func InvokeImpl(_ sender: WindowsFoundation.AnyIObservableVector<UWP.MediaPlaybackItem?>?, _ event: WindowsFoundation.AnyIVectorChangedEventArgs?) throws {
        let senderWrapper = UWP.__x_ABI_C__FIObservableVector_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        let eventWrapper = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper(event)
        let _event = try! eventWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _event))
        }
    }

}

internal class __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.VectorChangedEventHandler<UWP.MediaPlaybackItem?>
    internal typealias CABI = __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem
    internal typealias SwiftABI = UWP.VectorChangedEventHandlerMediaPlaybackItem

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, event) in
            try! _default.InvokeImpl(sender, event)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xc50898f6, Data2: 0xc536, Data3: 0x5f47, Data4: ( 0x85,0x83,0x8b,0x2c,0x24,0x38,0xa1,0x3b ))// c50898f6-c536-5f47-8583-8b2c2438a13b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIEventHandler_1_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1_IInspectableVTable: __x_ABI_C__FIEventHandler_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIEventHandler_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIEventHandler_1_IInspectableBridge>
internal class EventHandlerAny: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1_IInspectable }

    internal func InvokeImpl(_ sender: Any?, _ args: Any?) throws {
        let senderWrapper = __ABI_.AnyWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _args))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<Any?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1_IInspectable
    internal typealias SwiftABI = UWP.EventHandlerAny

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xdf4aac23, Data2: 0x4002, Data3: 0x5d4c, Data4: ( 0xa2,0x37,0x25,0x26,0xe3,0x44,0x97,0x8d ))// df4aac23-4002-5d4c-a237-2526e344978d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsVTable: __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        let args: UWP.ClipboardHistoryChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsBridge>
internal class EventHandlerClipboardHistoryChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgs }

    internal func InvokeImpl(_ sender: Any?, _ args: UWP.ClipboardHistoryChangedEventArgs?) throws {
        let senderWrapper = __ABI_.AnyWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<UWP.ClipboardHistoryChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryChangedEventArgs
    internal typealias SwiftABI = UWP.EventHandlerClipboardHistoryChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xc8bbcb29, Data2: 0x6b64, Data3: 0x5ce2, Data4: ( 0xa8,0x31,0x03,0x8f,0x6e,0x02,0x19,0x9e ))// c8bbcb29-6b64-5ce2-a831-038f6e02199e
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64VTable: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<String, UInt64>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: try! HString(result).detach())
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Bridge>
internal class IAsyncOperationWithProgressString_UInt64: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64 }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<String, UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<String, UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<String, UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<String, UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64
    internal typealias SwiftABI = IAsyncOperationWithProgressString_UInt64
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<String, UInt64>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Impl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = String
    typealias TProgress = UInt64
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING_UINT64Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> String {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<String, UInt64>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<String, UInt64>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x91ecbe45, Data2: 0xe889, Data3: 0x5518, Data4: ( 0xbd,0x8d,0xc5,0xbd,0xe1,0x63,0x10,0x9b ))// 91ecbe45-e889-5518-bd8d-c5bde163109b
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<String, Windows.Web.Http.HttpProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: try! HString(result).detach())
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class IAsyncOperationWithProgressString_HttpProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<String, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<String, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<String, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<String, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressString_HttpProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<String, UWP.HttpProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = String
    typealias TProgress = UWP.HttpProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2_HSTRING___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> String {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<String, UWP.HttpProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<String, UWP.HttpProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32: WindowsFoundation.IID {
    .init(Data1: 0xeccb574a, Data2: 0xc684, Data3: 0x5572, Data4: ( 0xa6,0x79,0x6b,0x08,0x42,0xcf,0xb5,0x7f ))// eccb574a-c684-5572-a679-6b0842cfb57f
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32VTable: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<UInt32, UInt32>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Bridge>
internal class IAsyncOperationWithProgressUInt32_UInt32: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32 }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UInt32, UInt32>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UInt32, UInt32>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT32_UINT32Wrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UInt32, UInt32>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UInt32, UInt32>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT32_UINT32Wrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32
    internal typealias SwiftABI = IAsyncOperationWithProgressUInt32_UInt32
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UInt32, UInt32>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Impl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UInt32
    typealias TProgress = UInt32
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UInt32 {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UInt32, UInt32>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UInt32, UInt32>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64: WindowsFoundation.IID {
    .init(Data1: 0x8f1db6e3, Data2: 0x6556, Data3: 0x5516, Data4: ( 0x82,0x5c,0x10,0x21,0xee,0x27,0xcd,0x0c ))// 8f1db6e3-6556-5516-825c-1021ee27cd0c
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64VTable: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<UInt64, UInt64>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Bridge>
internal class IAsyncOperationWithProgressUInt64_UInt64: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64 }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UInt64, UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UInt64, UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2_UINT64_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UInt64, UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UInt64, UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2_UINT64_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UInt64 {
        var result: UINT64 = 0
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64
    internal typealias SwiftABI = IAsyncOperationWithProgressUInt64_UInt64
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UInt64, UInt64>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Impl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UInt64
    typealias TProgress = UInt64
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UInt64 {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UInt64, UInt64>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UInt64, UInt64>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress: WindowsFoundation.IID {
    .init(Data1: 0x5a97aab7, Data2: 0xb6ea, Data3: 0x55ac, Data4: ( 0xa5,0xdc,0xd5,0xb1,0x64,0xd9,0x4e,0x94 ))// 5a97aab7-b6ea-55ac-a5dc-d5b164d94e94
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Management.Deployment.DeploymentResult, Windows.Management.Deployment.DeploymentProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressBridge>
internal class IAsyncOperationWithProgressDeploymentResult_DeploymentProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.DeploymentResult?, UWP.DeploymentProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.DeploymentResult?, UWP.DeploymentProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.DeploymentResult?, UWP.DeploymentProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.DeploymentResult?, UWP.DeploymentProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DeploymentResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressDeploymentResult_DeploymentProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DeploymentResult?, UWP.DeploymentProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.DeploymentResult?
    typealias TProgress = UWP.DeploymentProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CManagement__CDeployment__CDeploymentResult___x_ABI_CWindows__CManagement__CDeployment__CDeploymentProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.DeploymentResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.DeploymentResult?, UWP.DeploymentProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.DeploymentResult?, UWP.DeploymentProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation: WindowsFoundation.IID {
    .init(Data1: 0xe86a4f5d, Data2: 0x743a, Data3: 0x5f18, Data4: ( 0x9d,0x4c,0xbc,0x8e,0xd5,0x94,0x26,0x59 ))// e86a4f5d-743a-5f18-9d4c-bc8ed5942659
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Networking.BackgroundTransfer.DownloadOperation, Windows.Networking.BackgroundTransfer.DownloadOperation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationBridge>
internal class IAsyncOperationWithProgressDownloadOperation_DownloadOperation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.DownloadOperation?, UWP.DownloadOperation?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.DownloadOperation?, UWP.DownloadOperation?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.DownloadOperation?, UWP.DownloadOperation?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.DownloadOperation?, UWP.DownloadOperation?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DownloadOperation? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation
    internal typealias SwiftABI = IAsyncOperationWithProgressDownloadOperation_DownloadOperation
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.DownloadOperation?, UWP.DownloadOperation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.DownloadOperation?
    typealias TProgress = UWP.DownloadOperation?
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.DownloadOperation? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.DownloadOperation?, UWP.DownloadOperation?>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.DownloadOperation?, UWP.DownloadOperation?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32: WindowsFoundation.IID {
    .init(Data1: 0xd26b2819, Data2: 0x897f, Data3: 0x5c7d, Data4: ( 0x84,0xd6,0x56,0xd7,0x96,0x56,0x14,0x31 ))// d26b2819-897f-5c7d-84d6-56d796561431
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32VTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Storage.Streams.IBuffer, UInt32>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Bridge>
internal class IAsyncOperationWithProgressIBuffer_UInt32: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32 }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.AnyIBuffer?, UInt32>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.AnyIBuffer?, UInt32>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UInt32>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UInt32>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIBuffer? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32
    internal typealias SwiftABI = IAsyncOperationWithProgressIBuffer_UInt32
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt32>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Impl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIBuffer?
    typealias TProgress = UInt32
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.AnyIBuffer? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.AnyIBuffer?, UInt32>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UInt32>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64: WindowsFoundation.IID {
    .init(Data1: 0xad960e7f, Data2: 0xd73b, Data3: 0x56e4, Data4: ( 0xa5,0x8c,0x6e,0xc7,0x67,0x8c,0xfd,0x88 ))// ad960e7f-d73b-56e4-a58c-6ec7678cfd88
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64VTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Storage.Streams.IBuffer, UInt64>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Bridge>
internal class IAsyncOperationWithProgressIBuffer_UInt64: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64 }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.AnyIBuffer?, UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.AnyIBuffer?, UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIBuffer? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64
    internal typealias SwiftABI = IAsyncOperationWithProgressIBuffer_UInt64
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt64>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Impl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIBuffer?
    typealias TProgress = UInt64
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT64Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.AnyIBuffer? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.AnyIBuffer?, UInt64>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UInt64>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x88d9bb75, Data2: 0xafb4, Data3: 0x5f32, Data4: ( 0x9d,0x7e,0xd3,0xbf,0x37,0x85,0x35,0x4c ))// 88d9bb75-afb4-5f32-9d7e-d3bf3785354c
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Storage.Streams.IBuffer, Windows.Web.Http.HttpProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class IAsyncOperationWithProgressIBuffer_HttpProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.AnyIBuffer?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.AnyIBuffer?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIBuffer? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressIBuffer_HttpProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UWP.HttpProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIBuffer?
    typealias TProgress = UWP.HttpProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.AnyIBuffer? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.AnyIBuffer?, UWP.HttpProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.AnyIBuffer?, UWP.HttpProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64: WindowsFoundation.IID {
    .init(Data1: 0x455aa601, Data2: 0xf13e, Data3: 0x5dee, Data4: ( 0xb9,0xcb,0x16,0xb5,0x31,0x99,0x63,0x27 ))// 455aa601-f13e-5dee-b9cb-16b531996327
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64VTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Storage.Streams.IInputStream, UInt64>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Bridge>
internal class IAsyncOperationWithProgressIInputStream_UInt64: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64 }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.AnyIInputStream?, UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.AnyIInputStream?, UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.AnyIInputStream?, UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.AnyIInputStream?, UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIInputStream? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IInputStreamWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64
    internal typealias SwiftABI = IAsyncOperationWithProgressIInputStream_UInt64
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UInt64>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Impl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIInputStream?
    typealias TProgress = UInt64
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream_UINT64Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.AnyIInputStream? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.AnyIInputStream?, UInt64>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.AnyIInputStream?, UInt64>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x0b97c784, Data2: 0xdf17, Data3: 0x571f, Data4: ( 0x83,0x37,0x44,0x7d,0xff,0x06,0x8a,0x9c ))// 0b97c784-df17-571f-8337-447dff068a9c
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Storage.Streams.IInputStream, Windows.Web.Http.HttpProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class IAsyncOperationWithProgressIInputStream_HttpProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.AnyIInputStream?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.AnyIInputStream?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.AnyIInputStream?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.AnyIInputStream?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIInputStream? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IInputStreamWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressIInputStream_HttpProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIInputStream?, UWP.HttpProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIInputStream?
    typealias TProgress = UWP.HttpProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIInputStream___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.AnyIInputStream? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.AnyIInputStream?, UWP.HttpProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.AnyIInputStream?, UWP.HttpProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0xb128fbc4, Data2: 0x19c0, Data3: 0x5fe1, Data4: ( 0xae,0xc6,0xd2,0xe6,0x4b,0xd2,0x28,0x62 ))// b128fbc4-19c0-5fe1-aec6-d2e64bd22862
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Web.Http.HttpGetBufferResult, Windows.Web.Http.HttpProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class IAsyncOperationWithProgressHttpGetBufferResult_HttpProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.HttpGetBufferResult?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.HttpGetBufferResult?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.HttpGetBufferResult?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.HttpGetBufferResult?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.HttpGetBufferResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressHttpGetBufferResult_HttpProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetBufferResult?, UWP.HttpProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.HttpGetBufferResult?
    typealias TProgress = UWP.HttpProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetBufferResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.HttpGetBufferResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.HttpGetBufferResult?, UWP.HttpProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.HttpGetBufferResult?, UWP.HttpProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x6e1ce5ac, Data2: 0xc10b, Data3: 0x5d09, Data4: ( 0xad,0x43,0xf4,0xdd,0xea,0xda,0x85,0x7a ))// 6e1ce5ac-c10b-5d09-ad43-f4ddeada857a
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Web.Http.HttpGetInputStreamResult, Windows.Web.Http.HttpProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class IAsyncOperationWithProgressHttpGetInputStreamResult_HttpProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.HttpGetInputStreamResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressHttpGetInputStreamResult_HttpProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.HttpGetInputStreamResult?
    typealias TProgress = UWP.HttpProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetInputStreamResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.HttpGetInputStreamResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.HttpGetInputStreamResult?, UWP.HttpProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x7382f299, Data2: 0xbbbd, Data3: 0x5bd3, Data4: ( 0xb1,0x43,0x88,0x87,0xc6,0x27,0x92,0x9b ))// 7382f299-bbbd-5bd3-b143-8887c627929b
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Web.Http.HttpGetStringResult, Windows.Web.Http.HttpProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class IAsyncOperationWithProgressHttpGetStringResult_HttpProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.HttpGetStringResult?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.HttpGetStringResult?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.HttpGetStringResult?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.HttpGetStringResult?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.HttpGetStringResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressHttpGetStringResult_HttpProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpGetStringResult?, UWP.HttpProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.HttpGetStringResult?
    typealias TProgress = UWP.HttpProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpGetStringResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.HttpGetStringResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.HttpGetStringResult?, UWP.HttpProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.HttpGetStringResult?, UWP.HttpProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x97388336, Data2: 0x2eac, Data3: 0x5d76, Data4: ( 0xb2,0x28,0xd3,0x2e,0xf9,0xa3,0x81,0x75 ))// 97388336-2eac-5d76-b228-d32ef9a38175
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Web.Http.HttpRequestResult, Windows.Web.Http.HttpProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class IAsyncOperationWithProgressHttpRequestResult_HttpProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.HttpRequestResult?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.HttpRequestResult?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.HttpRequestResult?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.HttpRequestResult?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.HttpRequestResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressHttpRequestResult_HttpProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpRequestResult?, UWP.HttpProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.HttpRequestResult?
    typealias TProgress = UWP.HttpProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpRequestResult___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.HttpRequestResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.HttpRequestResult?, UWP.HttpProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.HttpRequestResult?, UWP.HttpProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress: WindowsFoundation.IID {
    .init(Data1: 0x5d144364, Data2: 0x77d7, Data3: 0x5eca, Data4: ( 0x8b,0x09,0x93,0x6a,0x69,0x44,0x66,0x52 ))// 5d144364-77d7-5eca-8b09-936a69446652
}

internal var __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.progress = handler
        return S_OK
    },

    get_Progress: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.progress
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge>
internal class IAsyncOperationWithProgressHttpResponseMessage_HttpProgress: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress }

    internal func put_ProgressImpl(_ handler: AsyncOperationProgressHandler<UWP.HttpResponseMessage?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Progress(pThis, _handler))
        }
    }

    internal func get_ProgressImpl() throws -> AsyncOperationProgressHandler<UWP.HttpResponseMessage?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Progress(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationProgressHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func put_CompletedImpl(_ handler: AsyncOperationWithProgressCompletedHandler<UWP.HttpResponseMessage?, UWP.HttpProgress>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationWithProgressCompletedHandler<UWP.HttpResponseMessage?, UWP.HttpProgress>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationWithProgressCompletedHandler_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.HttpResponseMessage? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgress
    internal typealias SwiftABI = IAsyncOperationWithProgressHttpResponseMessage_HttpProgress
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.HttpResponseMessage?, UWP.HttpProgress>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressImpl : IAsyncOperationWithProgress, AbiInterfaceImpl {
    typealias TResult = UWP.HttpResponseMessage?
    typealias TProgress = UWP.HttpProgress
    typealias Bridge = __x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CWeb__CHttp__CHttpResponseMessage___x_ABI_CWindows__CWeb__CHttp__CHttpProgressBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.getresults)
    fileprivate func getResults() throws -> UWP.HttpResponseMessage? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.progress)
    fileprivate var progress : AsyncOperationProgressHandler<UWP.HttpResponseMessage?, UWP.HttpProgress>? {
        get { try! _default.get_ProgressImpl() }
        set { try! _default.put_ProgressImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.completed)
    fileprivate var completed : AsyncOperationWithProgressCompletedHandler<UWP.HttpResponseMessage?, UWP.HttpProgress>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperationwithprogress-2.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xabf53c57, Data2: 0xee50, Data3: 0x5342, Data4: ( 0xb5,0x2a,0x26,0xe3,0xb8,0xcc,0x02,0x4f ))// abf53c57-ee50-5342-b52a-26e3b8cc024f
}

internal var __x_ABI_C__FIAsyncOperation_1_IInspectableVTable: __x_ABI_C__FIAsyncOperation_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_.AnyWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1_IInspectableBridge>
internal class IAsyncOperationAny: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1_IInspectable }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<Any?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<Any?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> Any? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1_IInspectable
    internal typealias SwiftABI = IAsyncOperationAny
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<Any?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1_IInspectableImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = Any?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> Any? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<Any?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1_boolean: WindowsFoundation.IID {
    .init(Data1: 0xcdb5efb3, Data2: 0x5788, Data3: 0x509d, Data4: ( 0x9b,0xe1,0x71,0xcc,0xb8,0xa3,0x36,0x2a ))// cdb5efb3-5788-509d-9be1-71ccb8a3362a
}

internal var __x_ABI_C__FIAsyncOperation_1_booleanVTable: __x_ABI_C__FIAsyncOperation_1_booleanVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1_booleanWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1_booleanWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1_booleanWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Bool>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: .init(from: result))
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1_booleanWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1_booleanBridge>
internal class IAsyncOperationBool: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1_boolean }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<Bool>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_boolean.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<Bool>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_boolean.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> Bool {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_boolean.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1_booleanBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1_boolean
    internal typealias SwiftABI = IAsyncOperationBool
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<Bool>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1_booleanImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1_booleanVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1_booleanImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = Bool
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1_booleanBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> Bool {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<Bool>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x3e1fe603, Data2: 0xf897, Data3: 0x5263, Data4: ( 0xb3,0x28,0x08,0x06,0x42,0x6b,0x8a,0x79 ))// 3e1fe603-f897-5263-b328-0806426b8a79
}

internal var __x_ABI_C__FIAsyncOperation_1_HSTRINGVTable: __x_ABI_C__FIAsyncOperation_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: try! HString(result).detach())
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1_HSTRINGBridge>
internal class IAsyncOperationString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1_HSTRING }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<String>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1_HSTRING
    internal typealias SwiftABI = IAsyncOperationString
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<String>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1_HSTRINGImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = String
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> String {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<String>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1_UINT32: WindowsFoundation.IID {
    .init(Data1: 0xef60385f, Data2: 0xbe78, Data3: 0x584b, Data4: ( 0xaa,0xef,0x78,0x29,0xad,0xa2,0xb0,0xde ))// ef60385f-be78-584b-aaef-7829ada2b0de
}

internal var __x_ABI_C__FIAsyncOperation_1_UINT32VTable: __x_ABI_C__FIAsyncOperation_1_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1_UINT32Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1_UINT32Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<UInt32>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1_UINT32Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1_UINT32Bridge>
internal class IAsyncOperationUInt32: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1_UINT32 }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UInt32>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UInt32>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_UINT32.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT32Wrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_UINT32.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1_UINT32Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1_UINT32
    internal typealias SwiftABI = IAsyncOperationUInt32
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UInt32>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1_UINT32Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1_UINT32VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1_UINT32Impl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UInt32
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1_UINT32Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UInt32 {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UInt32>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1_UINT64: WindowsFoundation.IID {
    .init(Data1: 0x2a70d630, Data2: 0x0767, Data3: 0x5f0a, Data4: ( 0xa1,0xc2,0xde,0xb0,0x81,0x26,0xe2,0x6e ))// 2a70d630-0767-5f0a-a1c2-deb08126e26e
}

internal var __x_ABI_C__FIAsyncOperation_1_UINT64VTable: __x_ABI_C__FIAsyncOperation_1_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1_UINT64Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1_UINT64Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<UInt64>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1_UINT64Wrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1_UINT64Bridge>
internal class IAsyncOperationUInt64: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1_UINT64 }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UInt64>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UInt64>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_UINT64.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1_UINT64Wrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UInt64 {
        var result: UINT64 = 0
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_UINT64.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1_UINT64Bridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1_UINT64
    internal typealias SwiftABI = IAsyncOperationUInt64
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UInt64>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1_UINT64Impl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1_UINT64VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1_UINT64Impl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UInt64
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1_UINT64Bridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UInt64 {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UInt64>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult: WindowsFoundation.IID {
    .init(Data1: 0x677b06b8, Data2: 0x0134, Data3: 0x5692, Data4: ( 0xb4,0x87,0x4c,0x8e,0x24,0x08,0xca,0x01 ))// 677b06b8-0134-5692-b487-4c8e2408ca01
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.ApplicationModel.DataTransfer.ClipboardHistoryItemsResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultBridge>
internal class IAsyncOperationClipboardHistoryItemsResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.ClipboardHistoryItemsResult?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.ClipboardHistoryItemsResult?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.ClipboardHistoryItemsResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResult
    internal typealias SwiftABI = IAsyncOperationClipboardHistoryItemsResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.ClipboardHistoryItemsResult?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.ClipboardHistoryItemsResult?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CClipboardHistoryItemsResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.ClipboardHistoryItemsResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.ClipboardHistoryItemsResult?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation: WindowsFoundation.IID {
    .init(Data1: 0x8b98aea9, Data2: 0x64f0, Data3: 0x5672, Data4: ( 0xb3,0x0e,0xdf,0xd9,0xc2,0xe4,0xf6,0xfe ))// 8b98aea9-64f0-5672-b30e-dfd9c2e4f6fe
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.ApplicationModel.DataTransfer.DataPackageOperation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge>
internal class IAsyncOperationDataPackageOperation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.DataPackageOperation>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.DataPackageOperation>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DataPackageOperation {
        var result: __x_ABI_CWindows_CApplicationModel_CDataTransfer_CDataPackageOperation = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation
    internal typealias SwiftABI = IAsyncOperationDataPackageOperation
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.DataPackageOperation>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.DataPackageOperation
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.DataPackageOperation {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.DataPackageOperation>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup: WindowsFoundation.IID {
    .init(Data1: 0xbbd292e3, Data2: 0xdb9f, Data3: 0x5802, Data4: ( 0xa4,0x88,0x40,0xf1,0x56,0x33,0x2c,0x04 ))// bbd292e3-db9f-5802-a488-40f156332c04
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.ApplicationModel.PackageContentGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge>
internal class IAsyncOperationPackageContentGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.PackageContentGroup?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.PackageContentGroup?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.PackageContentGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup
    internal typealias SwiftABI = IAsyncOperationPackageContentGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.PackageContentGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.PackageContentGroup?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.PackageContentGroup? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.PackageContentGroup?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult: WindowsFoundation.IID {
    .init(Data1: 0x010bd015, Data2: 0x43ef, Data3: 0x576c, Data4: ( 0xbe,0x1e,0xbc,0x38,0xc5,0xb6,0xb6,0x6b ))// 010bd015-43ef-576c-be1e-bc38c5b6b66b
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.ApplicationModel.PackageUpdateAvailabilityResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultBridge>
internal class IAsyncOperationPackageUpdateAvailabilityResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.PackageUpdateAvailabilityResult?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.PackageUpdateAvailabilityResult?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.PackageUpdateAvailabilityResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResult
    internal typealias SwiftABI = IAsyncOperationPackageUpdateAvailabilityResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.PackageUpdateAvailabilityResult?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.PackageUpdateAvailabilityResult?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CPackageUpdateAvailabilityResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.PackageUpdateAvailabilityResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.PackageUpdateAvailabilityResult?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation: WindowsFoundation.IID {
    .init(Data1: 0x07faa053, Data2: 0xeb2f, Data3: 0x5cba, Data4: ( 0xb2,0x5b,0xd9,0xd5,0x7b,0xe6,0x71,0x5f ))// 07faa053-eb2f-5cba-b25b-d9d57be6715f
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Devices.Enumeration.DeviceInformation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge>
internal class IAsyncOperationDeviceInformation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.DeviceInformation?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.DeviceInformation?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DeviceInformation? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation
    internal typealias SwiftABI = IAsyncOperationDeviceInformation
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.DeviceInformation?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.DeviceInformation?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.DeviceInformation? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.DeviceInformation?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection: WindowsFoundation.IID {
    .init(Data1: 0x45180254, Data2: 0x082e, Data3: 0x5274, Data4: ( 0xb2,0xe7,0xac,0x05,0x17,0xf4,0x4d,0x07 ))// 45180254-082e-5274-b2e7-ac0517f44d07
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Devices.Enumeration.DeviceInformationCollection>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionBridge>
internal class IAsyncOperationDeviceInformationCollection: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.DeviceInformationCollection?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.DeviceInformationCollection?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DeviceInformationCollection? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollection
    internal typealias SwiftABI = IAsyncOperationDeviceInformationCollection
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.DeviceInformationCollection?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.DeviceInformationCollection?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCollectionBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.DeviceInformationCollection? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.DeviceInformationCollection?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult: WindowsFoundation.IID {
    .init(Data1: 0x1002db74, Data2: 0x8948, Data3: 0x591e, Data4: ( 0x81,0x5d,0xe4,0x0b,0x66,0x75,0x99,0xa3 ))// 1002db74-8948-591e-815d-e40b667599a3
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Devices.Enumeration.DevicePairingResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultBridge>
internal class IAsyncOperationDevicePairingResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.DevicePairingResult?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.DevicePairingResult?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DevicePairingResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResult
    internal typealias SwiftABI = IAsyncOperationDevicePairingResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.DevicePairingResult?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.DevicePairingResult?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.DevicePairingResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.DevicePairingResult?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail: WindowsFoundation.IID {
    .init(Data1: 0xbac083a3, Data2: 0x3a19, Data3: 0x5072, Data4: ( 0x9d,0x90,0x13,0x33,0x23,0xa0,0x49,0xba ))// bac083a3-3a19-5072-9d90-133323a049ba
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Devices.Enumeration.DeviceThumbnail>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailBridge>
internal class IAsyncOperationDeviceThumbnail: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.DeviceThumbnail?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.DeviceThumbnail?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DeviceThumbnail? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnail
    internal typealias SwiftABI = IAsyncOperationDeviceThumbnail
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.DeviceThumbnail?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.DeviceThumbnail?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceThumbnailBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.DeviceThumbnail? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.DeviceThumbnail?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult: WindowsFoundation.IID {
    .init(Data1: 0x2bb4df3d, Data2: 0xbd7e, Data3: 0x5fe0, Data4: ( 0x90,0x20,0x56,0xdc,0x0d,0x30,0xb9,0x35 ))// 2bb4df3d-bd7e-5fe0-9020-56dc0d30b935
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Devices.Enumeration.DeviceUnpairingResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultBridge>
internal class IAsyncOperationDeviceUnpairingResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.DeviceUnpairingResult?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.DeviceUnpairingResult?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DeviceUnpairingResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResult
    internal typealias SwiftABI = IAsyncOperationDeviceUnpairingResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.DeviceUnpairingResult?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.DeviceUnpairingResult?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceUnpairingResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.DeviceUnpairingResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.DeviceUnpairingResult?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0xfc012d44, Data2: 0x2dcf, Data3: 0x5162, Data4: ( 0xbe,0x9a,0x76,0x68,0x67,0x5a,0xa5,0x90 ))// fc012d44-2dcf-5162-be9a-7668675aa590
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IMapView`2<String, Windows.Storage.Streams.RandomAccessStreamReference>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class IAsyncOperationIMapViewString_RandomAccessStreamReference: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = IAsyncOperationIMapViewString_RandomAccessStreamReference
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMapView_2_HSTRING___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIMapView<String, UWP.RandomAccessStreamReference?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x127e39c7, Data2: 0x07c1, Data3: 0x58e5, Data4: ( 0xb4,0x8e,0x3a,0x47,0x29,0x83,0x9f,0xec ))// 127e39c7-07c1-58e5-b48e-3a4729839fec
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IMap`2<String, Any>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableBridge>
internal class IAsyncOperationIMapString_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectable }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIMap<String, Any?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIMap<String, Any?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIMap<String, Any?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectable.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIMap_2_HSTRING_IInspectableWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectable
    internal typealias SwiftABI = IAsyncOperationIMapString_Any
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIMap<String, Any?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIMap<String, Any?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIMap_2_HSTRING_IInspectableBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIMap<String, Any?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIMap<String, Any?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySet: WindowsFoundation.IID {
    .init(Data1: 0x490b0686, Data2: 0xafd7, Data3: 0x5037, Data4: ( 0x96,0x47,0xd8,0xfe,0x24,0x8f,0x18,0x2c ))// 490b0686-afd7-5037-9647-d8fe248f182c
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IPropertySet>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Foundation_Collections.IPropertySetWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetBridge>
internal class IAsyncOperationIPropertySet: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySet }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIPropertySet?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySet.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIPropertySet?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySet.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__F__CIPropertySetWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIPropertySet? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySet.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Foundation_Collections.IPropertySetWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySet
    internal typealias SwiftABI = IAsyncOperationIPropertySet
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIPropertySet?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIPropertySet?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__F__CIPropertySetBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIPropertySet? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIPropertySet?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x2f92b529, Data2: 0x119b, Data3: 0x575a, Data4: ( 0xa4,0x19,0x39,0x04,0xb4,0xe4,0x1a,0xf2 ))// 2f92b529-119b-575a-a419-3904b4e41af2
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<String>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1_HSTRINGWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGBridge>
internal class IAsyncOperationIVectorViewString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<String>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<String>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<String>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING
    internal typealias SwiftABI = IAsyncOperationIVectorViewString
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<String>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<String>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<String>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<String>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo: WindowsFoundation.IID {
    .init(Data1: 0x07543d91, Data2: 0x8610, Data3: 0x5152, Data4: ( 0xb0,0xe4,0x43,0xd6,0xe4,0xcd,0xd0,0xcb ))// 07543d91-8610-5152-b0e4-43d6e4cdd0cb
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.ApplicationModel.AppInfo>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge>
internal class IAsyncOperationIVectorViewAppInfo: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AppInfo?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AppInfo?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.AppInfo?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfo
    internal typealias SwiftABI = IAsyncOperationIVectorViewAppInfo
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AppInfo?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.AppInfo?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CAppInfoBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.AppInfo?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AppInfo?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry: WindowsFoundation.IID {
    .init(Data1: 0xd3bcf8a0, Data2: 0x3538, Data3: 0x5dae, Data4: ( 0x98,0xd7,0x1f,0x2a,0xb8,0x8c,0x3f,0x01 ))// d3bcf8a0-3538-5dae-98d7-1f2ab88c3f01
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.ApplicationModel.Core.AppListEntry>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge>
internal class IAsyncOperationIVectorViewAppListEntry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntry
    internal typealias SwiftABI = IAsyncOperationIVectorViewAppListEntry
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CApplicationModel__CCore__CAppListEntryBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume: WindowsFoundation.IID {
    .init(Data1: 0x1e357e07, Data2: 0xd337, Data3: 0x5c07, Data4: ( 0xae,0x06,0x90,0x0c,0x1b,0x9a,0x77,0xc1 ))// 1e357e07-d337-5c07-ae06-900c1b9a77c1
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Management.Deployment.PackageVolume>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge>
internal class IAsyncOperationIVectorViewPackageVolume: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume
    internal typealias SwiftABI = IAsyncOperationIVectorViewPackageVolume
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.PackageVolume?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup: WindowsFoundation.IID {
    .init(Data1: 0xa795889f, Data2: 0x6d49, Data3: 0x5687, Data4: ( 0xaa,0xbe,0xf2,0xfc,0x62,0x37,0xfa,0x1a ))// a795889f-6d49-5687-aabe-f2fc6237fa1a
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Media.Capture.Frames.MediaFrameSourceGroup>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge>
internal class IAsyncOperationIVectorViewMediaFrameSourceGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup
    internal typealias SwiftABI = IAsyncOperationIVectorViewMediaFrameSourceGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.MediaFrameSourceGroup?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0x9d8a4113, Data2: 0xe7f3, Data3: 0x552d, Data4: ( 0x9a,0x8c,0x1c,0x25,0xe2,0x13,0x72,0x53 ))// 9d8a4113-e7f3-552d-9a8c-1c25e2137253
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Networking.Connectivity.AttributedNetworkUsage>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge>
internal class IAsyncOperationIVectorViewAttributedNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsage
    internal typealias SwiftABI = IAsyncOperationIVectorViewAttributedNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CAttributedNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AttributedNetworkUsage?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval: WindowsFoundation.IID {
    .init(Data1: 0xaf96d70b, Data2: 0x41c7, Data3: 0x5dc6, Data4: ( 0x98,0x95,0xea,0x04,0x3a,0x88,0x5d,0x8d ))// af96d70b-41c7-5dc6-9895-ea043a885d8d
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Networking.Connectivity.ConnectivityInterval>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge>
internal class IAsyncOperationIVectorViewConnectivityInterval: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityInterval
    internal typealias SwiftABI = IAsyncOperationIVectorViewConnectivityInterval
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectivityIntervalBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.ConnectivityInterval?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0x05c9e081, Data2: 0x6229, Data3: 0x5049, Data4: ( 0x8e,0xea,0xa4,0x98,0x40,0x7c,0x00,0xd5 ))// 05c9e081-6229-5049-8eea-a498407c00d5
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Networking.Connectivity.NetworkUsage>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge>
internal class IAsyncOperationIVectorViewNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsage
    internal typealias SwiftABI = IAsyncOperationIVectorViewNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.NetworkUsage?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage: WindowsFoundation.IID {
    .init(Data1: 0x7eba5a8f, Data2: 0xe4fd, Data3: 0x5201, Data4: ( 0xa4,0xf4,0x95,0x67,0x59,0x6f,0x21,0x3c ))// 7eba5a8f-e4fd-5201-a4f4-9567596f213c
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Networking.Connectivity.ProviderNetworkUsage>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge>
internal class IAsyncOperationIVectorViewProviderNetworkUsage: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsage
    internal typealias SwiftABI = IAsyncOperationIVectorViewProviderNetworkUsage
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CNetworking__CConnectivity__CProviderNetworkUsageBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.ProviderNetworkUsage?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0x4b1c0fd7, Data2: 0x7a01, Data3: 0x5e7a, Data4: ( 0xa6,0xfe,0xbe,0x45,0x00,0x28,0x3f,0x23 ))// 4b1c0fd7-7a01-5e7a-a6fe-be4500283f23
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Storage.IStorageItem>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemBridge>
internal class IAsyncOperationIVectorViewIStorageItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItem
    internal typealias SwiftABI = IAsyncOperationIVectorViewIStorageItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile: WindowsFoundation.IID {
    .init(Data1: 0x03362e33, Data2: 0xe413, Data3: 0x5f29, Data4: ( 0x97,0xd0,0x48,0xa4,0x78,0x09,0x35,0xf9 ))// 03362e33-e413-5f29-97d0-48a4780935f9
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Storage.StorageFile>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileBridge>
internal class IAsyncOperationIVectorViewStorageFile: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.StorageFile?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile
    internal typealias SwiftABI = IAsyncOperationIVectorViewStorageFile
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.StorageFile?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder: WindowsFoundation.IID {
    .init(Data1: 0xca40b21b, Data2: 0xaeb1, Data3: 0x5a61, Data4: ( 0x9e,0x08,0x3b,0xd5,0xd9,0x59,0x40,0x23 ))// ca40b21b-aeb1-5a61-9e08-3bd5d9594023
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Storage.StorageFolder>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderBridge>
internal class IAsyncOperationIVectorViewStorageFolder: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolder
    internal typealias SwiftABI = IAsyncOperationIVectorViewStorageFolder
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange: WindowsFoundation.IID {
    .init(Data1: 0x66e11b8a, Data2: 0x9003, Data3: 0x52c9, Data4: ( 0x84,0xa8,0xae,0x5c,0xce,0xbe,0x8c,0xf9 ))// 66e11b8a-9003-52c9-84a8-ae5ccebe8cf9
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Storage.StorageLibraryChange>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge>
internal class IAsyncOperationIVectorViewStorageLibraryChange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChange
    internal typealias SwiftABI = IAsyncOperationIVectorViewStorageLibraryChange
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser: WindowsFoundation.IID {
    .init(Data1: 0xe44ea1df, Data2: 0xbb85, Data3: 0x5a8c, Data4: ( 0xbd,0xdc,0xc8,0xe9,0x60,0xc3,0x55,0xc9 ))// e44ea1df-bb85-5a8c-bddc-c8e960c355c9
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.System.User>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserBridge>
internal class IAsyncOperationIVectorViewUser: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.User?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.User?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<UWP.User?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUser
    internal typealias SwiftABI = IAsyncOperationIVectorViewUser
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.User?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<UWP.User?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CSystem__CUserBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVectorView<UWP.User?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<UWP.User?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup: WindowsFoundation.IID {
    .init(Data1: 0x929e3c29, Data2: 0xbf29, Data3: 0x5594, Data4: ( 0xbc,0x63,0x67,0xdb,0x43,0xa5,0x39,0xea ))// 929e3c29-bf29-5594-bc63-67db43a539ea
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVector`1<Windows.ApplicationModel.PackageContentGroup>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge>
internal class IAsyncOperationIVectorPackageContentGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroup
    internal typealias SwiftABI = IAsyncOperationIVectorPackageContentGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVector_1___x_ABI_CWindows__CApplicationModel__CPackageContentGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVector<UWP.PackageContentGroup?>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUri: WindowsFoundation.IID {
    .init(Data1: 0x641cb9dd, Data2: 0xa28d, Data3: 0x59e2, Data4: ( 0xb8,0xdb,0xa2,0x27,0xed,0xa6,0xcf,0x2e ))// 641cb9dd-a28d-59e2-b8db-a227eda6cf2e
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Uri>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriBridge>
internal class IAsyncOperationUri: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUri }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.Uri?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUri.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.Uri?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUri.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CFoundation__CUriWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> WindowsFoundation.Uri? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUri.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUri
    internal typealias SwiftABI = IAsyncOperationUri
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.Uri?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.Uri?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CFoundation__CUriBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> WindowsFoundation.Uri? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.Uri?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder: WindowsFoundation.IID {
    .init(Data1: 0xaa94d8e9, Data2: 0xcaef, Data3: 0x53f6, Data4: ( 0x82,0x3d,0x91,0xb6,0xe8,0x34,0x05,0x10 ))// aa94d8e9-caef-53f6-823d-91b6e8340510
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Graphics.Imaging.BitmapDecoder>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderBridge>
internal class IAsyncOperationBitmapDecoder: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.BitmapDecoder?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.BitmapDecoder?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.BitmapDecoder? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoder
    internal typealias SwiftABI = IAsyncOperationBitmapDecoder
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.BitmapDecoder?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.BitmapDecoder?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapDecoderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.BitmapDecoder? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.BitmapDecoder?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder: WindowsFoundation.IID {
    .init(Data1: 0x151bd1c5, Data2: 0x4675, Data3: 0x5af5, Data4: ( 0xa2,0x89,0x00,0x1e,0xdc,0x66,0xb8,0x6a ))// 151bd1c5-4675-5af5-a289-001edc66b86a
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Graphics.Imaging.BitmapEncoder>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderBridge>
internal class IAsyncOperationBitmapEncoder: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.BitmapEncoder?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.BitmapEncoder?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.BitmapEncoder? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoder
    internal typealias SwiftABI = IAsyncOperationBitmapEncoder
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.BitmapEncoder?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.BitmapEncoder?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapEncoderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.BitmapEncoder? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.BitmapEncoder?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame: WindowsFoundation.IID {
    .init(Data1: 0xcb1483d1, Data2: 0x1464, Data3: 0x5bf9, Data4: ( 0x93,0x46,0xd5,0x37,0x73,0x5d,0xfb,0xd6 ))// cb1483d1-1464-5bf9-9346-d537735dfbd6
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Graphics.Imaging.BitmapFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameBridge>
internal class IAsyncOperationBitmapFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.BitmapFrame?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.BitmapFrame?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.BitmapFrame? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrame
    internal typealias SwiftABI = IAsyncOperationBitmapFrame
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.BitmapFrame?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.BitmapFrame?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapFrameBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.BitmapFrame? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.BitmapFrame?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet: WindowsFoundation.IID {
    .init(Data1: 0x464ac000, Data2: 0xb1f1, Data3: 0x5246, Data4: ( 0x82,0x68,0x91,0x2a,0x25,0x93,0xd8,0x89 ))// 464ac000-b1f1-5246-8268-912a2593d889
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Graphics.Imaging.BitmapPropertySet>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetBridge>
internal class IAsyncOperationBitmapPropertySet: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.BitmapPropertySet?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.BitmapPropertySet?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.BitmapPropertySet? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySet
    internal typealias SwiftABI = IAsyncOperationBitmapPropertySet
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.BitmapPropertySet?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.BitmapPropertySet?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CBitmapPropertySetBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.BitmapPropertySet? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.BitmapPropertySet?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream: WindowsFoundation.IID {
    .init(Data1: 0x684165be, Data2: 0x0011, Data3: 0x56d6, Data4: ( 0xbe,0xbf,0x43,0x00,0x16,0xd5,0x1b,0x7a ))// 684165be-0011-56d6-bebf-430016d51b7a
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Graphics.Imaging.ImageStream>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamBridge>
internal class IAsyncOperationImageStream: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.ImageStream?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.ImageStream?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.ImageStream? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStream
    internal typealias SwiftABI = IAsyncOperationImageStream
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.ImageStream?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.ImageStream?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CImageStreamBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.ImageStream? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.ImageStream?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider: WindowsFoundation.IID {
    .init(Data1: 0x8c2dfeb0, Data2: 0x6c22, Data3: 0x5863, Data4: ( 0x88,0xd8,0x85,0xc1,0xfb,0xc7,0x56,0x97 ))// 8c2dfeb0-6c22-5863-88d8-85c1fbc75697
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Graphics.Imaging.PixelDataProvider>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderBridge>
internal class IAsyncOperationPixelDataProvider: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.PixelDataProvider?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.PixelDataProvider?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.PixelDataProvider? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProvider
    internal typealias SwiftABI = IAsyncOperationPixelDataProvider
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.PixelDataProvider?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.PixelDataProvider?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CPixelDataProviderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.PixelDataProvider? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.PixelDataProvider?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap: WindowsFoundation.IID {
    .init(Data1: 0xc4a10980, Data2: 0x714b, Data3: 0x5501, Data4: ( 0x8d,0xa2,0xdb,0xda,0xcc,0xe7,0x0f,0x73 ))// c4a10980-714b-5501-8da2-dbdacce70f73
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Graphics.Imaging.SoftwareBitmap>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapBridge>
internal class IAsyncOperationSoftwareBitmap: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.SoftwareBitmap?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.SoftwareBitmap?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.SoftwareBitmap? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmap
    internal typealias SwiftABI = IAsyncOperationSoftwareBitmap
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.SoftwareBitmap?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.SoftwareBitmap?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CGraphics__CImaging__CSoftwareBitmapBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.SoftwareBitmap? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.SoftwareBitmap?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume: WindowsFoundation.IID {
    .init(Data1: 0x0315edb6, Data2: 0xdc58, Data3: 0x51cc, Data4: ( 0xa5,0x19,0x44,0x90,0x1a,0xd2,0xcf,0x15 ))// 0315edb6-dc58-51cc-a519-44901ad2cf15
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Management.Deployment.PackageVolume>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge>
internal class IAsyncOperationPackageVolume: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.PackageVolume?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.PackageVolume?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.PackageVolume? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolume
    internal typealias SwiftABI = IAsyncOperationPackageVolume
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.PackageVolume?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.PackageVolume?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CManagement__CDeployment__CPackageVolumeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.PackageVolume? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.PackageVolume?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult: WindowsFoundation.IID {
    .init(Data1: 0x80003979, Data2: 0x4986, Data3: 0x52a7, Data4: ( 0xb2,0x27,0xae,0x6b,0xe4,0xd2,0xb5,0xcd ))// 80003979-4986-52a7-b227-ae6be4d2b5cd
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Media.Capture.Frames.MediaFrameSourceGetPropertyResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultBridge>
internal class IAsyncOperationMediaFrameSourceGetPropertyResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.MediaFrameSourceGetPropertyResult?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.MediaFrameSourceGetPropertyResult?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.MediaFrameSourceGetPropertyResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResult
    internal typealias SwiftABI = IAsyncOperationMediaFrameSourceGetPropertyResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceGetPropertyResult?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.MediaFrameSourceGetPropertyResult?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGetPropertyResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.MediaFrameSourceGetPropertyResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.MediaFrameSourceGetPropertyResult?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup: WindowsFoundation.IID {
    .init(Data1: 0xf3256a87, Data2: 0xb1cf, Data3: 0x5943, Data4: ( 0xb6,0x64,0x9f,0x19,0x36,0x7d,0x27,0x79 ))// f3256a87-b1cf-5943-b664-9f19367d2779
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Media.Capture.Frames.MediaFrameSourceGroup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge>
internal class IAsyncOperationMediaFrameSourceGroup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.MediaFrameSourceGroup?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.MediaFrameSourceGroup?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.MediaFrameSourceGroup? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroup
    internal typealias SwiftABI = IAsyncOperationMediaFrameSourceGroup
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceGroup?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.MediaFrameSourceGroup?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceGroupBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.MediaFrameSourceGroup? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.MediaFrameSourceGroup?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus: WindowsFoundation.IID {
    .init(Data1: 0xa1507c16, Data2: 0x5f84, Data3: 0x586e, Data4: ( 0x8c,0xa9,0x22,0x4f,0x37,0xe0,0xe0,0xde ))// a1507c16-5f84-586e-8ca9-224f37e0e0de
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Media.Capture.Frames.MediaFrameSourceSetPropertyStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusBridge>
internal class IAsyncOperationMediaFrameSourceSetPropertyStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.MediaFrameSourceSetPropertyStatus>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.MediaFrameSourceSetPropertyStatus>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.MediaFrameSourceSetPropertyStatus {
        var result: __x_ABI_CWindows_CMedia_CCapture_CFrames_CMediaFrameSourceSetPropertyStatus = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatus
    internal typealias SwiftABI = IAsyncOperationMediaFrameSourceSetPropertyStatus
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.MediaFrameSourceSetPropertyStatus>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.MediaFrameSourceSetPropertyStatus
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSourceSetPropertyStatusBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.MediaFrameSourceSetPropertyStatus {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.MediaFrameSourceSetPropertyStatus>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample: WindowsFoundation.IID {
    .init(Data1: 0x3cdc5e86, Data2: 0x4ada, Data3: 0x5ef7, Data4: ( 0x96,0x7a,0xe1,0x37,0xa4,0x62,0x19,0x07 ))// 3cdc5e86-4ada-5ef7-967a-e137a4621907
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Media.Core.MediaStreamSample>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleBridge>
internal class IAsyncOperationMediaStreamSample: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.MediaStreamSample?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.MediaStreamSample?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.MediaStreamSample? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample
    internal typealias SwiftABI = IAsyncOperationMediaStreamSample
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.MediaStreamSample?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.MediaStreamSample?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CCore__CMediaStreamSampleBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.MediaStreamSample? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.MediaStreamSample?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult: WindowsFoundation.IID {
    .init(Data1: 0xbe0bcc1d, Data2: 0xd606, Data3: 0x59d2, Data4: ( 0xb2,0xf9,0xff,0x20,0x45,0x43,0xda,0x12 ))// be0bcc1d-d606-59d2-b2f9-ff204543da12
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultBridge>
internal class IAsyncOperationAdaptiveMediaSourceCreationResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.AdaptiveMediaSourceCreationResult?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.AdaptiveMediaSourceCreationResult?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AdaptiveMediaSourceCreationResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResult
    internal typealias SwiftABI = IAsyncOperationAdaptiveMediaSourceCreationResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.AdaptiveMediaSourceCreationResult?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.AdaptiveMediaSourceCreationResult?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceCreationResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.AdaptiveMediaSourceCreationResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.AdaptiveMediaSourceCreationResult?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile: WindowsFoundation.IID {
    .init(Data1: 0x5bf519ca, Data2: 0x8adb, Data3: 0x5ab5, Data4: ( 0xab,0xb8,0xff,0x1b,0xbe,0x5d,0x2d,0xe8 ))// 5bf519ca-8adb-5ab5-abb8-ff1bbe5d2de8
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Networking.Connectivity.ConnectionProfile>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileBridge>
internal class IAsyncOperationConnectionProfile: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.ConnectionProfile?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.ConnectionProfile?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.ConnectionProfile? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfile
    internal typealias SwiftABI = IAsyncOperationConnectionProfile
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.ConnectionProfile?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.ConnectionProfile?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.ConnectionProfile? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.ConnectionProfile?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus: WindowsFoundation.IID {
    .init(Data1: 0x2ffebc9e, Data2: 0x4bed, Data3: 0x5f3d, Data4: ( 0x8e,0x55,0x5a,0xbc,0x25,0x98,0xe1,0x44 ))// 2ffebc9e-4bed-5f3d-8e55-5abc2598e144
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Networking.Connectivity.ConnectionProfileDeleteStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusBridge>
internal class IAsyncOperationConnectionProfileDeleteStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.ConnectionProfileDeleteStatus>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.ConnectionProfileDeleteStatus>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.ConnectionProfileDeleteStatus {
        var result: __x_ABI_CWindows_CNetworking_CConnectivity_CConnectionProfileDeleteStatus = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatus
    internal typealias SwiftABI = IAsyncOperationConnectionProfileDeleteStatus
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.ConnectionProfileDeleteStatus>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.ConnectionProfileDeleteStatus
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CNetworking__CConnectivity__CConnectionProfileDeleteStatusBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.ConnectionProfileDeleteStatus {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.ConnectionProfileDeleteStatus>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain: WindowsFoundation.IID {
    .init(Data1: 0xf618c7d4, Data2: 0xaee1, Data3: 0x58ae, Data4: ( 0xaf,0xe8,0xfc,0x33,0x6d,0xaf,0x03,0x95 ))// f618c7d4-aee1-58ae-afe8-fc336daf0395
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Security.Cryptography.Certificates.CertificateChain>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainBridge>
internal class IAsyncOperationCertificateChain: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.CertificateChain?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.CertificateChain?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.CertificateChain? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChain
    internal typealias SwiftABI = IAsyncOperationCertificateChain
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.CertificateChain?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.CertificateChain?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CCryptography__CCertificates__CCertificateChainBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.CertificateChain? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.CertificateChain?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult: WindowsFoundation.IID {
    .init(Data1: 0xe8d81715, Data2: 0xc56c, Data3: 0x5a6b, Data4: ( 0xb7,0x38,0x5d,0xf6,0xc2,0x77,0x5b,0x7b ))// e8d81715-c56c-5a6b-b738-5df6c2775b7b
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultBridge>
internal class IAsyncOperationProtectionPolicyEvaluationResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.ProtectionPolicyEvaluationResult>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.ProtectionPolicyEvaluationResult>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.ProtectionPolicyEvaluationResult {
        var result: __x_ABI_CWindows_CSecurity_CEnterpriseData_CProtectionPolicyEvaluationResult = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResult
    internal typealias SwiftABI = IAsyncOperationProtectionPolicyEvaluationResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.ProtectionPolicyEvaluationResult>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.ProtectionPolicyEvaluationResult
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSecurity__CEnterpriseData__CProtectionPolicyEvaluationResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.ProtectionPolicyEvaluationResult {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.ProtectionPolicyEvaluationResult>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties: WindowsFoundation.IID {
    .init(Data1: 0x5186131a, Data2: 0x4467, Data3: 0x504b, Data4: ( 0x97,0x7a,0x07,0x85,0xa8,0x23,0x04,0x85 ))// 5186131a-4467-504b-977a-0785a8230485
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.FileProperties.BasicProperties>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesBridge>
internal class IAsyncOperationBasicProperties: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.BasicProperties?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.BasicProperties?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.BasicProperties? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicProperties
    internal typealias SwiftABI = IAsyncOperationBasicProperties
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.BasicProperties?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.BasicProperties?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.BasicProperties? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.BasicProperties?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties: WindowsFoundation.IID {
    .init(Data1: 0x6c86e97c, Data2: 0x5699, Data3: 0x5700, Data4: ( 0x8d,0x35,0xd3,0x50,0xad,0x3e,0x4d,0xf2 ))// 6c86e97c-5699-5700-8d35-d350ad3e4df2
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.FileProperties.DocumentProperties>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesBridge>
internal class IAsyncOperationDocumentProperties: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.DocumentProperties?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.DocumentProperties?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.DocumentProperties? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentProperties
    internal typealias SwiftABI = IAsyncOperationDocumentProperties
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.DocumentProperties?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.DocumentProperties?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CDocumentPropertiesBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.DocumentProperties? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.DocumentProperties?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties: WindowsFoundation.IID {
    .init(Data1: 0xfcd07511, Data2: 0xe7f8, Data3: 0x5bda, Data4: ( 0x8c,0x04,0x79,0x5a,0x63,0x9d,0xae,0x8f ))// fcd07511-e7f8-5bda-8c04-795a639dae8f
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.FileProperties.ImageProperties>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesBridge>
internal class IAsyncOperationImageProperties: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.ImageProperties?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.ImageProperties?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.ImageProperties? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImageProperties
    internal typealias SwiftABI = IAsyncOperationImageProperties
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.ImageProperties?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.ImageProperties?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CImagePropertiesBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.ImageProperties? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.ImageProperties?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties: WindowsFoundation.IID {
    .init(Data1: 0x0d023b76, Data2: 0x20a7, Data3: 0x56f3, Data4: ( 0x84,0xab,0xce,0x31,0xe6,0x54,0x4b,0x71 ))// 0d023b76-20a7-56f3-84ab-ce31e6544b71
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.FileProperties.MusicProperties>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesBridge>
internal class IAsyncOperationMusicProperties: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.MusicProperties?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.MusicProperties?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.MusicProperties? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicProperties
    internal typealias SwiftABI = IAsyncOperationMusicProperties
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.MusicProperties?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.MusicProperties?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CMusicPropertiesBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.MusicProperties? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.MusicProperties?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail: WindowsFoundation.IID {
    .init(Data1: 0x11c7cc5e, Data2: 0xc04e, Data3: 0x50e7, Data4: ( 0xa6,0x5e,0x6f,0x69,0x03,0x69,0x0c,0x16 ))// 11c7cc5e-c04e-50e7-a65e-6f6903690c16
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.FileProperties.StorageItemThumbnail>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailBridge>
internal class IAsyncOperationStorageItemThumbnail: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.StorageItemThumbnail?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.StorageItemThumbnail?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.StorageItemThumbnail? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnail
    internal typealias SwiftABI = IAsyncOperationStorageItemThumbnail
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.StorageItemThumbnail?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.StorageItemThumbnail? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.StorageItemThumbnail?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties: WindowsFoundation.IID {
    .init(Data1: 0x447d4590, Data2: 0xd3f9, Data3: 0x58bf, Data4: ( 0xac,0x58,0x6f,0x9a,0x50,0x83,0x9e,0xfe ))// 447d4590-d3f9-58bf-ac58-6f9a50839efe
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.FileProperties.VideoProperties>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesBridge>
internal class IAsyncOperationVideoProperties: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.VideoProperties?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.VideoProperties?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.VideoProperties? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoProperties
    internal typealias SwiftABI = IAsyncOperationVideoProperties
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.VideoProperties?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.VideoProperties?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CVideoPropertiesBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.VideoProperties? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.VideoProperties?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0x5fc9c137, Data2: 0xebb7, Data3: 0x5e6c, Data4: ( 0x9c,0xba,0x68,0x6f,0x2e,0xc2,0xb0,0xbb ))// 5fc9c137-ebb7-5e6c-9cba-686f2ec2b0bb
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.IStorageItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage.IStorageItemWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemBridge>
internal class IAsyncOperationIStorageItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItem }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.AnyIStorageItem?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.AnyIStorageItem?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIStorageItem? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItem
    internal typealias SwiftABI = IAsyncOperationIStorageItem
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.AnyIStorageItem?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIStorageItem?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.AnyIStorageItem? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.AnyIStorageItem?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState: WindowsFoundation.IID {
    .init(Data1: 0x88694b1f, Data2: 0xf380, Data3: 0x574d, Data4: ( 0x8a,0x05,0x4f,0x67,0xbd,0x52,0xcd,0x11 ))// 88694b1f-f380-574d-8a05-4f67bd52cd11
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.Search.IndexedState>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateBridge>
internal class IAsyncOperationIndexedState: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.IndexedState>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.IndexedState>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.IndexedState {
        var result: __x_ABI_CWindows_CStorage_CSearch_CIndexedState = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedState
    internal typealias SwiftABI = IAsyncOperationIndexedState
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.IndexedState>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.IndexedState
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CSearch__CIndexedStateBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.IndexedState {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.IndexedState>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFile: WindowsFoundation.IID {
    .init(Data1: 0x5e52f8ce, Data2: 0xaced, Data3: 0x5a42, Data4: ( 0x95,0xb4,0xf6,0x74,0xdd,0x84,0x88,0x5e ))// 5e52f8ce-aced-5a42-95b4-f674dd84885e
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.StorageFile>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileBridge>
internal class IAsyncOperationStorageFile: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFile }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.StorageFile?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.StorageFile?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.StorageFile? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFile
    internal typealias SwiftABI = IAsyncOperationStorageFile
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.StorageFile?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.StorageFile? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.StorageFile?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolder: WindowsFoundation.IID {
    .init(Data1: 0x6be9e7d7, Data2: 0xe83a, Data3: 0x5cbc, Data4: ( 0x80,0x2c,0x17,0x68,0x96,0x0b,0x52,0xc3 ))// 6be9e7d7-e83a-5cbc-802c-1768960b52c3
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.StorageFolder>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderBridge>
internal class IAsyncOperationStorageFolder: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolder }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.StorageFolder?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.StorageFolder?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.StorageFolder? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolder.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolder
    internal typealias SwiftABI = IAsyncOperationStorageFolder
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.StorageFolder?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.StorageFolder? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.StorageFolder?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction: WindowsFoundation.IID {
    .init(Data1: 0x0d81405a, Data2: 0x9bd3, Data3: 0x5e87, Data4: ( 0x82,0xf4,0x9b,0x41,0x28,0xa8,0x87,0xeb ))// 0d81405a-9bd3-5e87-82f4-9b4128a887eb
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.StorageStreamTransaction>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionBridge>
internal class IAsyncOperationStorageStreamTransaction: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.StorageStreamTransaction?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.StorageStreamTransaction?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.StorageStreamTransaction? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransaction
    internal typealias SwiftABI = IAsyncOperationStorageStreamTransaction
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.StorageStreamTransaction?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.StorageStreamTransaction? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.StorageStreamTransaction?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer: WindowsFoundation.IID {
    .init(Data1: 0x3bee8834, Data2: 0xb9a7, Data3: 0x5a80, Data4: ( 0xa7,0x46,0x5e,0xf0,0x97,0x22,0x78,0x78 ))// 3bee8834-b9a7-5a80-a746-5ef097227878
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.Streams.IBuffer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge>
internal class IAsyncOperationIBuffer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.AnyIBuffer?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.AnyIBuffer?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIBuffer? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer
    internal typealias SwiftABI = IAsyncOperationIBuffer
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.AnyIBuffer?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIBuffer?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.AnyIBuffer? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.AnyIBuffer?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream: WindowsFoundation.IID {
    .init(Data1: 0xa8fe0732, Data2: 0x556d, Data3: 0x5841, Data4: ( 0xb7,0xee,0xb3,0x45,0x0f,0xb5,0x26,0x66 ))// a8fe0732-556d-5841-b7ee-b3450fb52666
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.Streams.IInputStream>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamBridge>
internal class IAsyncOperationIInputStream: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.AnyIInputStream?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.AnyIInputStream?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIInputStream? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IInputStreamWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStream
    internal typealias SwiftABI = IAsyncOperationIInputStream
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.AnyIInputStream?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIInputStream?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.AnyIInputStream? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.AnyIInputStream?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream: WindowsFoundation.IID {
    .init(Data1: 0x430ecece, Data2: 0x1418, Data3: 0x5d19, Data4: ( 0x81,0xb2,0x5d,0xdb,0x38,0x16,0x03,0xcc ))// 430ecece-1418-5d19-81b2-5ddb381603cc
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.Streams.IRandomAccessStream>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamBridge>
internal class IAsyncOperationIRandomAccessStream: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStream?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStream?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIRandomAccessStream? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStream
    internal typealias SwiftABI = IAsyncOperationIRandomAccessStream
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIRandomAccessStream?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.AnyIRandomAccessStream? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStream?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0x65178d50, Data2: 0xe6a2, Data3: 0x5d16, Data4: ( 0xb2,0x44,0x65,0xe9,0x72,0x5e,0x5a,0x0c ))// 65178d50-e6a2-5d16-b244-65e9725e5a0c
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.Streams.IRandomAccessStreamReference>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceBridge>
internal class IAsyncOperationIRandomAccessStreamReference: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStreamReference?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStreamReference?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIRandomAccessStreamReference? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReference
    internal typealias SwiftABI = IAsyncOperationIRandomAccessStreamReference
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStreamReference?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIRandomAccessStreamReference?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamReferenceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.AnyIRandomAccessStreamReference? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStreamReference?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType: WindowsFoundation.IID {
    .init(Data1: 0xc4a57c5e, Data2: 0x32b0, Data3: 0x55b3, Data4: ( 0xad,0x13,0xce,0x1c,0x23,0x04,0x1e,0xd6 ))// c4a57c5e-32b0-55b3-ad13-ce1c23041ed6
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.Streams.IRandomAccessStreamWithContentType>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            let resultWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeBridge>
internal class IAsyncOperationIRandomAccessStreamWithContentType: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStreamWithContentType?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStreamWithContentType?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.AnyIRandomAccessStreamWithContentType? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentType
    internal typealias SwiftABI = IAsyncOperationIRandomAccessStreamWithContentType
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStreamWithContentType?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIRandomAccessStreamWithContentType?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.AnyIRandomAccessStreamWithContentType? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.AnyIRandomAccessStreamWithContentType?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0xd90442ca, Data2: 0x543c, Data3: 0x504b, Data4: ( 0x9e,0xb9,0x29,0x4b,0xca,0xd8,0xa2,0x83 ))// d90442ca-543c-504b-9eb9-294bcad8a283
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.Streams.RandomAccessStreamReference>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge>
internal class IAsyncOperationRandomAccessStreamReference: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.RandomAccessStreamReference?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.RandomAccessStreamReference?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.RandomAccessStreamReference? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReference
    internal typealias SwiftABI = IAsyncOperationRandomAccessStreamReference
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.RandomAccessStreamReference?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.RandomAccessStreamReference?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CRandomAccessStreamReferenceBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.RandomAccessStreamReference? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.RandomAccessStreamReference?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus: WindowsFoundation.IID {
    .init(Data1: 0xe7539992, Data2: 0x2220, Data3: 0x5d2d, Data4: ( 0x82,0xc4,0x3d,0x44,0xf8,0x75,0x0d,0x91 ))// e7539992-2220-5d2d-82c4-3d44f8750d91
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.System.LaunchQuerySupportStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusBridge>
internal class IAsyncOperationLaunchQuerySupportStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.LaunchQuerySupportStatus>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.LaunchQuerySupportStatus>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.LaunchQuerySupportStatus {
        var result: __x_ABI_CWindows_CSystem_CLaunchQuerySupportStatus = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatus
    internal typealias SwiftABI = IAsyncOperationLaunchQuerySupportStatus
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.LaunchQuerySupportStatus>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.LaunchQuerySupportStatus
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchQuerySupportStatusBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.LaunchQuerySupportStatus {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.LaunchQuerySupportStatus>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResult: WindowsFoundation.IID {
    .init(Data1: 0x7f97fc15, Data2: 0x1cd6, Data3: 0x54b7, Data4: ( 0xa2,0x90,0xac,0xb6,0x0d,0xba,0x81,0xa1 ))// 7f97fc15-1cd6-54b7-a290-acb60dba81a1
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.System.LaunchUriResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultBridge>
internal class IAsyncOperationLaunchUriResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResult }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.LaunchUriResult?>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResult.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.LaunchUriResult?>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriResultWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.LaunchUriResult? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResult.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResult
    internal typealias SwiftABI = IAsyncOperationLaunchUriResult
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.LaunchUriResult?>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.LaunchUriResult?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriResultBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.LaunchUriResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.LaunchUriResult?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatus: WindowsFoundation.IID {
    .init(Data1: 0xab3d721b, Data2: 0xa4f3, Data3: 0x5861, Data4: ( 0xb0,0x34,0x03,0x0b,0x15,0x23,0x3c,0x52 ))// ab3d721b-a4f3-5861-b034-030b15233c52
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.System.LaunchUriStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard let handler = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance.completed
        let resultWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard let __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusBridge>
internal class IAsyncOperationLaunchUriStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatus }

    internal func put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.LaunchUriStatus>?) throws {
        let handlerWrapper = UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper(handler)
        let _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal func get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.LaunchUriStatus>? {
        let (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatus.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return UWP.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CSystem__CLaunchUriStatusWrapper.unwrapFrom(abi: result)
    }

    internal func GetResultsImpl() throws -> UWP.LaunchUriStatus {
        var result: __x_ABI_CWindows_CSystem_CLaunchUriStatus = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatus.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatus
    internal typealias SwiftABI = IAsyncOperationLaunchUriStatus
    internal typealias SwiftProjection = WindowsFoundation.AnyIAsyncOperation<UWP.LaunchUriStatus>
    internal static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let abi = abi else { return nil }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusImpl(abi)
    }

    internal static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.LaunchUriStatus
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CSystem__CLaunchUriStatusBridge
    let _default: Bridge.SwiftABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.SwiftABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate func getResults() throws -> UWP.LaunchUriStatus {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.LaunchUriStatus>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate func cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate func close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { nil }
}

private var IID___x_ABI_C__FIReference_1_boolean: WindowsFoundation.IID {
    .init(Data1: 0x3c00fd60, Data2: 0x2950, Data3: 0x5939, Data4: ( 0xa2,0x1a,0x2d,0x12,0xc5,0xa0,0x1b,0x8a ))// 3c00fd60-2950-5939-a21a-2d12c5a01b8a
}

internal enum __x_ABI_C__FIReference_1_booleanBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_boolean
    typealias SwiftProjection = Bool
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_boolean }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: boolean = 0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .init(from: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_booleanVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_booleanVTable: __x_ABI_C__FIReference_1_booleanVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_booleanWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_booleanWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_booleanWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1_booleanWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Bool>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .init(from: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_booleanWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1_booleanBridge>
private var IID___x_ABI_C__FIReference_1_double: WindowsFoundation.IID {
    .init(Data1: 0x2f2d6c29, Data2: 0x5473, Data3: 0x5f3e, Data4: ( 0x92,0xe7,0x96,0x57,0x2b,0xb9,0x90,0xe2 ))// 2f2d6c29-5473-5f3e-92e7-96572bb990e2
}

internal enum __x_ABI_C__FIReference_1_doubleBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_double
    typealias SwiftProjection = Double
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_double }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: DOUBLE = 0.0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_doubleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_doubleVTable: __x_ABI_C__FIReference_1_doubleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_doubleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_doubleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_doubleWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1_doubleWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Double>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_doubleWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1_doubleBridge>
private var IID___x_ABI_C__FIReference_1_float: WindowsFoundation.IID {
    .init(Data1: 0x719cc2ba, Data2: 0x3e76, Data3: 0x5def, Data4: ( 0x9f,0x1a,0x38,0xd8,0x5a,0x14,0x5e,0xa8 ))// 719cc2ba-3e76-5def-9f1a-38d85a145ea8
}

internal enum __x_ABI_C__FIReference_1_floatBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_float
    typealias SwiftProjection = Float
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_float }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: FLOAT = 0.0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_floatVTable: __x_ABI_C__FIReference_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_floatWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1_floatWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_floatWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1_floatBridge>
private var IID___x_ABI_C__FIReference_1_GUID: WindowsFoundation.IID {
    .init(Data1: 0x7d50f649, Data2: 0x632c, Data3: 0x51f9, Data4: ( 0x84,0x9a,0xee,0x49,0x42,0x89,0x33,0xea ))// 7d50f649-632c-51f9-849a-ee49428933ea
}

internal enum __x_ABI_C__FIReference_1_GUIDBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_GUID
    typealias SwiftProjection = Foundation.UUID
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_GUID }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: WindowsFoundation.GUID = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .init(from: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_GUIDVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_GUIDVTable: __x_ABI_C__FIReference_1_GUIDVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_GUIDWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_GUIDWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_GUIDWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1_GUIDWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Foundation.UUID>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1_GUIDWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .init(from: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_GUIDWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1_GUIDBridge>
private var IID___x_ABI_C__FIReference_1_int: WindowsFoundation.IID {
    .init(Data1: 0x548cefbd, Data2: 0xbc8a, Data3: 0x5fa0, Data4: ( 0x8d,0xf2,0x95,0x74,0x40,0xfc,0x8b,0xf4 ))// 548cefbd-bc8a-5fa0-8df2-957440fc8bf4
}

internal enum __x_ABI_C__FIReference_1_intBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_int
    typealias SwiftProjection = Int32
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_int }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: INT32 = 0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_intVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_intVTable: __x_ABI_C__FIReference_1_intVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_intWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_intWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_intWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1_intWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Int32>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1_intWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_intWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1_intBridge>
private var IID___x_ABI_C__FIReference_1_UINT32: WindowsFoundation.IID {
    .init(Data1: 0x513ef3af, Data2: 0xe784, Data3: 0x5325, Data4: ( 0xa9,0x1e,0x97,0xc2,0xb8,0x11,0x1c,0xf3 ))// 513ef3af-e784-5325-a91e-97c2b8111cf3
}

internal enum __x_ABI_C__FIReference_1_UINT32Bridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_UINT32
    typealias SwiftProjection = UInt32
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_UINT32 }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: UINT32 = 0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_UINT32VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_UINT32VTable: __x_ABI_C__FIReference_1_UINT32Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_UINT32Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_UINT32Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_UINT32Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1_UINT32Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<UInt32>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1_UINT32Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_UINT32Wrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1_UINT32Bridge>
private var IID___x_ABI_C__FIReference_1_UINT64: WindowsFoundation.IID {
    .init(Data1: 0x6755e376, Data2: 0x53bb, Data3: 0x568b, Data4: ( 0xa1,0x1d,0x17,0x23,0x98,0x68,0x30,0x9e ))// 6755e376-53bb-568b-a11d-17239868309e
}

internal enum __x_ABI_C__FIReference_1_UINT64Bridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_UINT64
    typealias SwiftProjection = UInt64
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_UINT64 }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: UINT64 = 0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_UINT64VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_UINT64VTable: __x_ABI_C__FIReference_1_UINT64Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_UINT64Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_UINT64Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_UINT64Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1_UINT64Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<UInt64>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1_UINT64Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_UINT64Wrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1_UINT64Bridge>
private var IID___x_ABI_C__FIReference_1_byte: WindowsFoundation.IID {
    .init(Data1: 0xe5198cc8, Data2: 0x2873, Data3: 0x55f5, Data4: ( 0xb0,0xa1,0x84,0xff,0x9e,0x4a,0xad,0x62 ))// e5198cc8-2873-55f5-b0a1-84ff9e4aad62
}

internal enum __x_ABI_C__FIReference_1_byteBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_byte
    typealias SwiftProjection = UInt8
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_byte }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: UINT8 = 0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_byteVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_byteVTable: __x_ABI_C__FIReference_1_byteVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_byteWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_byteWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_byteWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1_byteWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<UInt8>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1_byteWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_byteWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1_byteBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTime: WindowsFoundation.IID {
    .init(Data1: 0x5541d8a7, Data2: 0x497c, Data3: 0x5aa4, Data4: ( 0x86,0xfc,0x77,0x13,0xad,0xbf,0x2a,0x2c ))// 5541d8a7-497c-5aa4-86fc-7713adbf2a2c
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTime
    typealias SwiftProjection = WindowsFoundation.DateTime
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTime }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CFoundation_CDateTime = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.DateTime>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4: WindowsFoundation.IID {
    .init(Data1: 0xdacbffdc, Data2: 0x68ef, Data3: 0x5fd0, Data4: ( 0xb6,0x57,0x78,0x2d,0x0a,0xc9,0x80,0x7e ))// dacbffdc-68ef-5fd0-b657-782d0ac9807e
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Bridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4
    typealias SwiftProjection = WindowsFoundation.Matrix4x4
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4 }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CFoundation_CNumerics_CMatrix4x4 = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4VTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.Numerics.Matrix4x4>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Wrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CMatrix4x4Bridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2: WindowsFoundation.IID {
    .init(Data1: 0x48f6a69e, Data2: 0x8465, Data3: 0x57ae, Data4: ( 0x94,0x00,0x97,0x64,0x08,0x7f,0x65,0xad ))// 48f6a69e-8465-57ae-9400-9764087f65ad
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Bridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2
    typealias SwiftProjection = WindowsFoundation.Vector2
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2 }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CFoundation_CNumerics_CVector2 = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2VTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.Numerics.Vector2>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Bridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3: WindowsFoundation.IID {
    .init(Data1: 0x1ee770ff, Data2: 0xc954, Data3: 0x59ca, Data4: ( 0xa7,0x54,0x61,0x99,0xa9,0xbe,0x28,0x2c ))// 1ee770ff-c954-59ca-a754-6199a9be282c
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Bridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3
    typealias SwiftProjection = WindowsFoundation.Vector3
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3 }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CFoundation_CNumerics_CVector3 = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3VTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Wrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.Numerics.Vector3>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Wrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector3Bridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPoint: WindowsFoundation.IID {
    .init(Data1: 0x84f14c22, Data2: 0xa00a, Data3: 0x5272, Data4: ( 0x8d,0x3d,0x82,0x11,0x2e,0x66,0xdf,0x00 ))// 84f14c22-a00a-5272-8d3d-82112e66df00
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPoint
    typealias SwiftProjection = WindowsFoundation.Point
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPoint }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CFoundation_CPoint = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.Point>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRect: WindowsFoundation.IID {
    .init(Data1: 0x80423f11, Data2: 0x054f, Data3: 0x5eac, Data4: ( 0xaf,0xd3,0x63,0xb6,0xce,0x15,0xe7,0x7b ))// 80423f11-054f-5eac-afd3-63b6ce15e77b
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRect
    typealias SwiftProjection = WindowsFoundation.Rect
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRect }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CFoundation_CRect = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.Rect>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpan: WindowsFoundation.IID {
    .init(Data1: 0x604d0c4c, Data2: 0x91de, Data3: 0x5c2a, Data4: ( 0x93,0x5f,0x36,0x2f,0x13,0xea,0xf8,0x00 ))// 604d0c4c-91de-5c2a-935f-362f13eaf800
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpan
    typealias SwiftProjection = WindowsFoundation.TimeSpan
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpan }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CFoundation_CTimeSpan = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange: WindowsFoundation.IID {
    .init(Data1: 0x2fffd101, Data2: 0x16f8, Data3: 0x596d, Data4: ( 0xa8,0x8e,0x65,0x9b,0x6f,0x58,0x46,0x41 ))// 2fffd101-16f8-596d-a88e-659b6f584641
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange
    typealias SwiftProjection = UWP.MseTimeRange
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRange }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CMedia_CCore_CMseTimeRange = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Media.Core.MseTimeRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CCore__CMseTimeRangeBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance: WindowsFoundation.IID {
    .init(Data1: 0xb0060b8a, Data2: 0x1105, Data3: 0x5ad4, Data4: ( 0x96,0x3d,0xf6,0xcf,0x19,0x05,0xd3,0x49 ))// b0060b8a-1105-5ad4-963d-f6cf1905d349
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance
    typealias SwiftProjection = UWP.ManualFocusDistance
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistance }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CMedia_CDevices_CManualFocusDistance = .init(0)
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Media.Devices.ManualFocusDistance>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CDevices__CManualFocusDistanceBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceType: WindowsFoundation.IID {
    .init(Data1: 0x74c8c3aa, Data2: 0xde03, Data3: 0x5bf0, Data4: ( 0xaa,0xe8,0xaa,0x8b,0x69,0x20,0x66,0xb3 ))// 74c8c3aa-de03-5bf0-aae8-aa8b692066b3
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceType
    typealias SwiftProjection = UWP.AdaptiveMediaSourceResourceType
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceType }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CMedia_CStreaming_CAdaptive_CAdaptiveMediaSourceResourceType = .init(0)
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceResourceTypeBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColor: WindowsFoundation.IID {
    .init(Data1: 0xab8e5d11, Data2: 0xb0c1, Data3: 0x5a21, Data4: ( 0x95,0xae,0xf1,0x6b,0xf3,0xa3,0x76,0x24 ))// ab8e5d11-b0c1-5a21-95ae-f16bf3a37624
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColor
    typealias SwiftProjection = UWP.Color
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColor }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CUI_CColor = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.UI.Color>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatus: WindowsFoundation.IID {
    .init(Data1: 0xf2b26336, Data2: 0x6a9d, Data3: 0x54de, Data4: ( 0x8e,0xca,0x00,0xd6,0xc8,0x71,0xe4,0x69 ))// f2b26336-6a9d-54de-8eca-00d6c871e469
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatus
    typealias SwiftProjection = UWP.WebErrorStatus
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatus }

    static func from(abi: ComPtr<CABI>?) -> SwiftProjection? {
        guard let val = abi else { return nil }
        var result: __x_ABI_CWindows_CWeb_CWebErrorStatus = .init(0)
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.release($0) },
    GetIids: {
        let size = MemoryLayout<WindowsFoundation.IID>.size
        let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        let hstring = try! HString("Windows.Foundation.IReference`1<Windows.Web.WebErrorStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard let __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusWrapper = ReferenceWrapperBase<UWP.__x_ABI_C__FIReference_1___x_ABI_CWindows__CWeb__CWebErrorStatusBridge>
private var IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x9df03456, Data2: 0x3383, Data3: 0x508b, Data4: ( 0x9c,0x75,0xee,0x84,0x0a,0x7e,0x1a,0x39 ))// 9df03456-3383-508b-9c75-ee840a7e1a39
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        let args: UWP.CompositionBatchCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsBridge>
internal class TypedEventHandlerAny_CompositionBatchCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgs }

    internal func InvokeImpl(_ sender: Any?, _ args: UWP.CompositionBatchCompletedEventArgs?) throws {
        let senderWrapper = __ABI_.AnyWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<Any?, UWP.CompositionBatchCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CWindows__CUI__CComposition__CCompositionBatchCompletedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerAny_CompositionBatchCompletedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x7725b2a5, Data2: 0x287d, Data3: 0x5ed2, Data4: ( 0xa7,0x89,0x2a,0x6a,0x26,0x73,0xc7,0xfe ))// 7725b2a5-287d-5ed2-a789-2a6a2673c7fe
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.SplashScreen? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableBridge>
internal class TypedEventHandlerSplashScreen_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectable }

    internal func InvokeImpl(_ sender: UWP.SplashScreen?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.SplashScreen?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CActivation__CSplashScreen_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerSplashScreen_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd4f89768, Data2: 0x688f, Data3: 0x59ec, Data4: ( 0xbf,0x24,0xc2,0xaf,0x6a,0x31,0x0f,0xa4 ))// d4f89768-688f-59ec-bf24-c2af6a310fa4
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.BackgroundTaskRegistrationGroup? = .from(abi: ComPtr($1))
        let args: UWP.BackgroundActivatedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsBridge>
internal class TypedEventHandlerBackgroundTaskRegistrationGroup_BackgroundActivatedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgs }

    internal func InvokeImpl(_ sender: UWP.BackgroundTaskRegistrationGroup?, _ args: UWP.BackgroundActivatedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.BackgroundTaskRegistrationGroup?, UWP.BackgroundActivatedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CBackground__CBackgroundTaskRegistrationGroup___x_ABI_CWindows__CApplicationModel__CActivation__CBackgroundActivatedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerBackgroundTaskRegistrationGroup_BackgroundActivatedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xc156b0c3, Data2: 0x1cbc, Data3: 0x5ca4, Data4: ( 0x90,0x1c,0x62,0xc5,0xa8,0xca,0x5c,0xb5 ))// c156b0c3-1cbc-5ca4-901c-62c5a8ca5cb5
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DataPackage? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableBridge>
internal class TypedEventHandlerDataPackage_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectable }

    internal func InvokeImpl(_ sender: UWP.DataPackage?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DataPackage?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerDataPackage_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xdd48af6c, Data2: 0xef9a, Data3: 0x59cb, Data4: ( 0xb3,0x26,0x57,0xd9,0xe2,0x41,0x1f,0x21 ))// dd48af6c-ef9a-59cb-b326-57d9e2411f21
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DataPackage? = .from(abi: ComPtr($1))
        let args: UWP.OperationCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsBridge>
internal class TypedEventHandlerDataPackage_OperationCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgs }

    internal func InvokeImpl(_ sender: UWP.DataPackage?, _ args: UWP.OperationCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DataPackage?, UWP.OperationCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__COperationCompletedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerDataPackage_OperationCompletedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xf8f7e24a, Data2: 0x56fe, Data3: 0x58df, Data4: ( 0xbc,0x15,0x23,0x65,0xae,0xc0,0x39,0x66 ))// f8f7e24a-56fe-58df-bc15-2365aec03966
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DataPackage? = .from(abi: ComPtr($1))
        let args: UWP.ShareCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsBridge>
internal class TypedEventHandlerDataPackage_ShareCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgs }

    internal func InvokeImpl(_ sender: UWP.DataPackage?, _ args: UWP.ShareCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DataPackage?, UWP.ShareCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackage___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareCompletedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerDataPackage_ShareCompletedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xec6f9cc8, Data2: 0x46d0, Data3: 0x5e0e, Data4: ( 0xb4,0xd2,0x7d,0x77,0x73,0xae,0x37,0xa0 ))// ec6f9cc8-46d0-5e0e-b4d2-7d7773ae37a0
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DataTransferManager? = .from(abi: ComPtr($1))
        let args: UWP.DataRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsBridge>
internal class TypedEventHandlerDataTransferManager_DataRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.DataTransferManager?, _ args: UWP.DataRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DataTransferManager?, UWP.DataRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerDataTransferManager_DataRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x147e2860, Data2: 0x7397, Data3: 0x582f, Data4: ( 0x80,0xdb,0xb8,0x68,0x53,0x83,0xa9,0x37 ))// 147e2860-7397-582f-80db-b8685383a937
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DataTransferManager? = .from(abi: ComPtr($1))
        let args: UWP.ShareProvidersRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsBridge>
internal class TypedEventHandlerDataTransferManager_ShareProvidersRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.DataTransferManager?, _ args: UWP.ShareProvidersRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DataTransferManager?, UWP.ShareProvidersRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CShareProvidersRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerDataTransferManager_ShareProvidersRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xc4ac1ba2, Data2: 0x7851, Data3: 0x5a44, Data4: ( 0xbc,0x8d,0x3d,0x7c,0x71,0x3f,0x1f,0x41 ))// c4ac1ba2-7851-5a44-bc8d-3d7c713f1f41
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DataTransferManager? = .from(abi: ComPtr($1))
        let args: UWP.TargetApplicationChosenEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsBridge>
internal class TypedEventHandlerDataTransferManager_TargetApplicationChosenEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgs }

    internal func InvokeImpl(_ sender: UWP.DataTransferManager?, _ args: UWP.TargetApplicationChosenEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DataTransferManager?, UWP.TargetApplicationChosenEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataTransferManager___x_ABI_CWindows__CApplicationModel__CDataTransfer__CTargetApplicationChosenEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerDataTransferManager_TargetApplicationChosenEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xfa65231f, Data2: 0x4178, Data3: 0x5de1, Data4: ( 0xb2,0xcc,0x03,0xe2,0x2d,0x77,0x02,0xb4 ))// fa65231f-4178-5de1-b2cc-03e22d7702b4
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DeviceInformationCustomPairing? = .from(abi: ComPtr($1))
        let args: UWP.DevicePairingRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsBridge>
internal class TypedEventHandlerDeviceInformationCustomPairing_DevicePairingRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.DeviceInformationCustomPairing?, _ args: UWP.DevicePairingRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DeviceInformationCustomPairing?, UWP.DevicePairingRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationCustomPairing___x_ABI_CWindows__CDevices__CEnumeration__CDevicePairingRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerDeviceInformationCustomPairing_DevicePairingRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x9234630f, Data2: 0x1ff4, Data3: 0x54f6, Data4: ( 0x9e,0x3f,0xac,0x20,0x36,0x9b,0x77,0x25 ))// 9234630f-1ff4-54f6-9e3f-ac20369b7725
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DeviceWatcher? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableBridge>
internal class TypedEventHandlerDeviceWatcher_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectable }

    internal func InvokeImpl(_ sender: UWP.DeviceWatcher?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DeviceWatcher?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerDeviceWatcher_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation: WindowsFoundation.IID {
    .init(Data1: 0x03c5a07b, Data2: 0x990c, Data3: 0x5d09, Data4: ( 0xb0,0xb8,0x57,0x34,0xea,0xa3,0x82,0x22 ))// 03c5a07b-990c-5d09-b0b8-5734eaa38222
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DeviceWatcher? = .from(abi: ComPtr($1))
        let args: UWP.DeviceInformation? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge>
internal class TypedEventHandlerDeviceWatcher_DeviceInformation: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation }

    internal func InvokeImpl(_ sender: UWP.DeviceWatcher?, _ args: UWP.DeviceInformation?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DeviceWatcher?, UWP.DeviceInformation?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation
    internal typealias SwiftABI = UWP.TypedEventHandlerDeviceWatcher_DeviceInformation

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdate: WindowsFoundation.IID {
    .init(Data1: 0x906f1254, Data2: 0x79ad, Data3: 0x54fc, Data4: ( 0x93,0xc4,0xcd,0xb9,0x9b,0x43,0x78,0x99 ))// 906f1254-79ad-54fc-93c4-cdb99b437899
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdate {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DeviceWatcher? = .from(abi: ComPtr($1))
        let args: UWP.DeviceInformationUpdate? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateBridge>
internal class TypedEventHandlerDeviceWatcher_DeviceInformationUpdate: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdate }

    internal func InvokeImpl(_ sender: UWP.DeviceWatcher?, _ args: UWP.DeviceInformationUpdate?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdate.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdateBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DeviceWatcher?, UWP.DeviceInformationUpdate?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CDevices__CEnumeration__CDeviceWatcher___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformationUpdate
    internal typealias SwiftABI = UWP.TypedEventHandlerDeviceWatcher_DeviceInformationUpdate

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x1333df3f, Data2: 0xc55b, Data3: 0x5a23, Data4: ( 0x95,0x96,0x34,0x65,0x7c,0x2a,0x34,0x06 ))// 1333df3f-c55b-5a23-9596-34657c2a3406
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AudioStateMonitor? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableBridge>
internal class TypedEventHandlerAudioStateMonitor_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectable }

    internal func InvokeImpl(_ sender: UWP.AudioStateMonitor?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AudioStateMonitor?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CAudio__CAudioStateMonitor_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerAudioStateMonitor_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xc7e61aa7, Data2: 0x4716, Data3: 0x5514, Data4: ( 0xa9,0x13,0xef,0x17,0x96,0xb9,0x8d,0xbd ))// c7e61aa7-4716-5514-a913-ef1796b98dbd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaFrameSource? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableBridge>
internal class TypedEventHandlerMediaFrameSource_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaFrameSource?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaFrameSource?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCapture__CFrames__CMediaFrameSource_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaFrameSource_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xb5b7e554, Data2: 0x2476, Data3: 0x5667, Data4: ( 0x9c,0x9a,0x1c,0x7a,0x7d,0x09,0xac,0xe2 ))// b5b7e554-2476-5667-9c9a-1c7a7d09ace2
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AudioTrack? = .from(abi: ComPtr($1))
        let args: UWP.AudioTrackOpenFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsBridge>
internal class TypedEventHandlerAudioTrack_AudioTrackOpenFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgs }

    internal func InvokeImpl(_ sender: UWP.AudioTrack?, _ args: UWP.AudioTrackOpenFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AudioTrack?, UWP.AudioTrackOpenFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CAudioTrack___x_ABI_CWindows__CMedia__CCore__CAudioTrackOpenFailedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerAudioTrack_AudioTrackOpenFailedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x21eb6e39, Data2: 0x728a, Data3: 0x56a9, Data4: ( 0x8d,0xce,0x06,0x2b,0xa4,0xc8,0x1b,0xf5 ))// 21eb6e39-728a-56a9-8dce-062ba4c81bf5
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AnyISingleSelectMediaTrackList? = __ABI_Windows_Media_Core.ISingleSelectMediaTrackListWrapper.unwrapFrom(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableBridge>
internal class TypedEventHandlerISingleSelectMediaTrackList_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectable }

    internal func InvokeImpl(_ sender: UWP.AnyISingleSelectMediaTrackList?, _ args: Any?) throws {
        let senderWrapper = __ABI_Windows_Media_Core.ISingleSelectMediaTrackListWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AnyISingleSelectMediaTrackList?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CISingleSelectMediaTrackList_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerISingleSelectMediaTrackList_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x5b133719, Data2: 0xee98, Data3: 0x59b2, Data4: ( 0xb4,0x32,0x1c,0x9a,0x5a,0x56,0xab,0x05 ))// 5b133719-ee98-59b2-b432-1c9a5a56ab05
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaBinder? = .from(abi: ComPtr($1))
        let args: UWP.MediaBindingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsBridge>
internal class TypedEventHandlerMediaBinder_MediaBindingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaBinder?, _ args: UWP.MediaBindingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaBinder?, UWP.MediaBindingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBinder___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaBinder_MediaBindingEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x3f3b10e2, Data2: 0xb2e9, Data3: 0x55c6, Data4: ( 0xab,0xb3,0x4a,0x25,0x80,0x72,0xeb,0xb9 ))// 3f3b10e2-b2e9-55c6-abb3-4a258072ebb9
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaBindingEventArgs? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableBridge>
internal class TypedEventHandlerMediaBindingEventArgs_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaBindingEventArgs?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaBindingEventArgs?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaBindingEventArgs_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaBindingEventArgs_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x425d53e3, Data2: 0xfba6, Data3: 0x5ea3, Data4: ( 0xb7,0x13,0xdb,0x4d,0x70,0x78,0x74,0x36 ))// 425d53e3-fba6-5ea3-b713-db4d70787436
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaSource? = .from(abi: ComPtr($1))
        let args: UWP.MediaSourceOpenOperationCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsBridge>
internal class TypedEventHandlerMediaSource_MediaSourceOpenOperationCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaSource?, _ args: UWP.MediaSourceOpenOperationCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaSource?, UWP.MediaSourceOpenOperationCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceOpenOperationCompletedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaSource_MediaSourceOpenOperationCompletedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x2274d3a6, Data2: 0x1ba0, Data3: 0x5230, Data4: ( 0xbb,0x86,0xde,0x90,0x05,0x8b,0x64,0x03 ))// 2274d3a6-1ba0-5230-bb86-de90058b6403
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaSource? = .from(abi: ComPtr($1))
        let args: UWP.MediaSourceStateChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsBridge>
internal class TypedEventHandlerMediaSource_MediaSourceStateChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaSource?, _ args: UWP.MediaSourceStateChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaSource?, UWP.MediaSourceStateChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaSource___x_ABI_CWindows__CMedia__CCore__CMediaSourceStateChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaSource_MediaSourceStateChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xd4dc5ef1, Data2: 0xc1cb, Data3: 0x5c32, Data4: ( 0x80,0x3d,0xf2,0xf9,0xa7,0xad,0x99,0x16 ))// d4dc5ef1-c1cb-5c32-803d-f2f9a7ad9916
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaStreamSample? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableBridge>
internal class TypedEventHandlerMediaStreamSample_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaStreamSample?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaStreamSample?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSample_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaStreamSample_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x6fd6ded7, Data2: 0x421b, Data3: 0x5ef5, Data4: ( 0x8b,0xf5,0xed,0xea,0x45,0x40,0x16,0x65 ))// 6fd6ded7-421b-5ef5-8bf5-edea45401665
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaStreamSource? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableBridge>
internal class TypedEventHandlerMediaStreamSource_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaStreamSource?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaStreamSource?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaStreamSource_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x238cc251, Data2: 0xd0b8, Data3: 0x5a34, Data4: ( 0x81,0xd4,0x0d,0xd1,0xf9,0x36,0xa2,0x0d ))// 238cc251-d0b8-5a34-81d4-0dd1f936a20d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaStreamSource? = .from(abi: ComPtr($1))
        let args: UWP.MediaStreamSourceClosedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsBridge>
internal class TypedEventHandlerMediaStreamSource_MediaStreamSourceClosedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaStreamSource?, _ args: UWP.MediaStreamSourceClosedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaStreamSource?, UWP.MediaStreamSourceClosedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceClosedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaStreamSource_MediaStreamSourceClosedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x9d812c70, Data2: 0x9f0d, Data3: 0x5ad5, Data4: ( 0x82,0x74,0xf7,0x60,0xc9,0xca,0x0c,0x38 ))// 9d812c70-9f0d-5ad5-8274-f760c9ca0c38
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaStreamSource? = .from(abi: ComPtr($1))
        let args: UWP.MediaStreamSourceSampleRenderedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsBridge>
internal class TypedEventHandlerMediaStreamSource_MediaStreamSourceSampleRenderedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaStreamSource?, _ args: UWP.MediaStreamSourceSampleRenderedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaStreamSource?, UWP.MediaStreamSourceSampleRenderedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRenderedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaStreamSource_MediaStreamSourceSampleRenderedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x4f1a3ae3, Data2: 0xb8b7, Data3: 0x5689, Data4: ( 0x90,0x1d,0xb0,0xb6,0x23,0xf5,0xa1,0x72 ))// 4f1a3ae3-b8b7-5689-901d-b0b623f5a172
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaStreamSource? = .from(abi: ComPtr($1))
        let args: UWP.MediaStreamSourceSampleRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsBridge>
internal class TypedEventHandlerMediaStreamSource_MediaStreamSourceSampleRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaStreamSource?, _ args: UWP.MediaStreamSourceSampleRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaStreamSource?, UWP.MediaStreamSourceSampleRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSampleRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaStreamSource_MediaStreamSourceSampleRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xa93d5846, Data2: 0xc660, Data3: 0x586e, Data4: ( 0xb6,0xb5,0xa5,0x2f,0xb8,0x1f,0x92,0x40 ))// a93d5846-c660-586e-b6b5-a52fb81f9240
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaStreamSource? = .from(abi: ComPtr($1))
        let args: UWP.MediaStreamSourceStartingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsBridge>
internal class TypedEventHandlerMediaStreamSource_MediaStreamSourceStartingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaStreamSource?, _ args: UWP.MediaStreamSourceStartingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaStreamSource?, UWP.MediaStreamSourceStartingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceStartingEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaStreamSource_MediaStreamSourceStartingEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x452b2e4a, Data2: 0x5511, Data3: 0x5b3c, Data4: ( 0x8a,0x8e,0xee,0x65,0x95,0x76,0xa4,0xc1 ))// 452b2e4a-5511-5b3c-8a8e-ee659576a4c1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaStreamSource? = .from(abi: ComPtr($1))
        let args: UWP.MediaStreamSourceSwitchStreamsRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsBridge>
internal class TypedEventHandlerMediaStreamSource_MediaStreamSourceSwitchStreamsRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaStreamSource?, _ args: UWP.MediaStreamSourceSwitchStreamsRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaStreamSource?, UWP.MediaStreamSourceSwitchStreamsRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMediaStreamSource___x_ABI_CWindows__CMedia__CCore__CMediaStreamSourceSwitchStreamsRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaStreamSource_MediaStreamSourceSwitchStreamsRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x187fd3d7, Data2: 0xbb9d, Data3: 0x541a, Data4: ( 0x94,0xfd,0x43,0xc3,0x1d,0xd8,0x4a,0x67 ))// 187fd3d7-bb9d-541a-94fd-43c31dd84a67
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MseSourceBuffer? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableBridge>
internal class TypedEventHandlerMseSourceBuffer_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MseSourceBuffer?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MseSourceBuffer?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBuffer_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMseSourceBuffer_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x0ff01695, Data2: 0xfbb2, Data3: 0x5e95, Data4: ( 0x8e,0xc7,0xda,0x17,0xd8,0xe9,0x9f,0x16 ))// 0ff01695-fbb2-5e95-8ec7-da17d8e99f16
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MseSourceBufferList? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableBridge>
internal class TypedEventHandlerMseSourceBufferList_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MseSourceBufferList?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MseSourceBufferList?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseSourceBufferList_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMseSourceBufferList_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x724bf4ef, Data2: 0xde7a, Data3: 0x5dbd, Data4: ( 0x81,0x5e,0x52,0x2a,0x87,0xbc,0x33,0x44 ))// 724bf4ef-de7a-5dbd-815e-522a87bc3344
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MseStreamSource? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableBridge>
internal class TypedEventHandlerMseStreamSource_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MseStreamSource?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MseStreamSource?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CMseStreamSource_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMseStreamSource_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x4aac9411, Data2: 0xc355, Data3: 0x5c95, Data4: ( 0x8c,0x78,0x5a,0x0f,0x5c,0xa1,0xa5,0x4d ))// 4aac9411-c355-5c95-8c78-5a0f5ca1a54d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.TimedMetadataTrack? = .from(abi: ComPtr($1))
        let args: UWP.MediaCueEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsBridge>
internal class TypedEventHandlerTimedMetadataTrack_MediaCueEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgs }

    internal func InvokeImpl(_ sender: UWP.TimedMetadataTrack?, _ args: UWP.MediaCueEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.TimedMetadataTrack?, UWP.MediaCueEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CMediaCueEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerTimedMetadataTrack_MediaCueEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x8dc73162, Data2: 0x255b, Data3: 0x532e, Data4: ( 0xb0,0xc7,0x9a,0x6d,0x70,0xb4,0xbb,0x9e ))// 8dc73162-255b-532e-b0c7-9a6d70b4bb9e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.TimedMetadataTrack? = .from(abi: ComPtr($1))
        let args: UWP.TimedMetadataTrackFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsBridge>
internal class TypedEventHandlerTimedMetadataTrack_TimedMetadataTrackFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgs }

    internal func InvokeImpl(_ sender: UWP.TimedMetadataTrack?, _ args: UWP.TimedMetadataTrackFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.TimedMetadataTrack?, UWP.TimedMetadataTrackFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrackFailedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerTimedMetadataTrack_TimedMetadataTrackFailedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x0220562a, Data2: 0x5de4, Data3: 0x5ad2, Data4: ( 0xac,0x20,0x6c,0xd2,0x6f,0x11,0x17,0x45 ))// 0220562a-5de4-5ad2-ac20-6cd26f111745
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.TimedTextSource? = .from(abi: ComPtr($1))
        let args: UWP.TimedTextSourceResolveResultEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsBridge>
internal class TypedEventHandlerTimedTextSource_TimedTextSourceResolveResultEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgs }

    internal func InvokeImpl(_ sender: UWP.TimedTextSource?, _ args: UWP.TimedTextSourceResolveResultEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.TimedTextSource?, UWP.TimedTextSourceResolveResultEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CTimedTextSource___x_ABI_CWindows__CMedia__CCore__CTimedTextSourceResolveResultEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerTimedTextSource_TimedTextSourceResolveResultEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xb1e4bd43, Data2: 0x541b, Data3: 0x53f3, Data4: ( 0xad,0x6c,0xdd,0xaa,0xc4,0x81,0x30,0x23 ))// b1e4bd43-541b-53f3-ad6c-ddaac4813023
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.VideoTrack? = .from(abi: ComPtr($1))
        let args: UWP.VideoTrackOpenFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsBridge>
internal class TypedEventHandlerVideoTrack_VideoTrackOpenFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgs }

    internal func InvokeImpl(_ sender: UWP.VideoTrack?, _ args: UWP.VideoTrackOpenFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.VideoTrack?, UWP.VideoTrackOpenFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CCore__CVideoTrack___x_ABI_CWindows__CMedia__CCore__CVideoTrackOpenFailedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerVideoTrack_VideoTrackOpenFailedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x5c43e195, Data2: 0x7d39, Data3: 0x5d0d, Data4: ( 0xa3,0x09,0x19,0x91,0xe6,0x8a,0xcd,0xb7 ))// 5c43e195-7d39-5d0d-a309-1991e68acdb7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaTimelineController? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableBridge>
internal class TypedEventHandlerMediaTimelineController_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaTimelineController?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaTimelineController?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaTimelineController_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x07cd62fb, Data2: 0x578d, Data3: 0x56a6, Data4: ( 0xa8,0xef,0xe6,0x53,0xeb,0x00,0x5d,0x1b ))// 07cd62fb-578d-56a6-a8ef-e653eb005d1b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaTimelineController? = .from(abi: ComPtr($1))
        let args: UWP.MediaTimelineControllerFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsBridge>
internal class TypedEventHandlerMediaTimelineController_MediaTimelineControllerFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaTimelineController?, _ args: UWP.MediaTimelineControllerFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaTimelineController?, UWP.MediaTimelineControllerFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CMediaTimelineController___x_ABI_CWindows__CMedia__CMediaTimelineControllerFailedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaTimelineController_MediaTimelineControllerFailedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x04afafa9, Data2: 0xd83a, Data3: 0x5ccb, Data4: ( 0x8c,0xab,0x82,0xc9,0xd9,0x2a,0x19,0xab ))// 04afafa9-d83a-5ccb-8cab-82c9d92a19ab
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaBreakManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaBreakEndedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsBridge>
internal class TypedEventHandlerMediaBreakManager_MediaBreakEndedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaBreakManager?, _ args: UWP.MediaBreakEndedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaBreakManager?, UWP.MediaBreakEndedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakEndedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaBreakManager_MediaBreakEndedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xa6954c30, Data2: 0x99dc, Data3: 0x5f84, Data4: ( 0xb4,0x82,0x7d,0x06,0x92,0xc0,0x27,0x7b ))// a6954c30-99dc-5f84-b482-7d0692c0277b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaBreakManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaBreakSeekedOverEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsBridge>
internal class TypedEventHandlerMediaBreakManager_MediaBreakSeekedOverEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaBreakManager?, _ args: UWP.MediaBreakSeekedOverEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaBreakManager?, UWP.MediaBreakSeekedOverEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSeekedOverEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaBreakManager_MediaBreakSeekedOverEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xc530fa5d, Data2: 0x1a56, Data3: 0x582a, Data4: ( 0xa2,0x54,0x1b,0x1a,0xe1,0x7b,0x8d,0x2d ))// c530fa5d-1a56-582a-a254-1b1ae17b8d2d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaBreakManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaBreakSkippedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsBridge>
internal class TypedEventHandlerMediaBreakManager_MediaBreakSkippedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaBreakManager?, _ args: UWP.MediaBreakSkippedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaBreakManager?, UWP.MediaBreakSkippedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSkippedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaBreakManager_MediaBreakSkippedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x4bf2cca1, Data2: 0xcd9d, Data3: 0x5d88, Data4: ( 0x9e,0x47,0x18,0x81,0x20,0x1b,0xb7,0x2d ))// 4bf2cca1-cd9d-5d88-9e47-1881201bb72d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaBreakManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaBreakStartedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsBridge>
internal class TypedEventHandlerMediaBreakManager_MediaBreakStartedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaBreakManager?, _ args: UWP.MediaBreakStartedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaBreakManager?, UWP.MediaBreakStartedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakManager___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakStartedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaBreakManager_MediaBreakStartedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x3c57acbf, Data2: 0xca07, Data3: 0x586a, Data4: ( 0x8a,0xdb,0x80,0x47,0xdc,0x91,0x65,0xa6 ))// 3c57acbf-ca07-586a-8adb-8047dc9165a6
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaBreakSchedule? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableBridge>
internal class TypedEventHandlerMediaBreakSchedule_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaBreakSchedule?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaBreakSchedule?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaBreakSchedule_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaBreakSchedule_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x824845b8, Data2: 0xc5df, Data3: 0x560b, Data4: ( 0xa7,0x22,0xc1,0x5b,0x25,0xd4,0x46,0x3a ))// 824845b8-c5df-560b-a722-c15b25d4463a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd7cd6ce3, Data2: 0x516f, Data3: 0x5b34, Data4: ( 0xbe,0xaf,0x3e,0xe9,0x0b,0x62,0x28,0x72 ))// d7cd6ce3-516f-5b34-beaf-3ee90b622872
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerFastForwardReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerFastForwardReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerFastForwardReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerFastForwardReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerFastForwardReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerFastForwardReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xce41af40, Data2: 0x93a6, Data3: 0x52bf, Data4: ( 0x9c,0xad,0x4d,0x5f,0xff,0xd1,0x0e,0xe0 ))// ce41af40-93a6-52bf-9cad-4d5fffd10ee0
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerNextReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerNextReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerNextReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerNextReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerNextReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerNextReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x79eb2ad3, Data2: 0x0781, Data3: 0x5f64, Data4: ( 0xb0,0xcd,0x31,0xe1,0x14,0x5d,0x10,0x9f ))// 79eb2ad3-0781-5f64-b0cd-31e1145d109f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerPauseReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerPauseReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerPauseReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerPauseReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPauseReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerPauseReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x76d59f7c, Data2: 0xedf3, Data3: 0x5dde, Data4: ( 0x95,0x29,0x6f,0x80,0x6b,0xdb,0x1f,0xcb ))// 76d59f7c-edf3-5dde-9529-6f806bdb1fcb
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerPlayReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerPlayReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerPlayReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerPlayReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPlayReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerPlayReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd863b1c4, Data2: 0x7442, Data3: 0x53c4, Data4: ( 0x94,0xd2,0x20,0xd8,0x97,0x3d,0xf5,0x85 ))// d863b1c4-7442-53c4-94d2-20d8973df585
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerPositionReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerPositionReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerPositionReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerPositionReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPositionReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerPositionReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x25726db4, Data2: 0x8913, Data3: 0x5967, Data4: ( 0x90,0xeb,0x10,0xf0,0x9f,0x30,0xdd,0x33 ))// 25726db4-8913-5967-90eb-10f09f30dd33
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerPreviousReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerPreviousReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerPreviousReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerPreviousReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerPreviousReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerPreviousReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x3f8a8ea1, Data2: 0xff9a, Data3: 0x5613, Data4: ( 0x98,0x46,0x33,0x79,0x9f,0x6b,0x8c,0x8a ))// 3f8a8ea1-ff9a-5613-9846-33799f6b8c8a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerRateReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerRateReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerRateReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerRateReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRateReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerRateReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x3c37e026, Data2: 0x8d0b, Data3: 0x5d73, Data4: ( 0xa6,0x50,0x9f,0x18,0xab,0xbc,0x35,0x3d ))// 3c37e026-8d0b-5d73-a650-9f18abbc353d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerRewindReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerRewindReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerRewindReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerRewindReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerRewindReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerRewindReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x6c972f91, Data2: 0xf626, Data3: 0x5799, Data4: ( 0xba,0x86,0x5e,0x94,0x1f,0x02,0x02,0xc8 ))// 6c972f91-f626-5799-ba86-5e941f0202c8
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManager? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackCommandManagerShuffleReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerShuffleReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManager?, _ args: UWP.MediaPlaybackCommandManagerShuffleReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManager?, UWP.MediaPlaybackCommandManagerShuffleReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManager___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerShuffleReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManager_MediaPlaybackCommandManagerShuffleReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x2675973a, Data2: 0xeb2d, Data3: 0x56a1, Data4: ( 0x82,0xa0,0x34,0x0b,0x0f,0xf0,0x41,0xe6 ))// 2675973a-eb2d-56a1-82a0-340b0ff041e6
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackCommandManagerCommandBehavior? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableBridge>
internal class TypedEventHandlerMediaPlaybackCommandManagerCommandBehavior_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackCommandManagerCommandBehavior?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackCommandManagerCommandBehavior?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackCommandManagerCommandBehavior_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackCommandManagerCommandBehavior_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x2dd51918, Data2: 0x4525, Data3: 0x5be5, Data4: ( 0xa6,0xc1,0x40,0x9b,0xc7,0x28,0x63,0xa6 ))// 2dd51918-4525-5be5-a6c1-409bc72863a6
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackItem? = .from(abi: ComPtr($1))
        let args: WindowsFoundation.AnyIVectorChangedEventArgs? = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackItem_IVectorChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackItem?, _ args: WindowsFoundation.AnyIVectorChangedEventArgs?) throws {
        let argsWrapper = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackItem?, WindowsFoundation.AnyIVectorChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItem___x_ABI_C__F__CIVectorChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackItem_IVectorChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x404c5f9d, Data2: 0x250d, Data3: 0x5f8c, Data4: ( 0x96,0x27,0x6b,0x41,0x05,0xc3,0x2d,0x09 ))// 404c5f9d-250d-5f8c-9627-6b4105c32d09
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackList? = .from(abi: ComPtr($1))
        let args: UWP.CurrentMediaPlaybackItemChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackList_CurrentMediaPlaybackItemChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackList?, _ args: UWP.CurrentMediaPlaybackItemChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackList?, UWP.CurrentMediaPlaybackItemChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CCurrentMediaPlaybackItemChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackList_CurrentMediaPlaybackItemChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x23319e7d, Data2: 0x34b1, Data3: 0x57b7, Data4: ( 0x97,0xe5,0x84,0x49,0x48,0xba,0x47,0x19 ))// 23319e7d-34b1-57b7-97e5-844948ba4719
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackList? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackItemFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackList_MediaPlaybackItemFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackList?, _ args: UWP.MediaPlaybackItemFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackList?, UWP.MediaPlaybackItemFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemFailedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackList_MediaPlaybackItemFailedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x6732bbef, Data2: 0x3311, Data3: 0x5f83, Data4: ( 0x9c,0x9d,0x82,0xa5,0xcf,0x3c,0xd8,0x2a ))// 6732bbef-3311-5f83-9c9d-82a5cf3cd82a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackList? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlaybackItemOpenedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackList_MediaPlaybackItemOpenedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackList?, _ args: UWP.MediaPlaybackItemOpenedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackList?, UWP.MediaPlaybackItemOpenedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackList___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackItemOpenedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackList_MediaPlaybackItemOpenedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x7c70f38d, Data2: 0x2aa1, Data3: 0x5522, Data4: ( 0xa6,0xd6,0x34,0xb5,0x2b,0x98,0x8a,0xe7 ))// 7c70f38d-2aa1-5522-a6d6-34b52b988ae7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackSession? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableBridge>
internal class TypedEventHandlerMediaPlaybackSession_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackSession?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackSession?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackSession_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackSession_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x40213c85, Data2: 0xbf23, Data3: 0x5f78, Data4: ( 0xb9,0xc4,0xe0,0x3f,0x3b,0xe2,0xb4,0x1c ))// 40213c85-bf23-5f78-b9c4-e03f3be2b41c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlaybackTimedMetadataTrackList? = .from(abi: ComPtr($1))
        let args: UWP.TimedMetadataPresentationModeChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsBridge>
internal class TypedEventHandlerMediaPlaybackTimedMetadataTrackList_TimedMetadataPresentationModeChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlaybackTimedMetadataTrackList?, _ args: UWP.TimedMetadataPresentationModeChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlaybackTimedMetadataTrackList?, UWP.TimedMetadataPresentationModeChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlaybackTimedMetadataTrackList___x_ABI_CWindows__CMedia__CPlayback__CTimedMetadataPresentationModeChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlaybackTimedMetadataTrackList_TimedMetadataPresentationModeChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xf1a6a51e, Data2: 0xd078, Data3: 0x5c40, Data4: ( 0xba,0x3f,0x34,0x88,0x70,0xba,0x5c,0x87 ))// f1a6a51e-d078-5c40-ba3f-348870ba5c87
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlayer? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableBridge>
internal class TypedEventHandlerMediaPlayer_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectable }

    internal func InvokeImpl(_ sender: UWP.MediaPlayer?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlayer?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlayer_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x362c45a7, Data2: 0x3a0a, Data3: 0x5e27, Data4: ( 0x99,0xce,0xcf,0xf6,0xd1,0xb7,0x70,0xe1 ))// 362c45a7-3a0a-5e27-99ce-cff6d1b770e1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlayer? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlayerFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsBridge>
internal class TypedEventHandlerMediaPlayer_MediaPlayerFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlayer?, _ args: UWP.MediaPlayerFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlayer?, UWP.MediaPlayerFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerFailedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlayer_MediaPlayerFailedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xba51d31a, Data2: 0x5688, Data3: 0x5d4d, Data4: ( 0xaf,0x42,0x12,0x20,0x70,0xb1,0xee,0xfa ))// ba51d31a-5688-5d4d-af42-122070b1eefa
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlayer? = .from(abi: ComPtr($1))
        let args: UWP.MediaPlayerRateChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsBridge>
internal class TypedEventHandlerMediaPlayer_MediaPlayerRateChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlayer?, _ args: UWP.MediaPlayerRateChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlayer?, UWP.MediaPlayerRateChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayerRateChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlayer_MediaPlayerRateChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x67a4f43c, Data2: 0xc254, Data3: 0x57f0, Data4: ( 0xa3,0x9d,0xa4,0x75,0xa3,0x42,0xd2,0x1d ))// 67a4f43c-c254-57f0-a39d-a475a342d21d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.MediaPlayer? = .from(abi: ComPtr($1))
        let args: UWP.PlaybackMediaMarkerReachedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsBridge>
internal class TypedEventHandlerMediaPlayer_PlaybackMediaMarkerReachedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgs }

    internal func InvokeImpl(_ sender: UWP.MediaPlayer?, _ args: UWP.PlaybackMediaMarkerReachedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.MediaPlayer?, UWP.PlaybackMediaMarkerReachedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CPlayback__CMediaPlayer___x_ABI_CWindows__CMedia__CPlayback__CPlaybackMediaMarkerReachedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerMediaPlayer_PlaybackMediaMarkerReachedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xad268caf, Data2: 0x7da0, Data3: 0x5ad4, Data4: ( 0x85,0x85,0xce,0xeb,0x90,0x3d,0xbd,0x50 ))// ad268caf-7da0-5ad4-8585-ceeb903dbd50
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AdaptiveMediaSource? = .from(abi: ComPtr($1))
        let args: UWP.AdaptiveMediaSourceDownloadBitrateChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsBridge>
internal class TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourceDownloadBitrateChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.AdaptiveMediaSource?, _ args: UWP.AdaptiveMediaSourceDownloadBitrateChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AdaptiveMediaSource?, UWP.AdaptiveMediaSourceDownloadBitrateChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadBitrateChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourceDownloadBitrateChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xcef775dd, Data2: 0x25b2, Data3: 0x5588, Data4: ( 0x8d,0x51,0xda,0xcd,0xea,0x66,0x0a,0x7d ))// cef775dd-25b2-5588-8d51-dacdea660a7d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AdaptiveMediaSource? = .from(abi: ComPtr($1))
        let args: UWP.AdaptiveMediaSourceDownloadCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsBridge>
internal class TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourceDownloadCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgs }

    internal func InvokeImpl(_ sender: UWP.AdaptiveMediaSource?, _ args: UWP.AdaptiveMediaSourceDownloadCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AdaptiveMediaSource?, UWP.AdaptiveMediaSourceDownloadCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadCompletedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourceDownloadCompletedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x6ee5cc44, Data2: 0x49ad, Data3: 0x5138, Data4: ( 0xab,0x47,0xf5,0xc0,0x75,0xa2,0xbc,0x34 ))// 6ee5cc44-49ad-5138-ab47-f5c075a2bc34
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AdaptiveMediaSource? = .from(abi: ComPtr($1))
        let args: UWP.AdaptiveMediaSourceDownloadFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsBridge>
internal class TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourceDownloadFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgs }

    internal func InvokeImpl(_ sender: UWP.AdaptiveMediaSource?, _ args: UWP.AdaptiveMediaSourceDownloadFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AdaptiveMediaSource?, UWP.AdaptiveMediaSourceDownloadFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadFailedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourceDownloadFailedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd3b7dbf1, Data2: 0xfd8e, Data3: 0x589e, Data4: ( 0x9c,0x7f,0xba,0x67,0x39,0x7e,0x50,0xcd ))// d3b7dbf1-fd8e-589e-9c7f-ba67397e50cd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AdaptiveMediaSource? = .from(abi: ComPtr($1))
        let args: UWP.AdaptiveMediaSourceDownloadRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsBridge>
internal class TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourceDownloadRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.AdaptiveMediaSource?, _ args: UWP.AdaptiveMediaSourceDownloadRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AdaptiveMediaSource?, UWP.AdaptiveMediaSourceDownloadRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDownloadRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourceDownloadRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xdf4f4e89, Data2: 0x6173, Data3: 0x539b, Data4: ( 0x94,0xd8,0x69,0xb7,0xcb,0x75,0x78,0xa7 ))// df4f4e89-6173-539b-94d8-69b7cb7578a7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AdaptiveMediaSource? = .from(abi: ComPtr($1))
        let args: UWP.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsBridge>
internal class TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.AdaptiveMediaSource?, _ args: UWP.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AdaptiveMediaSource?, UWP.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSource___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourcePlaybackBitrateChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerAdaptiveMediaSource_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xfd4ce6b5, Data2: 0x7c3b, Data3: 0x58f4, Data4: ( 0x9e,0xfc,0x1d,0x9e,0xe6,0xa0,0x9d,0x21 ))// fd4ce6b5-7c3b-58f4-9efc-1d9ee6a09d21
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AdaptiveMediaSourceDiagnostics? = .from(abi: ComPtr($1))
        let args: UWP.AdaptiveMediaSourceDiagnosticAvailableEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsBridge>
internal class TypedEventHandlerAdaptiveMediaSourceDiagnostics_AdaptiveMediaSourceDiagnosticAvailableEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgs }

    internal func InvokeImpl(_ sender: UWP.AdaptiveMediaSourceDiagnostics?, _ args: UWP.AdaptiveMediaSourceDiagnosticAvailableEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AdaptiveMediaSourceDiagnostics?, UWP.AdaptiveMediaSourceDiagnosticAvailableEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnostics___x_ABI_CWindows__CMedia__CStreaming__CAdaptive__CAdaptiveMediaSourceDiagnosticAvailableEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerAdaptiveMediaSourceDiagnostics_AdaptiveMediaSourceDiagnosticAvailableEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xa6214bde, Data2: 0x02d5, Data3: 0x55b3, Data4: ( 0xab,0x0d,0xc6,0x03,0x1b,0xe7,0x0d,0xa1 ))// a6214bde-02d5-55b3-ab0d-c6031be70da1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.SystemMediaTransportControls? = .from(abi: ComPtr($1))
        let args: UWP.AutoRepeatModeChangeRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsBridge>
internal class TypedEventHandlerSystemMediaTransportControls_AutoRepeatModeChangeRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.SystemMediaTransportControls?, _ args: UWP.AutoRepeatModeChangeRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.SystemMediaTransportControls?, UWP.AutoRepeatModeChangeRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CAutoRepeatModeChangeRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerSystemMediaTransportControls_AutoRepeatModeChangeRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x44e34f15, Data2: 0xbdc0, Data3: 0x50a7, Data4: ( 0xac,0xe4,0x39,0xe9,0x1f,0xb7,0x53,0xf1 ))// 44e34f15-bdc0-50a7-ace4-39e91fb753f1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.SystemMediaTransportControls? = .from(abi: ComPtr($1))
        let args: UWP.PlaybackPositionChangeRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsBridge>
internal class TypedEventHandlerSystemMediaTransportControls_PlaybackPositionChangeRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.SystemMediaTransportControls?, _ args: UWP.PlaybackPositionChangeRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.SystemMediaTransportControls?, UWP.PlaybackPositionChangeRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackPositionChangeRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerSystemMediaTransportControls_PlaybackPositionChangeRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x15eb0182, Data2: 0x6366, Data3: 0x5b9f, Data4: ( 0xbd,0x8c,0x8a,0xb4,0xfa,0x9d,0x7c,0xd9 ))// 15eb0182-6366-5b9f-bd8c-8ab4fa9d7cd9
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.SystemMediaTransportControls? = .from(abi: ComPtr($1))
        let args: UWP.PlaybackRateChangeRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsBridge>
internal class TypedEventHandlerSystemMediaTransportControls_PlaybackRateChangeRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.SystemMediaTransportControls?, _ args: UWP.PlaybackRateChangeRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.SystemMediaTransportControls?, UWP.PlaybackRateChangeRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CPlaybackRateChangeRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerSystemMediaTransportControls_PlaybackRateChangeRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x17ecea80, Data2: 0x27e4, Data3: 0x5dae, Data4: ( 0xab,0xb4,0xc8,0x58,0xad,0x1c,0x53,0x07 ))// 17ecea80-27e4-5dae-abb4-c858ad1c5307
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.SystemMediaTransportControls? = .from(abi: ComPtr($1))
        let args: UWP.ShuffleEnabledChangeRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsBridge>
internal class TypedEventHandlerSystemMediaTransportControls_ShuffleEnabledChangeRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.SystemMediaTransportControls?, _ args: UWP.ShuffleEnabledChangeRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.SystemMediaTransportControls?, UWP.ShuffleEnabledChangeRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CShuffleEnabledChangeRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerSystemMediaTransportControls_ShuffleEnabledChangeRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x0557e996, Data2: 0x7b23, Data3: 0x5bae, Data4: ( 0xaa,0x81,0xea,0x0d,0x67,0x11,0x43,0xa4 ))// 0557e996-7b23-5bae-aa81-ea0d671143a4
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.SystemMediaTransportControls? = .from(abi: ComPtr($1))
        let args: UWP.SystemMediaTransportControlsButtonPressedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsBridge>
internal class TypedEventHandlerSystemMediaTransportControls_SystemMediaTransportControlsButtonPressedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgs }

    internal func InvokeImpl(_ sender: UWP.SystemMediaTransportControls?, _ args: UWP.SystemMediaTransportControlsButtonPressedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.SystemMediaTransportControls?, UWP.SystemMediaTransportControlsButtonPressedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsButtonPressedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerSystemMediaTransportControls_SystemMediaTransportControlsButtonPressedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x9fd61dad, Data2: 0x1746, Data3: 0x5fa1, Data4: ( 0xa9,0x08,0xef,0x7c,0xb4,0x60,0x3c,0x85 ))// 9fd61dad-1746-5fa1-a908-ef7cb4603c85
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.SystemMediaTransportControls? = .from(abi: ComPtr($1))
        let args: UWP.SystemMediaTransportControlsPropertyChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsBridge>
internal class TypedEventHandlerSystemMediaTransportControls_SystemMediaTransportControlsPropertyChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.SystemMediaTransportControls?, _ args: UWP.SystemMediaTransportControlsPropertyChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.SystemMediaTransportControls?, UWP.SystemMediaTransportControlsPropertyChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CMedia__CSystemMediaTransportControls___x_ABI_CWindows__CMedia__CSystemMediaTransportControlsPropertyChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerSystemMediaTransportControls_SystemMediaTransportControlsPropertyChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x93a20d85, Data2: 0xbdfc, Data3: 0x5195, Data4: ( 0x90,0xd9,0x8c,0xb5,0x6c,0xbc,0xb3,0xd8 ))// 93a20d85-bdfc-5195-90d9-8cb56cbcb3d8
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DownloadOperation? = .from(abi: ComPtr($1))
        let args: UWP.BackgroundTransferRangesDownloadedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsBridge>
internal class TypedEventHandlerDownloadOperation_BackgroundTransferRangesDownloadedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgs }

    internal func InvokeImpl(_ sender: UWP.DownloadOperation?, _ args: UWP.BackgroundTransferRangesDownloadedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DownloadOperation?, UWP.BackgroundTransferRangesDownloadedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CDownloadOperation___x_ABI_CWindows__CNetworking__CBackgroundTransfer__CBackgroundTransferRangesDownloadedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerDownloadOperation_BackgroundTransferRangesDownloadedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x4ba22861, Data2: 0x00c4, Data3: 0x597f, Data4: ( 0xb6,0xbf,0x3a,0xf5,0x16,0xf3,0xb8,0x70 ))// 4ba22861-00c4-597f-b6bf-3af516f3b870
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AnyIStorageQueryResultBase? = __ABI_Windows_Storage_Search.IStorageQueryResultBaseWrapper.unwrapFrom(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableBridge>
internal class TypedEventHandlerIStorageQueryResultBase_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectable }

    internal func InvokeImpl(_ sender: UWP.AnyIStorageQueryResultBase?, _ args: Any?) throws {
        let senderWrapper = __ABI_Windows_Storage_Search.IStorageQueryResultBaseWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AnyIStorageQueryResultBase?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CStorage__CSearch__CIStorageQueryResultBase_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerIStorageQueryResultBase_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xfe79f855, Data2: 0x2f40, Data3: 0x5b88, Data4: ( 0xa0,0xc3,0x4c,0x04,0x2a,0x05,0xdd,0x05 ))// fe79f855-2f40-5b88-a0c3-4c042a05dd05
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DispatcherQueue? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableBridge>
internal class TypedEventHandlerDispatcherQueue_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectable }

    internal func InvokeImpl(_ sender: UWP.DispatcherQueue?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DispatcherQueue?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerDispatcherQueue_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xb58b5e24, Data2: 0xe1c6, Data3: 0x528e, Data4: ( 0x9d,0x99,0x07,0xec,0x88,0x29,0xde,0xa5 ))// b58b5e24-e1c6-528e-9d99-07ec8829dea5
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DispatcherQueue? = .from(abi: ComPtr($1))
        let args: UWP.DispatcherQueueShutdownStartingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsBridge>
internal class TypedEventHandlerDispatcherQueue_DispatcherQueueShutdownStartingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgs }

    internal func InvokeImpl(_ sender: UWP.DispatcherQueue?, _ args: UWP.DispatcherQueueShutdownStartingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DispatcherQueue?, UWP.DispatcherQueueShutdownStartingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueue___x_ABI_CWindows__CSystem__CDispatcherQueueShutdownStartingEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerDispatcherQueue_DispatcherQueueShutdownStartingEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x8b5644c8, Data2: 0x8b57, Data3: 0x50ce, Data4: ( 0x89,0x33,0x7a,0xb2,0xcc,0x5a,0x14,0xef ))// 8b5644c8-8b57-50ce-8933-7ab2cc5a14ef
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.DispatcherQueueTimer? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableBridge>
internal class TypedEventHandlerDispatcherQueueTimer_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectable }

    internal func InvokeImpl(_ sender: UWP.DispatcherQueueTimer?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.DispatcherQueueTimer?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CDispatcherQueueTimer_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerDispatcherQueueTimer_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xf155e0ff, Data2: 0xdbb5, Data3: 0x5c34, Data4: ( 0xac,0x0c,0x7e,0x29,0x1e,0x33,0x00,0xab ))// f155e0ff-dbb5-5c34-ac0c-7e291e3300ab
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.UserWatcher? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableBridge>
internal class TypedEventHandlerUserWatcher_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectable }

    internal func InvokeImpl(_ sender: UWP.UserWatcher?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.UserWatcher?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerUserWatcher_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x9ec3d9d5, Data2: 0xb413, Data3: 0x51df, Data4: ( 0x8c,0x64,0x64,0x0e,0x33,0x56,0xe3,0x51 ))// 9ec3d9d5-b413-51df-8c64-640e3356e351
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.UserWatcher? = .from(abi: ComPtr($1))
        let args: UWP.UserAuthenticationStatusChangingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsBridge>
internal class TypedEventHandlerUserWatcher_UserAuthenticationStatusChangingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgs }

    internal func InvokeImpl(_ sender: UWP.UserWatcher?, _ args: UWP.UserAuthenticationStatusChangingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.UserWatcher?, UWP.UserAuthenticationStatusChangingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserAuthenticationStatusChangingEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerUserWatcher_UserAuthenticationStatusChangingEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xeb9d0454, Data2: 0x25db, Data3: 0x5620, Data4: ( 0x98,0xb8,0xbe,0x4c,0x5d,0x0d,0xbc,0x67 ))// eb9d0454-25db-5620-98b8-be4c5d0dbc67
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.UserWatcher? = .from(abi: ComPtr($1))
        let args: UWP.UserChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsBridge>
internal class TypedEventHandlerUserWatcher_UserChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.UserWatcher?, _ args: UWP.UserChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.UserWatcher?, UWP.UserChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CSystem__CUserWatcher___x_ABI_CWindows__CSystem__CUserChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerUserWatcher_UserChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x136dff0d, Data2: 0xf7e8, Data3: 0x5153, Data4: ( 0xb3,0x1c,0x86,0x39,0x0c,0x70,0x18,0x80 ))// 136dff0d-f7e8-5153-b31c-86390c701880
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreDispatcher? = .from(abi: ComPtr($1))
        let args: UWP.AcceleratorKeyEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsBridge>
internal class TypedEventHandlerCoreDispatcher_AcceleratorKeyEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreDispatcher?, _ args: UWP.AcceleratorKeyEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreDispatcher?, UWP.AcceleratorKeyEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreDispatcher___x_ABI_CWindows__CUI__CCore__CAcceleratorKeyEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreDispatcher_AcceleratorKeyEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x6368ae3d, Data2: 0x52d4, Data3: 0x5290, Data4: ( 0xb9,0x36,0x71,0x7a,0x9a,0xcf,0x5b,0xea ))// 6368ae3d-52d4-5290-b936-717a9acf5bea
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableBridge>
internal class TypedEventHandlerCoreWindow_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectable }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x54db5c04, Data2: 0x81f7, Data3: 0x5f46, Data4: ( 0x9f,0xb8,0xe4,0x9b,0xee,0xc7,0x0a,0x24 ))// 54db5c04-81f7-5f46-9fb8-e49beec70a24
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.AutomationProviderRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsBridge>
internal class TypedEventHandlerCoreWindow_AutomationProviderRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.AutomationProviderRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.AutomationProviderRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CAutomationProviderRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_AutomationProviderRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x73f846a8, Data2: 0x0af6, Data3: 0x5872, Data4: ( 0x8f,0xb8,0xae,0x2f,0x56,0xd8,0x55,0x3e ))// 73f846a8-0af6-5872-8fb8-ae2f56d8553e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.CharacterReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsBridge>
internal class TypedEventHandlerCoreWindow_CharacterReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.CharacterReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.CharacterReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCharacterReceivedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_CharacterReceivedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x21a652d2, Data2: 0xbfe2, Data3: 0x5b2e, Data4: ( 0xa2,0xab,0xca,0x45,0x25,0x3b,0xe8,0xb0 ))// 21a652d2-bfe2-5b2e-a2ab-ca45253be8b0
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.ClosestInteractiveBoundsRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsBridge>
internal class TypedEventHandlerCoreWindow_ClosestInteractiveBoundsRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.ClosestInteractiveBoundsRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.ClosestInteractiveBoundsRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CClosestInteractiveBoundsRequestedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_ClosestInteractiveBoundsRequestedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd08e4f66, Data2: 0x3457, Data3: 0x57f2, Data4: ( 0xba,0x0c,0xcb,0x34,0x71,0x33,0xbd,0x15 ))// d08e4f66-3457-57f2-ba0c-cb347133bd15
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.CoreWindowEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsBridge>
internal class TypedEventHandlerCoreWindow_CoreWindowEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.CoreWindowEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.CoreWindowEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CCoreWindowEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_CoreWindowEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xe230a64a, Data2: 0x506a, Data3: 0x59c3, Data4: ( 0xbb,0x61,0x55,0x59,0xff,0x99,0x56,0x63 ))// e230a64a-506a-59c3-bb61-5559ff995663
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.InputEnabledEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsBridge>
internal class TypedEventHandlerCoreWindow_InputEnabledEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.InputEnabledEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.InputEnabledEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CInputEnabledEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_InputEnabledEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xa3ec0774, Data2: 0x55ac, Data3: 0x5d61, Data4: ( 0x82,0x32,0xb3,0x5c,0x5d,0x35,0xc9,0x3c ))// a3ec0774-55ac-5d61-8232-b35c5d35c93c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.KeyEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsBridge>
internal class TypedEventHandlerCoreWindow_KeyEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.KeyEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.KeyEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CKeyEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_KeyEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x420e1bb6, Data2: 0xe99d, Data3: 0x5e64, Data4: ( 0x8e,0x25,0x07,0x46,0x7e,0x3c,0xae,0x9e ))// 420e1bb6-e99d-5e64-8e25-07467e3cae9e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.PointerEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsBridge>
internal class TypedEventHandlerCoreWindow_PointerEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.PointerEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.PointerEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CPointerEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_PointerEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x197654c9, Data2: 0x0c47, Data3: 0x502b, Data4: ( 0x9a,0xa1,0x0d,0xeb,0x03,0xed,0x97,0x02 ))// 197654c9-0c47-502b-9aa1-0deb03ed9702
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.TouchHitTestingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsBridge>
internal class TypedEventHandlerCoreWindow_TouchHitTestingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.TouchHitTestingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.TouchHitTestingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CTouchHitTestingEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_TouchHitTestingEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x14b7f692, Data2: 0x5583, Data3: 0x52a1, Data4: ( 0xaa,0x42,0xfc,0x18,0x43,0xc0,0xf7,0x48 ))// 14b7f692-5583-52a1-aa42-fc1843c0f748
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.VisibilityChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsBridge>
internal class TypedEventHandlerCoreWindow_VisibilityChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.VisibilityChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.VisibilityChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CVisibilityChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_VisibilityChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x26a73b35, Data2: 0xa7f9, Data3: 0x52db, Data4: ( 0x88,0xd6,0x15,0x72,0x6d,0xeb,0x25,0x23 ))// 26a73b35-a7f9-52db-88d6-15726deb2523
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.WindowActivatedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsBridge>
internal class TypedEventHandlerCoreWindow_WindowActivatedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.WindowActivatedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.WindowActivatedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowActivatedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_WindowActivatedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x318dbb67, Data2: 0x4089, Data3: 0x5690, Data4: ( 0x90,0x40,0x1d,0x45,0x4f,0xb2,0xf6,0x86 ))// 318dbb67-4089-5690-9040-1d454fb2f686
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.CoreWindow? = .from(abi: ComPtr($1))
        let args: UWP.WindowSizeChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsBridge>
internal class TypedEventHandlerCoreWindow_WindowSizeChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.CoreWindow?, _ args: UWP.WindowSizeChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.CoreWindow?, UWP.WindowSizeChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CCoreWindow___x_ABI_CWindows__CUI__CCore__CWindowSizeChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerCoreWindow_WindowSizeChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x29742d27, Data2: 0x177d, Data3: 0x54c3, Data4: ( 0xb9,0x74,0x61,0x6f,0xc4,0x5a,0x2b,0x0c ))// 29742d27-177d-54c3-b974-616fc45a2b0c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.AnyICorePointerRedirector? = __ABI_Windows_UI_Core.ICorePointerRedirectorWrapper.unwrapFrom(abi: ComPtr($1))
        let args: UWP.PointerEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsBridge>
internal class TypedEventHandlerICorePointerRedirector_PointerEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgs }

    internal func InvokeImpl(_ sender: UWP.AnyICorePointerRedirector?, _ args: UWP.PointerEventArgs?) throws {
        let senderWrapper = __ABI_Windows_UI_Core.ICorePointerRedirectorWrapper(sender)
        let _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.AnyICorePointerRedirector?, UWP.PointerEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CCore__CICorePointerRedirector___x_ABI_CWindows__CUI__CCore__CPointerEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerICorePointerRedirector_PointerEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x2dbdba9d, Data2: 0x20da, Data3: 0x519d, Data4: ( 0x90,0x78,0x09,0xf8,0x35,0xbc,0x5b,0xc7 ))// 2dbdba9d-20da-519d-9078-09f835bc5bc7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectable {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.UISettings? = .from(abi: ComPtr($1))
        let args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableBridge>
internal class TypedEventHandlerUISettings_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectable }

    internal func InvokeImpl(_ sender: UWP.UISettings?, _ args: Any?) throws {
        let argsWrapper = __ABI_.AnyWrapper(args)
        let _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectable.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.UISettings?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings_IInspectable
    internal typealias SwiftABI = UWP.TypedEventHandlerUISettings_Any

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x808aef30, Data2: 0x2660, Data3: 0x51b0, Data4: ( 0x9c,0x11,0xf7,0x5d,0xd4,0x20,0x06,0xb4 ))// 808aef30-2660-51b0-9c11-f75dd42006b4
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgs {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard let __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        let sender: UWP.UISettings? = .from(abi: ComPtr($1))
        let args: UWP.UISettingsAutoHideScrollBarsChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsWrapper = InterfaceWrapperBase<UWP.__x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsBridge>
internal class TypedEventHandlerUISettings_UISettingsAutoHideScrollBarsChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgs }

    internal func InvokeImpl(_ sender: UWP.UISettings?, _ args: UWP.UISettingsAutoHideScrollBarsChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<UWP.UISettings?, UWP.UISettingsAutoHideScrollBarsChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CWindows__CUI__CViewManagement__CUISettings___x_ABI_CWindows__CUI__CViewManagement__CUISettingsAutoHideScrollBarsChangedEventArgs
    internal typealias SwiftABI = UWP.TypedEventHandlerUISettings_UISettingsAutoHideScrollBarsChangedEventArgs

    internal static func from(abi: ComPtr<CABI>?) -> Handler? {
        guard let abi = abi else { return nil }
        let _default = SwiftABI(abi)
        let handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
public extension EventSource where Handler == TypedEventHandler<ISingleSelectMediaTrackList?, Any?> {
    func invoke(_ sender: UWP.AnyISingleSelectMediaTrackList!, _ args: Any!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<IStorageQueryResultBase?, Any?> {
    func invoke(_ sender: UWP.AnyIStorageQueryResultBase!, _ args: Any!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreDispatcher?, AcceleratorKeyEventArgs?> {
    func invoke(_ sender: UWP.CoreDispatcher!, _ args: UWP.AcceleratorKeyEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, AutomationProviderRequestedEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.AutomationProviderRequestedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, CharacterReceivedEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.CharacterReceivedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, CoreWindowEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.CoreWindowEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, InputEnabledEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.InputEnabledEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, KeyEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.KeyEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, PointerEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.PointerEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, TouchHitTestingEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.TouchHitTestingEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, VisibilityChangedEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.VisibilityChangedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, WindowActivatedEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.WindowActivatedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<CoreWindow?, WindowSizeChangedEventArgs?> {
    func invoke(_ sender: UWP.CoreWindow!, _ args: UWP.WindowSizeChangedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<ICorePointerRedirector?, PointerEventArgs?> {
    func invoke(_ sender: UWP.AnyICorePointerRedirector!, _ args: UWP.PointerEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

