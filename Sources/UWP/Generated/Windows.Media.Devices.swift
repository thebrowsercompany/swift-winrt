// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.advancedphotomode)
public typealias AdvancedPhotoMode = __x_ABI_CWindows_CMedia_CDevices_CAdvancedPhotoMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.audiodevicerole)
public typealias AudioDeviceRole = __x_ABI_CWindows_CMedia_CDevices_CAudioDeviceRole
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.autofocusrange)
public typealias AutoFocusRange = __x_ABI_CWindows_CMedia_CDevices_CAutoFocusRange
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.capturescenemode)
public typealias CaptureSceneMode = __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.captureuse)
public typealias CaptureUse = __x_ABI_CWindows_CMedia_CDevices_CCaptureUse
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.colortemperaturepreset)
public typealias ColorTemperaturePreset = __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focusmode)
public typealias FocusMode = __x_ABI_CWindows_CMedia_CDevices_CFocusMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuspreset)
public typealias FocusPreset = __x_ABI_CWindows_CMedia_CDevices_CFocusPreset
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.hdrvideomode)
public typealias HdrVideoMode = __x_ABI_CWindows_CMedia_CDevices_CHdrVideoMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchmode)
public typealias InfraredTorchMode = __x_ABI_CWindows_CMedia_CDevices_CInfraredTorchMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedpreset)
public typealias IsoSpeedPreset = __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.manualfocusdistance)
public typealias ManualFocusDistance = __x_ABI_CWindows_CMedia_CDevices_CManualFocusDistance
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediacapturefocusstate)
public typealias MediaCaptureFocusState = __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureFocusState
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediacaptureoptimization)
public typealias MediaCaptureOptimization = __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureOptimization
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.opticalimagestabilizationmode)
public typealias OpticalImageStabilizationMode = __x_ABI_CWindows_CMedia_CDevices_COpticalImageStabilizationMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinteresttype)
public typealias RegionOfInterestType = __x_ABI_CWindows_CMedia_CDevices_CRegionOfInterestType
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontrollergetdevicepropertystatus)
public typealias VideoDeviceControllerGetDevicePropertyStatus = __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerGetDevicePropertyStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontrollersetdevicepropertystatus)
public typealias VideoDeviceControllerSetDevicePropertyStatus = __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerSetDevicePropertyStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videotemporaldenoisingmode)
public typealias VideoTemporalDenoisingMode = __x_ABI_CWindows_CMedia_CDevices_CVideoTemporalDenoisingMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomtransitionmode)
public typealias ZoomTransitionMode = __x_ABI_CWindows_CMedia_CDevices_CZoomTransitionMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.advancedphotocapturesettings)
public final class AdvancedPhotoCaptureSettings : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IAdvancedPhotoCaptureSettings
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIAdvancedPhotoCaptureSettings
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIAdvancedPhotoCaptureSettings>?) -> AdvancedPhotoCaptureSettings? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Devices.AdvancedPhotoCaptureSettings")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.advancedphotocapturesettings.mode)
    public var mode : AdvancedPhotoMode {
        get { try! _default.get_ModeImpl() }
        set { try! _default.put_ModeImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.advancedphotocontrol)
public final class AdvancedPhotoControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IAdvancedPhotoControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIAdvancedPhotoControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIAdvancedPhotoControl>?) -> AdvancedPhotoControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.advancedphotocontrol.configure)
    public func configure(_ settings: AdvancedPhotoCaptureSettings!) throws {
        try _default.ConfigureImpl(settings)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.advancedphotocontrol.mode)
    public var mode : AdvancedPhotoMode {
        get { try! _default.get_ModeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.advancedphotocontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.advancedphotocontrol.supportedmodes)
    public var supportedModes : WindowsFoundation.AnyIVectorView<AdvancedPhotoMode>! {
        get { try! _default.get_SupportedModesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.audiodevicecontroller)
public final class AudioDeviceController : WinRTClass, IMediaDeviceController {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IAudioDeviceController
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIAudioDeviceController
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIAudioDeviceController>?) -> AudioDeviceController? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IMediaDeviceController: __ABI_Windows_Media_Devices.IMediaDeviceController! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.audiodevicecontroller.getavailablemediastreamproperties)
    public func getAvailableMediaStreamProperties(_ mediaStreamType: UWP.MediaStreamType) throws -> WindowsFoundation.AnyIVectorView<UWP.AnyIMediaEncodingProperties?>! {
        try _IMediaDeviceController.GetAvailableMediaStreamPropertiesImpl(mediaStreamType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.audiodevicecontroller.getmediastreamproperties)
    public func getMediaStreamProperties(_ mediaStreamType: UWP.MediaStreamType) throws -> UWP.AnyIMediaEncodingProperties! {
        try _IMediaDeviceController.GetMediaStreamPropertiesImpl(mediaStreamType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.audiodevicecontroller.setmediastreampropertiesasync)
    public func setMediaStreamPropertiesAsync(_ mediaStreamType: UWP.MediaStreamType, _ mediaEncodingProperties: UWP.AnyIMediaEncodingProperties!) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _IMediaDeviceController.SetMediaStreamPropertiesAsyncImpl(mediaStreamType, mediaEncodingProperties)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.audiodevicecontroller.muted)
    public var muted : Bool {
        get { try! _default.get_MutedImpl() }
        set { try! _default.put_MutedImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.audiodevicecontroller.volumepercent)
    public var volumePercent : Float {
        get { try! _default.get_VolumePercentImpl() }
        set { try! _default.put_VolumePercentImpl(newValue) }
    }

    deinit {
        _IMediaDeviceController = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecompensationcontrol)
public final class ExposureCompensationControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IExposureCompensationControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIExposureCompensationControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIExposureCompensationControl>?) -> ExposureCompensationControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecompensationcontrol.setvalueasync)
    public func setValueAsync(_ value: Float) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetValueAsyncImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecompensationcontrol.max)
    public var max : Float {
        get { try! _default.get_MaxImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecompensationcontrol.min)
    public var min : Float {
        get { try! _default.get_MinImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecompensationcontrol.step)
    public var step : Float {
        get { try! _default.get_StepImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecompensationcontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecompensationcontrol.value)
    public var value : Float {
        get { try! _default.get_ValueImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol)
public final class ExposureControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IExposureControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIExposureControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIExposureControl>?) -> ExposureControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol.setautoasync)
    public func setAutoAsync(_ value: Bool) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetAutoAsyncImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol.setvalueasync)
    public func setValueAsync(_ shutterDuration: WindowsFoundation.TimeSpan) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetValueAsyncImpl(shutterDuration)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol.auto)
    public var auto : Bool {
        get { try! _default.get_AutoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol.max)
    public var max : WindowsFoundation.TimeSpan {
        get { try! _default.get_MaxImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol.min)
    public var min : WindowsFoundation.TimeSpan {
        get { try! _default.get_MinImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol.step)
    public var step : WindowsFoundation.TimeSpan {
        get { try! _default.get_StepImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurecontrol.value)
    public var value : WindowsFoundation.TimeSpan {
        get { try! _default.get_ValueImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurepriorityvideocontrol)
public final class ExposurePriorityVideoControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IExposurePriorityVideoControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIExposurePriorityVideoControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIExposurePriorityVideoControl>?) -> ExposurePriorityVideoControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurepriorityvideocontrol.enabled)
    public var enabled : Bool {
        get { try! _default.get_EnabledImpl() }
        set { try! _default.put_EnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.exposurepriorityvideocontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol)
public final class FlashControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IFlashControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIFlashControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIFlashControl>?) -> FlashControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.auto)
    public var auto : Bool {
        get { try! _default.get_AutoImpl() }
        set { try! _default.put_AutoImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.enabled)
    public var enabled : Bool {
        get { try! _default.get_EnabledImpl() }
        set { try! _default.put_EnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.powerpercent)
    public var powerPercent : Float {
        get { try! _default.get_PowerPercentImpl() }
        set { try! _default.put_PowerPercentImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.powersupported)
    public var powerSupported : Bool {
        get { try! _default.get_PowerSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.redeyereduction)
    public var redEyeReduction : Bool {
        get { try! _default.get_RedEyeReductionImpl() }
        set { try! _default.put_RedEyeReductionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.redeyereductionsupported)
    public var redEyeReductionSupported : Bool {
        get { try! _default.get_RedEyeReductionSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    private lazy var _IFlashControl2: __ABI_Windows_Media_Devices.IFlashControl2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.assistantlightenabled)
    public var assistantLightEnabled : Bool {
        get { try! _IFlashControl2.get_AssistantLightEnabledImpl() }
        set { try! _IFlashControl2.put_AssistantLightEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.flashcontrol.assistantlightsupported)
    public var assistantLightSupported : Bool {
        get { try! _IFlashControl2.get_AssistantLightSupportedImpl() }
    }

    deinit {
        _default = nil
        _IFlashControl2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol)
public final class FocusControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IFocusControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIFocusControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIFocusControl>?) -> FocusControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.setpresetasync)
    public func setPresetAsync(_ preset: FocusPreset) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetPresetAsyncImpl(preset)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.setpresetasync)
    public func setPresetAsync(_ preset: FocusPreset, _ completeBeforeFocus: Bool) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetPresetWithCompletionOptionAsyncImpl(preset, completeBeforeFocus)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.setvalueasync)
    public func setValueAsync(_ focus: UInt32) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetValueAsyncImpl(focus)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.focusasync)
    public func focusAsync() throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.FocusAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.max)
    public var max : UInt32 {
        get { try! _default.get_MaxImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.min)
    public var min : UInt32 {
        get { try! _default.get_MinImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.preset)
    public var preset : FocusPreset {
        get { try! _default.get_PresetImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.step)
    public var step : UInt32 {
        get { try! _default.get_StepImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.supportedpresets)
    public var supportedPresets : WindowsFoundation.AnyIVectorView<FocusPreset>! {
        get { try! _default.get_SupportedPresetsImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.value)
    public var value : UInt32 {
        get { try! _default.get_ValueImpl() }
    }

    private lazy var _IFocusControl2: __ABI_Windows_Media_Devices.IFocusControl2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.unlockasync)
    public func unlockAsync() throws -> WindowsFoundation.AnyIAsyncAction! {
        try _IFocusControl2.UnlockAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.lockasync)
    public func lockAsync() throws -> WindowsFoundation.AnyIAsyncAction! {
        try _IFocusControl2.LockAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.configure)
    public func configure(_ settings: FocusSettings!) throws {
        try _IFocusControl2.ConfigureImpl(settings)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.focuschangedsupported)
    public var focusChangedSupported : Bool {
        get { try! _IFocusControl2.get_FocusChangedSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.focusstate)
    public var focusState : MediaCaptureFocusState {
        get { try! _IFocusControl2.get_FocusStateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.mode)
    public var mode : FocusMode {
        get { try! _IFocusControl2.get_ModeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.supportedfocusdistances)
    public var supportedFocusDistances : WindowsFoundation.AnyIVectorView<ManualFocusDistance>! {
        get { try! _IFocusControl2.get_SupportedFocusDistancesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.supportedfocusmodes)
    public var supportedFocusModes : WindowsFoundation.AnyIVectorView<FocusMode>! {
        get { try! _IFocusControl2.get_SupportedFocusModesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.supportedfocusranges)
    public var supportedFocusRanges : WindowsFoundation.AnyIVectorView<AutoFocusRange>! {
        get { try! _IFocusControl2.get_SupportedFocusRangesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focuscontrol.waitforfocussupported)
    public var waitForFocusSupported : Bool {
        get { try! _IFocusControl2.get_WaitForFocusSupportedImpl() }
    }

    deinit {
        _default = nil
        _IFocusControl2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focussettings)
public final class FocusSettings : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IFocusSettings
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIFocusSettings
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIFocusSettings>?) -> FocusSettings? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Devices.FocusSettings")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focussettings.autofocusrange)
    public var autoFocusRange : AutoFocusRange {
        get { try! _default.get_AutoFocusRangeImpl() }
        set { try! _default.put_AutoFocusRangeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focussettings.disabledriverfallback)
    public var disableDriverFallback : Bool {
        get { try! _default.get_DisableDriverFallbackImpl() }
        set { try! _default.put_DisableDriverFallbackImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focussettings.distance)
    public var distance : ManualFocusDistance? {
        get { try! _default.get_DistanceImpl() }
        set { try! _default.put_DistanceImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focussettings.mode)
    public var mode : FocusMode {
        get { try! _default.get_ModeImpl() }
        set { try! _default.put_ModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focussettings.value)
    public var value : UInt32? {
        get { try! _default.get_ValueImpl() }
        set { try! _default.put_ValueImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.focussettings.waitforfocus)
    public var waitForFocus : Bool {
        get { try! _default.get_WaitForFocusImpl() }
        set { try! _default.put_WaitForFocusImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.hdrvideocontrol)
public final class HdrVideoControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IHdrVideoControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIHdrVideoControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIHdrVideoControl>?) -> HdrVideoControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.hdrvideocontrol.mode)
    public var mode : HdrVideoMode {
        get { try! _default.get_ModeImpl() }
        set { try! _default.put_ModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.hdrvideocontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.hdrvideocontrol.supportedmodes)
    public var supportedModes : WindowsFoundation.AnyIVectorView<HdrVideoMode>! {
        get { try! _default.get_SupportedModesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchcontrol)
public final class InfraredTorchControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IInfraredTorchControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIInfraredTorchControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIInfraredTorchControl>?) -> InfraredTorchControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchcontrol.currentmode)
    public var currentMode : InfraredTorchMode {
        get { try! _default.get_CurrentModeImpl() }
        set { try! _default.put_CurrentModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchcontrol.issupported)
    public var isSupported : Bool {
        get { try! _default.get_IsSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchcontrol.maxpower)
    public var maxPower : Int32 {
        get { try! _default.get_MaxPowerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchcontrol.minpower)
    public var minPower : Int32 {
        get { try! _default.get_MinPowerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchcontrol.power)
    public var power : Int32 {
        get { try! _default.get_PowerImpl() }
        set { try! _default.put_PowerImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchcontrol.powerstep)
    public var powerStep : Int32 {
        get { try! _default.get_PowerStepImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.infraredtorchcontrol.supportedmodes)
    public var supportedModes : WindowsFoundation.AnyIVectorView<InfraredTorchMode>! {
        get { try! _default.get_SupportedModesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol)
public final class IsoSpeedControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IIsoSpeedControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIIsoSpeedControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIIsoSpeedControl>?) -> IsoSpeedControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.setpresetasync)
    public func setPresetAsync(_ preset: IsoSpeedPreset) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetPresetAsyncImpl(preset)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.preset)
    public var preset : IsoSpeedPreset {
        get { try! _default.get_PresetImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.supportedpresets)
    public var supportedPresets : WindowsFoundation.AnyIVectorView<IsoSpeedPreset>! {
        get { try! _default.get_SupportedPresetsImpl() }
    }

    private lazy var _IIsoSpeedControl2: __ABI_Windows_Media_Devices.IIsoSpeedControl2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.setvalueasync)
    public func setValueAsync(_ isoSpeed: UInt32) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _IIsoSpeedControl2.SetValueAsyncImpl(isoSpeed)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.setautoasync)
    public func setAutoAsync() throws -> WindowsFoundation.AnyIAsyncAction! {
        try _IIsoSpeedControl2.SetAutoAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.auto)
    public var auto : Bool {
        get { try! _IIsoSpeedControl2.get_AutoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.max)
    public var max : UInt32 {
        get { try! _IIsoSpeedControl2.get_MaxImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.min)
    public var min : UInt32 {
        get { try! _IIsoSpeedControl2.get_MinImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.step)
    public var step : UInt32 {
        get { try! _IIsoSpeedControl2.get_StepImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.isospeedcontrol.value)
    public var value : UInt32 {
        get { try! _IIsoSpeedControl2.get_ValueImpl() }
    }

    deinit {
        _default = nil
        _IIsoSpeedControl2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotocontrol)
public final class LowLagPhotoControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.ILowLagPhotoControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CILowLagPhotoControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CILowLagPhotoControl>?) -> LowLagPhotoControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotocontrol.gethighestconcurrentframerate)
    public func getHighestConcurrentFrameRate(_ captureProperties: UWP.AnyIMediaEncodingProperties!) throws -> UWP.MediaRatio! {
        try _default.GetHighestConcurrentFrameRateImpl(captureProperties)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotocontrol.getcurrentframerate)
    public func getCurrentFrameRate() throws -> UWP.MediaRatio! {
        try _default.GetCurrentFrameRateImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotocontrol.desiredthumbnailsize)
    public var desiredThumbnailSize : UInt32 {
        get { try! _default.get_DesiredThumbnailSizeImpl() }
        set { try! _default.put_DesiredThumbnailSizeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotocontrol.hardwareacceleratedthumbnailsupported)
    public var hardwareAcceleratedThumbnailSupported : UInt32 {
        get { try! _default.get_HardwareAcceleratedThumbnailSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotocontrol.thumbnailenabled)
    public var thumbnailEnabled : Bool {
        get { try! _default.get_ThumbnailEnabledImpl() }
        set { try! _default.put_ThumbnailEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotocontrol.thumbnailformat)
    public var thumbnailFormat : UWP.MediaThumbnailFormat {
        get { try! _default.get_ThumbnailFormatImpl() }
        set { try! _default.put_ThumbnailFormatImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol)
public final class LowLagPhotoSequenceControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.ILowLagPhotoSequenceControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CILowLagPhotoSequenceControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CILowLagPhotoSequenceControl>?) -> LowLagPhotoSequenceControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.gethighestconcurrentframerate)
    public func getHighestConcurrentFrameRate(_ captureProperties: UWP.AnyIMediaEncodingProperties!) throws -> UWP.MediaRatio! {
        try _default.GetHighestConcurrentFrameRateImpl(captureProperties)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.getcurrentframerate)
    public func getCurrentFrameRate() throws -> UWP.MediaRatio! {
        try _default.GetCurrentFrameRateImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.desiredthumbnailsize)
    public var desiredThumbnailSize : UInt32 {
        get { try! _default.get_DesiredThumbnailSizeImpl() }
        set { try! _default.put_DesiredThumbnailSizeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.hardwareacceleratedthumbnailsupported)
    public var hardwareAcceleratedThumbnailSupported : UInt32 {
        get { try! _default.get_HardwareAcceleratedThumbnailSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.maxpastphotos)
    public var maxPastPhotos : UInt32 {
        get { try! _default.get_MaxPastPhotosImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.maxphotospersecond)
    public var maxPhotosPerSecond : Float {
        get { try! _default.get_MaxPhotosPerSecondImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.pastphotolimit)
    public var pastPhotoLimit : UInt32 {
        get { try! _default.get_PastPhotoLimitImpl() }
        set { try! _default.put_PastPhotoLimitImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.photospersecondlimit)
    public var photosPerSecondLimit : Float {
        get { try! _default.get_PhotosPerSecondLimitImpl() }
        set { try! _default.put_PhotosPerSecondLimitImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.thumbnailenabled)
    public var thumbnailEnabled : Bool {
        get { try! _default.get_ThumbnailEnabledImpl() }
        set { try! _default.put_ThumbnailEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.lowlagphotosequencecontrol.thumbnailformat)
    public var thumbnailFormat : UWP.MediaThumbnailFormat {
        get { try! _default.get_ThumbnailFormatImpl() }
        set { try! _default.put_ThumbnailFormatImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrol)
public final class MediaDeviceControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IMediaDeviceControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIMediaDeviceControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIMediaDeviceControl>?) -> MediaDeviceControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrol.trygetvalue)
    public func tryGetValue(_ value: inout Double) throws -> Bool {
        try _default.TryGetValueImpl(&value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrol.trysetvalue)
    public func trySetValue(_ value: Double) throws -> Bool {
        try _default.TrySetValueImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrol.trygetauto)
    public func tryGetAuto(_ value: inout Bool) throws -> Bool {
        try _default.TryGetAutoImpl(&value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrol.trysetauto)
    public func trySetAuto(_ value: Bool) throws -> Bool {
        try _default.TrySetAutoImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrol.capabilities)
    public var capabilities : MediaDeviceControlCapabilities! {
        get { try! _default.get_CapabilitiesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrolcapabilities)
public final class MediaDeviceControlCapabilities : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IMediaDeviceControlCapabilities
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIMediaDeviceControlCapabilities
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIMediaDeviceControlCapabilities>?) -> MediaDeviceControlCapabilities? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrolcapabilities.automodesupported)
    public var autoModeSupported : Bool {
        get { try! _default.get_AutoModeSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrolcapabilities.default)
    public var `default` : Double {
        get { try! _default.get_DefaultImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrolcapabilities.max)
    public var max : Double {
        get { try! _default.get_MaxImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrolcapabilities.min)
    public var min : Double {
        get { try! _default.get_MinImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrolcapabilities.step)
    public var step : Double {
        get { try! _default.get_StepImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.mediadevicecontrolcapabilities.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.opticalimagestabilizationcontrol)
public final class OpticalImageStabilizationControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IOpticalImageStabilizationControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIOpticalImageStabilizationControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIOpticalImageStabilizationControl>?) -> OpticalImageStabilizationControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.opticalimagestabilizationcontrol.mode)
    public var mode : OpticalImageStabilizationMode {
        get { try! _default.get_ModeImpl() }
        set { try! _default.put_ModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.opticalimagestabilizationcontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.opticalimagestabilizationcontrol.supportedmodes)
    public var supportedModes : WindowsFoundation.AnyIVectorView<OpticalImageStabilizationMode>! {
        get { try! _default.get_SupportedModesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.photoconfirmationcontrol)
public final class PhotoConfirmationControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IPhotoConfirmationControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIPhotoConfirmationControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIPhotoConfirmationControl>?) -> PhotoConfirmationControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.photoconfirmationcontrol.enabled)
    public var enabled : Bool {
        get { try! _default.get_EnabledImpl() }
        set { try! _default.put_EnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.photoconfirmationcontrol.pixelformat)
    public var pixelFormat : UWP.MediaPixelFormat {
        get { try! _default.get_PixelFormatImpl() }
        set { try! _default.put_PixelFormatImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.photoconfirmationcontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinterest)
public final class RegionOfInterest : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IRegionOfInterest
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIRegionOfInterest
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIRegionOfInterest>?) -> RegionOfInterest? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Devices.RegionOfInterest")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinterest.autoexposureenabled)
    public var autoExposureEnabled : Bool {
        get { try! _default.get_AutoExposureEnabledImpl() }
        set { try! _default.put_AutoExposureEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinterest.autofocusenabled)
    public var autoFocusEnabled : Bool {
        get { try! _default.get_AutoFocusEnabledImpl() }
        set { try! _default.put_AutoFocusEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinterest.autowhitebalanceenabled)
    public var autoWhiteBalanceEnabled : Bool {
        get { try! _default.get_AutoWhiteBalanceEnabledImpl() }
        set { try! _default.put_AutoWhiteBalanceEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinterest.bounds)
    public var bounds : WindowsFoundation.Rect {
        get { try! _default.get_BoundsImpl() }
        set { try! _default.put_BoundsImpl(newValue) }
    }

    private lazy var _IRegionOfInterest2: __ABI_Windows_Media_Devices.IRegionOfInterest2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinterest.boundsnormalized)
    public var boundsNormalized : Bool {
        get { try! _IRegionOfInterest2.get_BoundsNormalizedImpl() }
        set { try! _IRegionOfInterest2.put_BoundsNormalizedImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinterest.type)
    public var type : RegionOfInterestType {
        get { try! _IRegionOfInterest2.get_TypeImpl() }
        set { try! _IRegionOfInterest2.put_TypeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionofinterest.weight)
    public var weight : UInt32 {
        get { try! _IRegionOfInterest2.get_WeightImpl() }
        set { try! _IRegionOfInterest2.put_WeightImpl(newValue) }
    }

    deinit {
        _default = nil
        _IRegionOfInterest2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionsofinterestcontrol)
public final class RegionsOfInterestControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IRegionsOfInterestControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIRegionsOfInterestControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIRegionsOfInterestControl>?) -> RegionsOfInterestControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionsofinterestcontrol.setregionsasync)
    public func setRegionsAsync(_ regions: WindowsFoundation.AnyIIterable<RegionOfInterest?>!) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetRegionsAsyncImpl(regions)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionsofinterestcontrol.setregionsasync)
    public func setRegionsAsync(_ regions: WindowsFoundation.AnyIIterable<RegionOfInterest?>!, _ lockValues: Bool) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetRegionsWithLockAsyncImpl(regions, lockValues)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionsofinterestcontrol.clearregionsasync)
    public func clearRegionsAsync() throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.ClearRegionsAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionsofinterestcontrol.autoexposuresupported)
    public var autoExposureSupported : Bool {
        get { try! _default.get_AutoExposureSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionsofinterestcontrol.autofocussupported)
    public var autoFocusSupported : Bool {
        get { try! _default.get_AutoFocusSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionsofinterestcontrol.autowhitebalancesupported)
    public var autoWhiteBalanceSupported : Bool {
        get { try! _default.get_AutoWhiteBalanceSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.regionsofinterestcontrol.maxregions)
    public var maxRegions : UInt32 {
        get { try! _default.get_MaxRegionsImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.scenemodecontrol)
public final class SceneModeControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.ISceneModeControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CISceneModeControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CISceneModeControl>?) -> SceneModeControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.scenemodecontrol.setvalueasync)
    public func setValueAsync(_ sceneMode: CaptureSceneMode) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetValueAsyncImpl(sceneMode)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.scenemodecontrol.supportedmodes)
    public var supportedModes : WindowsFoundation.AnyIVectorView<CaptureSceneMode>! {
        get { try! _default.get_SupportedModesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.scenemodecontrol.value)
    public var value : CaptureSceneMode {
        get { try! _default.get_ValueImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.torchcontrol)
public final class TorchControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.ITorchControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CITorchControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CITorchControl>?) -> TorchControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.torchcontrol.enabled)
    public var enabled : Bool {
        get { try! _default.get_EnabledImpl() }
        set { try! _default.put_EnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.torchcontrol.powerpercent)
    public var powerPercent : Float {
        get { try! _default.get_PowerPercentImpl() }
        set { try! _default.put_PowerPercentImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.torchcontrol.powersupported)
    public var powerSupported : Bool {
        get { try! _default.get_PowerSupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.torchcontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller)
public final class VideoDeviceController : WinRTClass, IMediaDeviceController {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IVideoDeviceController
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIVideoDeviceController
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIVideoDeviceController>?) -> VideoDeviceController? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IMediaDeviceController: __ABI_Windows_Media_Devices.IMediaDeviceController! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.getavailablemediastreamproperties)
    public func getAvailableMediaStreamProperties(_ mediaStreamType: UWP.MediaStreamType) throws -> WindowsFoundation.AnyIVectorView<UWP.AnyIMediaEncodingProperties?>! {
        try _IMediaDeviceController.GetAvailableMediaStreamPropertiesImpl(mediaStreamType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.getmediastreamproperties)
    public func getMediaStreamProperties(_ mediaStreamType: UWP.MediaStreamType) throws -> UWP.AnyIMediaEncodingProperties! {
        try _IMediaDeviceController.GetMediaStreamPropertiesImpl(mediaStreamType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.setmediastreampropertiesasync)
    public func setMediaStreamPropertiesAsync(_ mediaStreamType: UWP.MediaStreamType, _ mediaEncodingProperties: UWP.AnyIMediaEncodingProperties!) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _IMediaDeviceController.SetMediaStreamPropertiesAsyncImpl(mediaStreamType, mediaEncodingProperties)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.trysetpowerlinefrequency)
    public func trySetPowerlineFrequency(_ value: UWP.PowerlineFrequency) throws -> Bool {
        try _default.TrySetPowerlineFrequencyImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.trygetpowerlinefrequency)
    public func tryGetPowerlineFrequency(_ value: inout UWP.PowerlineFrequency) throws -> Bool {
        try _default.TryGetPowerlineFrequencyImpl(&value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.backlightcompensation)
    public var backlightCompensation : MediaDeviceControl! {
        get { try! _default.get_BacklightCompensationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.brightness)
    public var brightness : MediaDeviceControl! {
        get { try! _default.get_BrightnessImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.contrast)
    public var contrast : MediaDeviceControl! {
        get { try! _default.get_ContrastImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.exposure)
    public var exposure : MediaDeviceControl! {
        get { try! _default.get_ExposureImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.focus)
    public var focus : MediaDeviceControl! {
        get { try! _default.get_FocusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.hue)
    public var hue : MediaDeviceControl! {
        get { try! _default.get_HueImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.pan)
    public var pan : MediaDeviceControl! {
        get { try! _default.get_PanImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.roll)
    public var roll : MediaDeviceControl! {
        get { try! _default.get_RollImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.tilt)
    public var tilt : MediaDeviceControl! {
        get { try! _default.get_TiltImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.whitebalance)
    public var whiteBalance : MediaDeviceControl! {
        get { try! _default.get_WhiteBalanceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.zoom)
    public var zoom : MediaDeviceControl! {
        get { try! _default.get_ZoomImpl() }
    }

    private lazy var _IAdvancedVideoCaptureDeviceController: __ABI_Windows_Media_Devices.IAdvancedVideoCaptureDeviceController! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.setdeviceproperty)
    public func setDeviceProperty(_ propertyId: String, _ propertyValue: Any!) throws {
        try _IAdvancedVideoCaptureDeviceController.SetDevicePropertyImpl(propertyId, propertyValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.getdeviceproperty)
    public func getDeviceProperty(_ propertyId: String) throws -> Any! {
        try _IAdvancedVideoCaptureDeviceController.GetDevicePropertyImpl(propertyId)
    }

    private lazy var _IAdvancedVideoCaptureDeviceController2: __ABI_Windows_Media_Devices.IAdvancedVideoCaptureDeviceController2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.exposurecompensationcontrol)
    public var exposureCompensationControl : ExposureCompensationControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_ExposureCompensationControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.exposurecontrol)
    public var exposureControl : ExposureControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_ExposureControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.flashcontrol)
    public var flashControl : FlashControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_FlashControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.focuscontrol)
    public var focusControl : FocusControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_FocusControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.isospeedcontrol)
    public var isoSpeedControl : IsoSpeedControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_IsoSpeedControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.lowlagphoto)
    public var lowLagPhoto : LowLagPhotoControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_LowLagPhotoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.lowlagphotosequence)
    public var lowLagPhotoSequence : LowLagPhotoSequenceControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_LowLagPhotoSequenceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.primaryuse)
    public var primaryUse : CaptureUse {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_PrimaryUseImpl() }
        set { try! _IAdvancedVideoCaptureDeviceController2.put_PrimaryUseImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.regionsofinterestcontrol)
    public var regionsOfInterestControl : RegionsOfInterestControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_RegionsOfInterestControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.scenemodecontrol)
    public var sceneModeControl : SceneModeControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_SceneModeControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.torchcontrol)
    public var torchControl : TorchControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_TorchControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.whitebalancecontrol)
    public var whiteBalanceControl : WhiteBalanceControl! {
        get { try! _IAdvancedVideoCaptureDeviceController2.get_WhiteBalanceControlImpl() }
    }

    private lazy var _IAdvancedVideoCaptureDeviceController3: __ABI_Windows_Media_Devices.IAdvancedVideoCaptureDeviceController3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.photoconfirmationcontrol)
    public var photoConfirmationControl : PhotoConfirmationControl! {
        get { try! _IAdvancedVideoCaptureDeviceController3.get_PhotoConfirmationControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.variablephotosequencecontroller)
    public var variablePhotoSequenceController : UWP.VariablePhotoSequenceController! {
        get { try! _IAdvancedVideoCaptureDeviceController3.get_VariablePhotoSequenceControllerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.zoomcontrol)
    public var zoomControl : ZoomControl! {
        get { try! _IAdvancedVideoCaptureDeviceController3.get_ZoomControlImpl() }
    }

    private lazy var _IAdvancedVideoCaptureDeviceController4: __ABI_Windows_Media_Devices.IAdvancedVideoCaptureDeviceController4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.advancedphotocontrol)
    public var advancedPhotoControl : AdvancedPhotoControl! {
        get { try! _IAdvancedVideoCaptureDeviceController4.get_AdvancedPhotoControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.desiredoptimization)
    public var desiredOptimization : MediaCaptureOptimization {
        get { try! _IAdvancedVideoCaptureDeviceController4.get_DesiredOptimizationImpl() }
        set { try! _IAdvancedVideoCaptureDeviceController4.put_DesiredOptimizationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.exposurepriorityvideocontrol)
    public var exposurePriorityVideoControl : ExposurePriorityVideoControl! {
        get { try! _IAdvancedVideoCaptureDeviceController4.get_ExposurePriorityVideoControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.hdrvideocontrol)
    public var hdrVideoControl : HdrVideoControl! {
        get { try! _IAdvancedVideoCaptureDeviceController4.get_HdrVideoControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.opticalimagestabilizationcontrol)
    public var opticalImageStabilizationControl : OpticalImageStabilizationControl! {
        get { try! _IAdvancedVideoCaptureDeviceController4.get_OpticalImageStabilizationControlImpl() }
    }

    private lazy var _IAdvancedVideoCaptureDeviceController5: __ABI_Windows_Media_Devices.IAdvancedVideoCaptureDeviceController5! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.getdevicepropertybyid)
    public func getDevicePropertyById(_ propertyId: String, _ maxPropertyValueSize: UInt32?) throws -> VideoDeviceControllerGetDevicePropertyResult! {
        try _IAdvancedVideoCaptureDeviceController5.GetDevicePropertyByIdImpl(propertyId, maxPropertyValueSize)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.setdevicepropertybyid)
    public func setDevicePropertyById(_ propertyId: String, _ propertyValue: Any!) throws -> VideoDeviceControllerSetDevicePropertyStatus {
        try _IAdvancedVideoCaptureDeviceController5.SetDevicePropertyByIdImpl(propertyId, propertyValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.id)
    public var id : String {
        get { try! _IAdvancedVideoCaptureDeviceController5.get_IdImpl() }
    }

    private lazy var _IAdvancedVideoCaptureDeviceController6: __ABI_Windows_Media_Devices.IAdvancedVideoCaptureDeviceController6! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.videotemporaldenoisingcontrol)
    public var videoTemporalDenoisingControl : VideoTemporalDenoisingControl! {
        get { try! _IAdvancedVideoCaptureDeviceController6.get_VideoTemporalDenoisingControlImpl() }
    }

    private lazy var _IAdvancedVideoCaptureDeviceController7: __ABI_Windows_Media_Devices.IAdvancedVideoCaptureDeviceController7! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontroller.infraredtorchcontrol)
    public var infraredTorchControl : InfraredTorchControl! {
        get { try! _IAdvancedVideoCaptureDeviceController7.get_InfraredTorchControlImpl() }
    }

    deinit {
        _IMediaDeviceController = nil
        _default = nil
        _IAdvancedVideoCaptureDeviceController = nil
        _IAdvancedVideoCaptureDeviceController2 = nil
        _IAdvancedVideoCaptureDeviceController3 = nil
        _IAdvancedVideoCaptureDeviceController4 = nil
        _IAdvancedVideoCaptureDeviceController5 = nil
        _IAdvancedVideoCaptureDeviceController6 = nil
        _IAdvancedVideoCaptureDeviceController7 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontrollergetdevicepropertyresult)
public final class VideoDeviceControllerGetDevicePropertyResult : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IVideoDeviceControllerGetDevicePropertyResult
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIVideoDeviceControllerGetDevicePropertyResult
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIVideoDeviceControllerGetDevicePropertyResult>?) -> VideoDeviceControllerGetDevicePropertyResult? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontrollergetdevicepropertyresult.status)
    public var status : VideoDeviceControllerGetDevicePropertyStatus {
        get { try! _default.get_StatusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videodevicecontrollergetdevicepropertyresult.value)
    public var value : Any! {
        get { try! _default.get_ValueImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videotemporaldenoisingcontrol)
public final class VideoTemporalDenoisingControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IVideoTemporalDenoisingControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIVideoTemporalDenoisingControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIVideoTemporalDenoisingControl>?) -> VideoTemporalDenoisingControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videotemporaldenoisingcontrol.mode)
    public var mode : VideoTemporalDenoisingMode {
        get { try! _default.get_ModeImpl() }
        set { try! _default.put_ModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videotemporaldenoisingcontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.videotemporaldenoisingcontrol.supportedmodes)
    public var supportedModes : WindowsFoundation.AnyIVectorView<VideoTemporalDenoisingMode>! {
        get { try! _default.get_SupportedModesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol)
public final class WhiteBalanceControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IWhiteBalanceControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIWhiteBalanceControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIWhiteBalanceControl>?) -> WhiteBalanceControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol.setpresetasync)
    public func setPresetAsync(_ preset: ColorTemperaturePreset) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetPresetAsyncImpl(preset)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol.setvalueasync)
    public func setValueAsync(_ temperature: UInt32) throws -> WindowsFoundation.AnyIAsyncAction! {
        try _default.SetValueAsyncImpl(temperature)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol.max)
    public var max : UInt32 {
        get { try! _default.get_MaxImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol.min)
    public var min : UInt32 {
        get { try! _default.get_MinImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol.preset)
    public var preset : ColorTemperaturePreset {
        get { try! _default.get_PresetImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol.step)
    public var step : UInt32 {
        get { try! _default.get_StepImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.whitebalancecontrol.value)
    public var value : UInt32 {
        get { try! _default.get_ValueImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol)
public final class ZoomControl : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IZoomControl
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIZoomControl
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIZoomControl>?) -> ZoomControl? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol.max)
    public var max : Float {
        get { try! _default.get_MaxImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol.min)
    public var min : Float {
        get { try! _default.get_MinImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol.step)
    public var step : Float {
        get { try! _default.get_StepImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol.supported)
    public var supported : Bool {
        get { try! _default.get_SupportedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol.value)
    public var value : Float {
        get { try! _default.get_ValueImpl() }
        set { try! _default.put_ValueImpl(newValue) }
    }

    private lazy var _IZoomControl2: __ABI_Windows_Media_Devices.IZoomControl2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol.configure)
    public func configure(_ settings: ZoomSettings!) throws {
        try _IZoomControl2.ConfigureImpl(settings)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol.mode)
    public var mode : ZoomTransitionMode {
        get { try! _IZoomControl2.get_ModeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomcontrol.supportedmodes)
    public var supportedModes : WindowsFoundation.AnyIVectorView<ZoomTransitionMode>! {
        get { try! _IZoomControl2.get_SupportedModesImpl() }
    }

    deinit {
        _default = nil
        _IZoomControl2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomsettings)
public final class ZoomSettings : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Devices.IZoomSettings
    private typealias CABI = __x_ABI_CWindows_CMedia_CDevices_CIZoomSettings
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CDevices_CIZoomSettings>?) -> ZoomSettings? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Devices.ZoomSettings")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomsettings.mode)
    public var mode : ZoomTransitionMode {
        get { try! _default.get_ModeImpl() }
        set { try! _default.put_ModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.zoomsettings.value)
    public var value : Float {
        get { try! _default.get_ValueImpl() }
        set { try! _default.put_ValueImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.imediadevicecontroller)
public protocol IMediaDeviceController : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.imediadevicecontroller.getavailablemediastreamproperties)
    func getAvailableMediaStreamProperties(_ mediaStreamType: UWP.MediaStreamType) throws -> WindowsFoundation.AnyIVectorView<UWP.AnyIMediaEncodingProperties?>!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.imediadevicecontroller.getmediastreamproperties)
    func getMediaStreamProperties(_ mediaStreamType: UWP.MediaStreamType) throws -> UWP.AnyIMediaEncodingProperties!
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.devices.imediadevicecontroller.setmediastreampropertiesasync)
    func setMediaStreamPropertiesAsync(_ mediaStreamType: UWP.MediaStreamType, _ mediaEncodingProperties: UWP.AnyIMediaEncodingProperties!) throws -> WindowsFoundation.AnyIAsyncAction!
}

extension IMediaDeviceController {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Devices.IMediaDeviceControllerWrapper.IID:
                let wrapper = __ABI_Windows_Media_Devices.IMediaDeviceControllerWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIMediaDeviceController = any IMediaDeviceController

extension UWP.AdvancedPhotoMode {
    public static var auto : UWP.AdvancedPhotoMode {
        __x_ABI_CWindows_CMedia_CDevices_CAdvancedPhotoMode_Auto
    }
    public static var standard : UWP.AdvancedPhotoMode {
        __x_ABI_CWindows_CMedia_CDevices_CAdvancedPhotoMode_Standard
    }
    public static var hdr : UWP.AdvancedPhotoMode {
        __x_ABI_CWindows_CMedia_CDevices_CAdvancedPhotoMode_Hdr
    }
    public static var lowLight : UWP.AdvancedPhotoMode {
        __x_ABI_CWindows_CMedia_CDevices_CAdvancedPhotoMode_LowLight
    }
}
extension UWP.AdvancedPhotoMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.AudioDeviceRole {
    public static var `default` : UWP.AudioDeviceRole {
        __x_ABI_CWindows_CMedia_CDevices_CAudioDeviceRole_Default
    }
    public static var communications : UWP.AudioDeviceRole {
        __x_ABI_CWindows_CMedia_CDevices_CAudioDeviceRole_Communications
    }
}
extension UWP.AudioDeviceRole: @retroactive Hashable, @retroactive Codable {}

extension UWP.AutoFocusRange {
    public static var fullRange : UWP.AutoFocusRange {
        __x_ABI_CWindows_CMedia_CDevices_CAutoFocusRange_FullRange
    }
    public static var macro : UWP.AutoFocusRange {
        __x_ABI_CWindows_CMedia_CDevices_CAutoFocusRange_Macro
    }
    public static var normal : UWP.AutoFocusRange {
        __x_ABI_CWindows_CMedia_CDevices_CAutoFocusRange_Normal
    }
}
extension UWP.AutoFocusRange: @retroactive Hashable, @retroactive Codable {}

extension UWP.CaptureSceneMode {
    public static var auto : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Auto
    }
    public static var manual : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Manual
    }
    public static var macro : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Macro
    }
    public static var portrait : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Portrait
    }
    public static var sport : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Sport
    }
    public static var snow : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Snow
    }
    public static var night : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Night
    }
    public static var beach : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Beach
    }
    public static var sunset : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Sunset
    }
    public static var candlelight : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Candlelight
    }
    public static var landscape : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Landscape
    }
    public static var nightPortrait : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_NightPortrait
    }
    public static var backlit : UWP.CaptureSceneMode {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureSceneMode_Backlit
    }
}
extension UWP.CaptureSceneMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.CaptureUse {
    public static var none : UWP.CaptureUse {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureUse_None
    }
    public static var photo : UWP.CaptureUse {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureUse_Photo
    }
    public static var video : UWP.CaptureUse {
        __x_ABI_CWindows_CMedia_CDevices_CCaptureUse_Video
    }
}
extension UWP.CaptureUse: @retroactive Hashable, @retroactive Codable {}

extension UWP.ColorTemperaturePreset {
    public static var auto : UWP.ColorTemperaturePreset {
        __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset_Auto
    }
    public static var manual : UWP.ColorTemperaturePreset {
        __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset_Manual
    }
    public static var cloudy : UWP.ColorTemperaturePreset {
        __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset_Cloudy
    }
    public static var daylight : UWP.ColorTemperaturePreset {
        __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset_Daylight
    }
    public static var flash : UWP.ColorTemperaturePreset {
        __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset_Flash
    }
    public static var fluorescent : UWP.ColorTemperaturePreset {
        __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset_Fluorescent
    }
    public static var tungsten : UWP.ColorTemperaturePreset {
        __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset_Tungsten
    }
    public static var candlelight : UWP.ColorTemperaturePreset {
        __x_ABI_CWindows_CMedia_CDevices_CColorTemperaturePreset_Candlelight
    }
}
extension UWP.ColorTemperaturePreset: @retroactive Hashable, @retroactive Codable {}

extension UWP.FocusMode {
    public static var auto : UWP.FocusMode {
        __x_ABI_CWindows_CMedia_CDevices_CFocusMode_Auto
    }
    public static var single : UWP.FocusMode {
        __x_ABI_CWindows_CMedia_CDevices_CFocusMode_Single
    }
    public static var continuous : UWP.FocusMode {
        __x_ABI_CWindows_CMedia_CDevices_CFocusMode_Continuous
    }
    public static var manual : UWP.FocusMode {
        __x_ABI_CWindows_CMedia_CDevices_CFocusMode_Manual
    }
}
extension UWP.FocusMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.FocusPreset {
    public static var auto : UWP.FocusPreset {
        __x_ABI_CWindows_CMedia_CDevices_CFocusPreset_Auto
    }
    public static var manual : UWP.FocusPreset {
        __x_ABI_CWindows_CMedia_CDevices_CFocusPreset_Manual
    }
    public static var autoMacro : UWP.FocusPreset {
        __x_ABI_CWindows_CMedia_CDevices_CFocusPreset_AutoMacro
    }
    public static var autoNormal : UWP.FocusPreset {
        __x_ABI_CWindows_CMedia_CDevices_CFocusPreset_AutoNormal
    }
    public static var autoInfinity : UWP.FocusPreset {
        __x_ABI_CWindows_CMedia_CDevices_CFocusPreset_AutoInfinity
    }
    public static var autoHyperfocal : UWP.FocusPreset {
        __x_ABI_CWindows_CMedia_CDevices_CFocusPreset_AutoHyperfocal
    }
}
extension UWP.FocusPreset: @retroactive Hashable, @retroactive Codable {}

extension UWP.HdrVideoMode {
    public static var off : UWP.HdrVideoMode {
        __x_ABI_CWindows_CMedia_CDevices_CHdrVideoMode_Off
    }
    public static var on : UWP.HdrVideoMode {
        __x_ABI_CWindows_CMedia_CDevices_CHdrVideoMode_On
    }
    public static var auto : UWP.HdrVideoMode {
        __x_ABI_CWindows_CMedia_CDevices_CHdrVideoMode_Auto
    }
}
extension UWP.HdrVideoMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.InfraredTorchMode {
    public static var off : UWP.InfraredTorchMode {
        __x_ABI_CWindows_CMedia_CDevices_CInfraredTorchMode_Off
    }
    public static var on : UWP.InfraredTorchMode {
        __x_ABI_CWindows_CMedia_CDevices_CInfraredTorchMode_On
    }
    public static var alternatingFrameIllumination : UWP.InfraredTorchMode {
        __x_ABI_CWindows_CMedia_CDevices_CInfraredTorchMode_AlternatingFrameIllumination
    }
}
extension UWP.InfraredTorchMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.IsoSpeedPreset {
    public static var auto : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Auto
    }
    public static var iso50 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso50
    }
    public static var iso80 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso80
    }
    public static var iso100 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso100
    }
    public static var iso200 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso200
    }
    public static var iso400 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso400
    }
    public static var iso800 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso800
    }
    public static var iso1600 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso1600
    }
    public static var iso3200 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso3200
    }
    public static var iso6400 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso6400
    }
    public static var iso12800 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso12800
    }
    public static var iso25600 : UWP.IsoSpeedPreset {
        __x_ABI_CWindows_CMedia_CDevices_CIsoSpeedPreset_Iso25600
    }
}
extension UWP.IsoSpeedPreset: @retroactive Hashable, @retroactive Codable {}

extension UWP.ManualFocusDistance {
    public static var infinity : UWP.ManualFocusDistance {
        __x_ABI_CWindows_CMedia_CDevices_CManualFocusDistance_Infinity
    }
    public static var hyperfocal : UWP.ManualFocusDistance {
        __x_ABI_CWindows_CMedia_CDevices_CManualFocusDistance_Hyperfocal
    }
    public static var nearest : UWP.ManualFocusDistance {
        __x_ABI_CWindows_CMedia_CDevices_CManualFocusDistance_Nearest
    }
}
extension UWP.ManualFocusDistance: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaCaptureFocusState {
    public static var uninitialized : UWP.MediaCaptureFocusState {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureFocusState_Uninitialized
    }
    public static var lost : UWP.MediaCaptureFocusState {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureFocusState_Lost
    }
    public static var searching : UWP.MediaCaptureFocusState {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureFocusState_Searching
    }
    public static var focused : UWP.MediaCaptureFocusState {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureFocusState_Focused
    }
    public static var failed : UWP.MediaCaptureFocusState {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureFocusState_Failed
    }
}
extension UWP.MediaCaptureFocusState: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaCaptureOptimization {
    public static var `default` : UWP.MediaCaptureOptimization {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureOptimization_Default
    }
    public static var quality : UWP.MediaCaptureOptimization {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureOptimization_Quality
    }
    public static var latency : UWP.MediaCaptureOptimization {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureOptimization_Latency
    }
    public static var power : UWP.MediaCaptureOptimization {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureOptimization_Power
    }
    public static var latencyThenQuality : UWP.MediaCaptureOptimization {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureOptimization_LatencyThenQuality
    }
    public static var latencyThenPower : UWP.MediaCaptureOptimization {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureOptimization_LatencyThenPower
    }
    public static var powerAndQuality : UWP.MediaCaptureOptimization {
        __x_ABI_CWindows_CMedia_CDevices_CMediaCaptureOptimization_PowerAndQuality
    }
}
extension UWP.MediaCaptureOptimization: @retroactive Hashable, @retroactive Codable {}

extension UWP.OpticalImageStabilizationMode {
    public static var off : UWP.OpticalImageStabilizationMode {
        __x_ABI_CWindows_CMedia_CDevices_COpticalImageStabilizationMode_Off
    }
    public static var on : UWP.OpticalImageStabilizationMode {
        __x_ABI_CWindows_CMedia_CDevices_COpticalImageStabilizationMode_On
    }
    public static var auto : UWP.OpticalImageStabilizationMode {
        __x_ABI_CWindows_CMedia_CDevices_COpticalImageStabilizationMode_Auto
    }
}
extension UWP.OpticalImageStabilizationMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.RegionOfInterestType {
    public static var unknown : UWP.RegionOfInterestType {
        __x_ABI_CWindows_CMedia_CDevices_CRegionOfInterestType_Unknown
    }
    public static var face : UWP.RegionOfInterestType {
        __x_ABI_CWindows_CMedia_CDevices_CRegionOfInterestType_Face
    }
}
extension UWP.RegionOfInterestType: @retroactive Hashable, @retroactive Codable {}

extension UWP.VideoDeviceControllerGetDevicePropertyStatus {
    public static var success : UWP.VideoDeviceControllerGetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerGetDevicePropertyStatus_Success
    }
    public static var unknownFailure : UWP.VideoDeviceControllerGetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerGetDevicePropertyStatus_UnknownFailure
    }
    public static var bufferTooSmall : UWP.VideoDeviceControllerGetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerGetDevicePropertyStatus_BufferTooSmall
    }
    public static var notSupported : UWP.VideoDeviceControllerGetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerGetDevicePropertyStatus_NotSupported
    }
    public static var deviceNotAvailable : UWP.VideoDeviceControllerGetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerGetDevicePropertyStatus_DeviceNotAvailable
    }
    public static var maxPropertyValueSizeTooSmall : UWP.VideoDeviceControllerGetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerGetDevicePropertyStatus_MaxPropertyValueSizeTooSmall
    }
    public static var maxPropertyValueSizeRequired : UWP.VideoDeviceControllerGetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerGetDevicePropertyStatus_MaxPropertyValueSizeRequired
    }
}
extension UWP.VideoDeviceControllerGetDevicePropertyStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.VideoDeviceControllerSetDevicePropertyStatus {
    public static var success : UWP.VideoDeviceControllerSetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerSetDevicePropertyStatus_Success
    }
    public static var unknownFailure : UWP.VideoDeviceControllerSetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerSetDevicePropertyStatus_UnknownFailure
    }
    public static var notSupported : UWP.VideoDeviceControllerSetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerSetDevicePropertyStatus_NotSupported
    }
    public static var invalidValue : UWP.VideoDeviceControllerSetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerSetDevicePropertyStatus_InvalidValue
    }
    public static var deviceNotAvailable : UWP.VideoDeviceControllerSetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerSetDevicePropertyStatus_DeviceNotAvailable
    }
    public static var notInControl : UWP.VideoDeviceControllerSetDevicePropertyStatus {
        __x_ABI_CWindows_CMedia_CDevices_CVideoDeviceControllerSetDevicePropertyStatus_NotInControl
    }
}
extension UWP.VideoDeviceControllerSetDevicePropertyStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.VideoTemporalDenoisingMode {
    public static var off : UWP.VideoTemporalDenoisingMode {
        __x_ABI_CWindows_CMedia_CDevices_CVideoTemporalDenoisingMode_Off
    }
    public static var on : UWP.VideoTemporalDenoisingMode {
        __x_ABI_CWindows_CMedia_CDevices_CVideoTemporalDenoisingMode_On
    }
    public static var auto : UWP.VideoTemporalDenoisingMode {
        __x_ABI_CWindows_CMedia_CDevices_CVideoTemporalDenoisingMode_Auto
    }
}
extension UWP.VideoTemporalDenoisingMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.ZoomTransitionMode {
    public static var auto : UWP.ZoomTransitionMode {
        __x_ABI_CWindows_CMedia_CDevices_CZoomTransitionMode_Auto
    }
    public static var direct : UWP.ZoomTransitionMode {
        __x_ABI_CWindows_CMedia_CDevices_CZoomTransitionMode_Direct
    }
    public static var smooth : UWP.ZoomTransitionMode {
        __x_ABI_CWindows_CMedia_CDevices_CZoomTransitionMode_Smooth
    }
}
extension UWP.ZoomTransitionMode: @retroactive Hashable, @retroactive Codable {}

