// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

private var IID___x_ABI_CWindows_CStorage_CStreams_CIBuffer: WindowsFoundation.IID {
    .init(Data1: 0x905A0FE0, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ))// 905A0FE0-BC53-11DF-8C49-001E4FC686DA
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIBufferFactory: WindowsFoundation.IID {
    .init(Data1: 0x71AF914D, Data2: 0xC10F, Data3: 0x484B, Data4: ( 0xBC,0x50,0x14,0xBC,0x62,0x3B,0x3A,0x27 ))// 71AF914D-C10F-484B-BC50-14BC623B3A27
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIBufferStatics: WindowsFoundation.IID {
    .init(Data1: 0xE901E65B, Data2: 0xD716, Data3: 0x475A, Data4: ( 0xA9,0x0A,0xAF,0x72,0x29,0xB1,0xE7,0x41 ))// E901E65B-D716-475A-A90A-AF7229B1E741
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider: WindowsFoundation.IID {
    .init(Data1: 0x97D098A5, Data2: 0x3B99, Data3: 0x4DE9, Data4: ( 0x88,0xA5,0xE1,0x1D,0x2F,0x50,0xC7,0x95 ))// 97D098A5-3B99-4DE9-88A5-E11D2F50C795
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIDataReader: WindowsFoundation.IID {
    .init(Data1: 0xE2B50029, Data2: 0xB4C1, Data3: 0x4314, Data4: ( 0xA4,0xB8,0xFB,0x81,0x3A,0x2F,0x27,0x5E ))// E2B50029-B4C1-4314-A4B8-FB813A2F275E
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIDataReaderFactory: WindowsFoundation.IID {
    .init(Data1: 0xD7527847, Data2: 0x57DA, Data3: 0x4E15, Data4: ( 0x91,0x4C,0x06,0x80,0x66,0x99,0xA0,0x98 ))// D7527847-57DA-4E15-914C-06806699A098
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIDataReaderStatics: WindowsFoundation.IID {
    .init(Data1: 0x11FCBFC8, Data2: 0xF93A, Data3: 0x471B, Data4: ( 0xB1,0x21,0xF3,0x79,0xE3,0x49,0x31,0x3C ))// 11FCBFC8-F93A-471B-B121-F379E349313C
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIDataWriter: WindowsFoundation.IID {
    .init(Data1: 0x64B89265, Data2: 0xD341, Data3: 0x4922, Data4: ( 0xB3,0x8A,0xDD,0x4A,0xF8,0x80,0x8C,0x4E ))// 64B89265-D341-4922-B38A-DD4AF8808C4E
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIDataWriterFactory: WindowsFoundation.IID {
    .init(Data1: 0x338C67C2, Data2: 0x8B84, Data3: 0x4C2B, Data4: ( 0x9C,0x50,0x7B,0x87,0x67,0x84,0x7A,0x1F ))// 338C67C2-8B84-4C2B-9C50-7B8767847A1F
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics: WindowsFoundation.IID {
    .init(Data1: 0x73550107, Data2: 0x3B57, Data3: 0x4B5D, Data4: ( 0x83,0x45,0x55,0x4D,0x2F,0xC6,0x21,0xF0 ))// 73550107-3B57-4B5D-8345-554D2FC621F0
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIInputStream: WindowsFoundation.IID {
    .init(Data1: 0x905A0FE2, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ))// 905A0FE2-BC53-11DF-8C49-001E4FC686DA
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference: WindowsFoundation.IID {
    .init(Data1: 0x43929D18, Data2: 0x5EC9, Data3: 0x4B5A, Data4: ( 0x91,0x9C,0x42,0x05,0xB0,0xC8,0x04,0xB6 ))// 43929D18-5EC9-4B5A-919C-4205B0C804B6
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIOutputStream: WindowsFoundation.IID {
    .init(Data1: 0x905A0FE6, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ))// 905A0FE6-BC53-11DF-8C49-001E4FC686DA
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream: WindowsFoundation.IID {
    .init(Data1: 0x905A0FE1, Data2: 0xBC53, Data3: 0x11DF, Data4: ( 0x8C,0x49,0x00,0x1E,0x4F,0xC6,0x86,0xDA ))// 905A0FE1-BC53-11DF-8C49-001E4FC686DA
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference: WindowsFoundation.IID {
    .init(Data1: 0x33EE3134, Data2: 0x1DD6, Data3: 0x4E3A, Data4: ( 0x80,0x67,0xD1,0xC1,0x62,0xE8,0x64,0x2B ))// 33EE3134-1DD6-4E3A-8067-D1C162E8642B
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReferenceStatics: WindowsFoundation.IID {
    .init(Data1: 0x857309DC, Data2: 0x3FBF, Data3: 0x4E7D, Data4: ( 0x98,0x6F,0xEF,0x3B,0x1A,0x07,0xA9,0x64 ))// 857309DC-3FBF-4E7D-986F-EF3B1A07A964
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamStatics: WindowsFoundation.IID {
    .init(Data1: 0x524CEDCF, Data2: 0x6E29, Data3: 0x4CE5, Data4: ( 0x95,0x73,0x6B,0x75,0x3D,0xB6,0x6C,0x3A ))// 524CEDCF-6E29-4CE5-9573-6B753DB66C3A
}

private var IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType: WindowsFoundation.IID {
    .init(Data1: 0xCC254827, Data2: 0x4B3D, Data3: 0x438F, Data4: ( 0x92,0x32,0x10,0xC7,0x6B,0xC7,0xE0,0x38 ))// CC254827-4B3D-438F-9232-10C76BC7E038
}

public enum __ABI_Windows_Storage_Streams {
    public class IBuffer: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIBuffer }

        open func get_CapacityImpl() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Capacity(pThis, &value))
            }
            return value
        }

        open func get_LengthImpl() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Length(pThis, &value))
            }
            return value
        }

        open func put_LengthImpl(_ value: UInt32) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBuffer.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_Length(pThis, value))
            }
        }

    }

    internal static var IBufferVTable: __x_ABI_CWindows_CStorage_CStreams_CIBufferVtbl = .init(
        QueryInterface: { IBufferWrapper.queryInterface($0, $1, $2) },
        AddRef: { IBufferWrapper.addRef($0) },
        Release: { IBufferWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IBufferWrapper.IID
            iids[3] = __ABI_.IBufferByteAccessWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IBuffer").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Capacity: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.capacity
            $1?.initialize(to: value)
            return S_OK
        },

        get_Length: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.length
            $1?.initialize(to: value)
            return S_OK
        },

        put_Length: {
            guard let __unwrapped__instance = IBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UInt32 = $1
            __unwrapped__instance.length = value
            return S_OK
        }
    )

    public typealias IBufferWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IBufferBridge>
    public class IBufferFactory: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIBufferFactory }

        internal func CreateImpl(_ capacity: UInt32) throws -> IBuffer {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBufferFactory.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.Create(pThis, capacity, &valueAbi))
                }
            }
            return IBuffer(value!)
        }

    }

    public class IBufferStatics: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIBufferStatics }

        internal func CreateCopyFromMemoryBufferImpl(_ input: WindowsFoundation.AnyIMemoryBuffer?) throws -> UWP.Buffer? {
            let (value) = try ComPtrs.initialize { valueAbi in
                let inputWrapper = __ABI_Windows_Foundation.IMemoryBufferWrapper(input)
                let _input = try! inputWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBufferStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateCopyFromMemoryBuffer(pThis, _input, &valueAbi))
                }
            }
            return .from(abi: value)
        }

        internal func CreateMemoryBufferOverIBufferImpl(_ input: UWP.AnyIBuffer?) throws -> WindowsFoundation.MemoryBuffer? {
            let (value) = try ComPtrs.initialize { valueAbi in
                let inputWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(input)
                let _input = try! inputWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIBufferStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateMemoryBufferOverIBuffer(pThis, _input, &valueAbi))
                }
            }
            return .from(abi: value)
        }

    }

    public class IContentTypeProvider: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider }

        open func get_ContentTypeImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIContentTypeProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ContentType(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IContentTypeProviderVTable: __x_ABI_CWindows_CStorage_CStreams_CIContentTypeProviderVtbl = .init(
        QueryInterface: { IContentTypeProviderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IContentTypeProviderWrapper.addRef($0) },
        Release: { IContentTypeProviderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IContentTypeProvider").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_ContentType: {
            guard let __unwrapped__instance = IContentTypeProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.contentType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        }
    )

    public typealias IContentTypeProviderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IContentTypeProviderBridge>
    public class IDataReader: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIDataReader }

        open func get_UnconsumedBufferLengthImpl() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_UnconsumedBufferLength(pThis, &value))
            }
            return value
        }

        open func get_UnicodeEncodingImpl() throws -> UWP.UnicodeEncoding {
            var value: __x_ABI_CWindows_CStorage_CStreams_CUnicodeEncoding = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_UnicodeEncoding(pThis, &value))
            }
            return value
        }

        open func put_UnicodeEncodingImpl(_ value: UWP.UnicodeEncoding) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_UnicodeEncoding(pThis, value))
            }
        }

        open func get_ByteOrderImpl() throws -> UWP.ByteOrder {
            var value: __x_ABI_CWindows_CStorage_CStreams_CByteOrder = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ByteOrder(pThis, &value))
            }
            return value
        }

        open func put_ByteOrderImpl(_ value: UWP.ByteOrder) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_ByteOrder(pThis, value))
            }
        }

        open func get_InputStreamOptionsImpl() throws -> UWP.InputStreamOptions {
            var value: __x_ABI_CWindows_CStorage_CStreams_CInputStreamOptions = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_InputStreamOptions(pThis, &value))
            }
            return value
        }

        open func put_InputStreamOptionsImpl(_ value: UWP.InputStreamOptions) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_InputStreamOptions(pThis, value))
            }
        }

        open func ReadByteImpl() throws -> UInt8 {
            var value: UINT8 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadByte(pThis, &value))
            }
            return value
        }

        open func ReadBufferImpl(_ length: UInt32) throws -> UWP.AnyIBuffer? {
            let (buffer) = try ComPtrs.initialize { bufferAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadBuffer(pThis, length, &bufferAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: buffer)
        }

        open func ReadBooleanImpl() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadBoolean(pThis, &value))
            }
            return .init(from: value)
        }

        open func ReadGuidImpl() throws -> Foundation.UUID {
            var value: WindowsFoundation.GUID = .init()
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadGuid(pThis, &value))
            }
            return .init(from: value)
        }

        open func ReadInt16Impl() throws -> Int16 {
            var value: INT16 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadInt16(pThis, &value))
            }
            return value
        }

        open func ReadInt32Impl() throws -> Int32 {
            var value: INT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadInt32(pThis, &value))
            }
            return value
        }

        open func ReadInt64Impl() throws -> Int64 {
            var value: INT64 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadInt64(pThis, &value))
            }
            return value
        }

        open func ReadUInt16Impl() throws -> UInt16 {
            var value: UINT16 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadUInt16(pThis, &value))
            }
            return value
        }

        open func ReadUInt32Impl() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadUInt32(pThis, &value))
            }
            return value
        }

        open func ReadUInt64Impl() throws -> UInt64 {
            var value: UINT64 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadUInt64(pThis, &value))
            }
            return value
        }

        open func ReadSingleImpl() throws -> Float {
            var value: FLOAT = 0.0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadSingle(pThis, &value))
            }
            return value
        }

        open func ReadDoubleImpl() throws -> Double {
            var value: DOUBLE = 0.0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadDouble(pThis, &value))
            }
            return value
        }

        open func ReadStringImpl(_ codeUnitCount: UInt32) throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadString(pThis, codeUnitCount, &value))
            }
            return .init(from: value)
        }

        open func ReadDateTimeImpl() throws -> WindowsFoundation.DateTime {
            var value: __x_ABI_CWindows_CFoundation_CDateTime = .init()
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadDateTime(pThis, &value))
            }
            return .from(abi: value)
        }

        open func ReadTimeSpanImpl() throws -> WindowsFoundation.TimeSpan {
            var value: __x_ABI_CWindows_CFoundation_CTimeSpan = .init()
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.ReadTimeSpan(pThis, &value))
            }
            return .from(abi: value)
        }

        open func LoadAsyncImpl(_ count: UInt32) throws -> UWP.DataReaderLoadOperation? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsync(pThis, count, &operationAbi))
                }
            }
            return .from(abi: operation)
        }

        open func DetachBufferImpl() throws -> UWP.AnyIBuffer? {
            let (buffer) = try ComPtrs.initialize { bufferAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DetachBuffer(pThis, &bufferAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: buffer)
        }

        open func DetachStreamImpl() throws -> UWP.AnyIInputStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReader.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DetachStream(pThis, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IInputStreamWrapper.unwrapFrom(abi: stream)
        }

    }

    internal static var IDataReaderVTable: __x_ABI_CWindows_CStorage_CStreams_CIDataReaderVtbl = .init(
        QueryInterface: { IDataReaderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IDataReaderWrapper.addRef($0) },
        Release: { IDataReaderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IDataReaderWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IDataReader").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_UnconsumedBufferLength: {
            guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.unconsumedBufferLength
            $1?.initialize(to: value)
            return S_OK
        },

        get_UnicodeEncoding: {
            guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.unicodeEncoding
            $1?.initialize(to: value)
            return S_OK
        },

        put_UnicodeEncoding: {
            guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UWP.UnicodeEncoding = $1
            __unwrapped__instance.unicodeEncoding = value
            return S_OK
        },

        get_ByteOrder: {
            guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.byteOrder
            $1?.initialize(to: value)
            return S_OK
        },

        put_ByteOrder: {
            guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UWP.ByteOrder = $1
            __unwrapped__instance.byteOrder = value
            return S_OK
        },

        get_InputStreamOptions: {
            guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.inputStreamOptions
            $1?.initialize(to: value)
            return S_OK
        },

        put_InputStreamOptions: {
            guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UWP.InputStreamOptions = $1
            __unwrapped__instance.inputStreamOptions = value
            return S_OK
        },

        ReadByte: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readByte()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadBytes: { _, _, _ in return failWith(err: E_NOTIMPL) },

        ReadBuffer: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let length: UInt32 = $1
                let buffer = try __unwrapped__instance.readBuffer(length)
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                bufferWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadBoolean: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readBoolean()
                $1?.initialize(to: .init(from: value))
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadGuid: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readGuid()
                $1?.initialize(to: .init(from: value))
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadInt16: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readInt16()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadInt32: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readInt32()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadInt64: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readInt64()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadUInt16: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readUInt16()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadUInt32: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readUInt32()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadUInt64: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readUInt64()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadSingle: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readSingle()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadDouble: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readDouble()
                $1?.initialize(to: value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadString: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let codeUnitCount: UInt32 = $1
                let value = try __unwrapped__instance.readString(codeUnitCount)
                $2?.initialize(to: try! HString(value).detach())
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadDateTime: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readDateTime()
                $1?.initialize(to: .from(swift: value))
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        ReadTimeSpan: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value = try __unwrapped__instance.readTimeSpan()
                $1?.initialize(to: .from(swift: value))
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        LoadAsync: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let count: UInt32 = $1
                let operation = try __unwrapped__instance.loadAsync(count)
                operation?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        DetachBuffer: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer = try __unwrapped__instance.detachBuffer()
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                bufferWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        DetachStream: {
            do {
                guard let __unwrapped__instance = IDataReaderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let stream = try __unwrapped__instance.detachStream()
                let streamWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(stream)
                streamWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IDataReaderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IDataReaderBridge>
    public class IDataReaderFactory: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIDataReaderFactory }

        internal func CreateDataReaderImpl(_ inputStream: UWP.AnyIInputStream?) throws -> IDataReader {
            let (dataReader) = try ComPtrs.initialize { dataReaderAbi in
                let inputStreamWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(inputStream)
                let _inputStream = try! inputStreamWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReaderFactory.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateDataReader(pThis, _inputStream, &dataReaderAbi))
                }
            }
            return IDataReader(dataReader!)
        }

    }

    public class IDataReaderStatics: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIDataReaderStatics }

        internal func FromBufferImpl(_ buffer: UWP.AnyIBuffer?) throws -> UWP.DataReader? {
            let (dataReader) = try ComPtrs.initialize { dataReaderAbi in
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                let _buffer = try! bufferWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataReaderStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.FromBuffer(pThis, _buffer, &dataReaderAbi))
                }
            }
            return .from(abi: dataReader)
        }

    }

    public class IDataWriter: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIDataWriter }

        open func get_UnstoredBufferLengthImpl() throws -> UInt32 {
            var value: UINT32 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_UnstoredBufferLength(pThis, &value))
            }
            return value
        }

        open func get_UnicodeEncodingImpl() throws -> UWP.UnicodeEncoding {
            var value: __x_ABI_CWindows_CStorage_CStreams_CUnicodeEncoding = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_UnicodeEncoding(pThis, &value))
            }
            return value
        }

        open func put_UnicodeEncodingImpl(_ value: UWP.UnicodeEncoding) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_UnicodeEncoding(pThis, value))
            }
        }

        open func get_ByteOrderImpl() throws -> UWP.ByteOrder {
            var value: __x_ABI_CWindows_CStorage_CStreams_CByteOrder = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ByteOrder(pThis, &value))
            }
            return value
        }

        open func put_ByteOrderImpl(_ value: UWP.ByteOrder) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_ByteOrder(pThis, value))
            }
        }

        open func WriteByteImpl(_ value: UInt8) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteByte(pThis, value))
            }
        }

        open func WriteBufferImpl(_ buffer: UWP.AnyIBuffer?) throws {
            let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
            let _buffer = try! bufferWrapper?.toABI { $0 }
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteBuffer(pThis, _buffer))
            }
        }

        open func WriteBufferRangeImpl(_ buffer: UWP.AnyIBuffer?, _ start: UInt32, _ count: UInt32) throws {
            let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
            let _buffer = try! bufferWrapper?.toABI { $0 }
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteBufferRange(pThis, _buffer, start, count))
            }
        }

        open func WriteBooleanImpl(_ value: Bool) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteBoolean(pThis, .init(from: value)))
            }
        }

        open func WriteGuidImpl(_ value: Foundation.UUID) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteGuid(pThis, .init(from: value)))
            }
        }

        open func WriteInt16Impl(_ value: Int16) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteInt16(pThis, value))
            }
        }

        open func WriteInt32Impl(_ value: Int32) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteInt32(pThis, value))
            }
        }

        open func WriteInt64Impl(_ value: Int64) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteInt64(pThis, value))
            }
        }

        open func WriteUInt16Impl(_ value: UInt16) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteUInt16(pThis, value))
            }
        }

        open func WriteUInt32Impl(_ value: UInt32) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteUInt32(pThis, value))
            }
        }

        open func WriteUInt64Impl(_ value: UInt64) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteUInt64(pThis, value))
            }
        }

        open func WriteSingleImpl(_ value: Float) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteSingle(pThis, value))
            }
        }

        open func WriteDoubleImpl(_ value: Double) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteDouble(pThis, value))
            }
        }

        open func WriteDateTimeImpl(_ value: WindowsFoundation.DateTime) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteDateTime(pThis, .from(swift: value)))
            }
        }

        open func WriteTimeSpanImpl(_ value: WindowsFoundation.TimeSpan) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteTimeSpan(pThis, .from(swift: value)))
            }
        }

        open func WriteStringImpl(_ value: String) throws -> UInt32 {
            var codeUnitCount: UINT32 = 0
            let _value = try! HString(value)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.WriteString(pThis, _value.get(), &codeUnitCount))
            }
            return codeUnitCount
        }

        open func MeasureStringImpl(_ value: String) throws -> UInt32 {
            var codeUnitCount: UINT32 = 0
            let _value = try! HString(value)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.MeasureString(pThis, _value.get(), &codeUnitCount))
            }
            return codeUnitCount
        }

        open func StoreAsyncImpl() throws -> UWP.DataWriterStoreOperation? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.StoreAsync(pThis, &operationAbi))
                }
            }
            return .from(abi: operation)
        }

        open func FlushAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<Bool>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.FlushAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.unwrapFrom(abi: operation)
        }

        open func DetachBufferImpl() throws -> UWP.AnyIBuffer? {
            let (buffer) = try ComPtrs.initialize { bufferAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DetachBuffer(pThis, &bufferAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: buffer)
        }

        open func DetachStreamImpl() throws -> UWP.AnyIOutputStream? {
            let (outputStream) = try ComPtrs.initialize { outputStreamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriter.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DetachStream(pThis, &outputStreamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IOutputStreamWrapper.unwrapFrom(abi: outputStream)
        }

    }

    internal static var IDataWriterVTable: __x_ABI_CWindows_CStorage_CStreams_CIDataWriterVtbl = .init(
        QueryInterface: { IDataWriterWrapper.queryInterface($0, $1, $2) },
        AddRef: { IDataWriterWrapper.addRef($0) },
        Release: { IDataWriterWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IDataWriterWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IDataWriter").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_UnstoredBufferLength: {
            guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.unstoredBufferLength
            $1?.initialize(to: value)
            return S_OK
        },

        get_UnicodeEncoding: {
            guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.unicodeEncoding
            $1?.initialize(to: value)
            return S_OK
        },

        put_UnicodeEncoding: {
            guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UWP.UnicodeEncoding = $1
            __unwrapped__instance.unicodeEncoding = value
            return S_OK
        },

        get_ByteOrder: {
            guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.byteOrder
            $1?.initialize(to: value)
            return S_OK
        },

        put_ByteOrder: {
            guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UWP.ByteOrder = $1
            __unwrapped__instance.byteOrder = value
            return S_OK
        },

        WriteByte: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: UInt8 = $1
                try __unwrapped__instance.writeByte(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteBytes: { _, _, _ in return failWith(err: E_NOTIMPL) },

        WriteBuffer: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer: UWP.AnyIBuffer? = __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: ComPtr($1))
                try __unwrapped__instance.writeBuffer(buffer)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteBufferRange: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer: UWP.AnyIBuffer? = __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: ComPtr($1))
                let start: UInt32 = $2
                let count: UInt32 = $3
                try __unwrapped__instance.writeBuffer(buffer, start, count)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteBoolean: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: Bool = .init(from: $1)
                try __unwrapped__instance.writeBoolean(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteGuid: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: Foundation.UUID = .init(from: $1)
                try __unwrapped__instance.writeGuid(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteInt16: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: Int16 = $1
                try __unwrapped__instance.writeInt16(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteInt32: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: Int32 = $1
                try __unwrapped__instance.writeInt32(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteInt64: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: Int64 = $1
                try __unwrapped__instance.writeInt64(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteUInt16: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: UInt16 = $1
                try __unwrapped__instance.writeUInt16(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteUInt32: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: UInt32 = $1
                try __unwrapped__instance.writeUInt32(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteUInt64: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: UInt64 = $1
                try __unwrapped__instance.writeUInt64(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteSingle: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: Float = $1
                try __unwrapped__instance.writeSingle(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteDouble: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: Double = $1
                try __unwrapped__instance.writeDouble(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteDateTime: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: WindowsFoundation.DateTime = .from(abi: $1)
                try __unwrapped__instance.writeDateTime(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteTimeSpan: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: WindowsFoundation.TimeSpan = .from(abi: $1)
                try __unwrapped__instance.writeTimeSpan(value)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        WriteString: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: String = .init(from: $1)
                let codeUnitCount = try __unwrapped__instance.writeString(value)
                $2?.initialize(to: codeUnitCount)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        MeasureString: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let value: String = .init(from: $1)
                let codeUnitCount = try __unwrapped__instance.measureString(value)
                $2?.initialize(to: codeUnitCount)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        StoreAsync: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.storeAsync()
                operation?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        FlushAsync: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.flushAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1_booleanWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        DetachBuffer: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer = try __unwrapped__instance.detachBuffer()
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                bufferWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        DetachStream: {
            do {
                guard let __unwrapped__instance = IDataWriterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let outputStream = try __unwrapped__instance.detachStream()
                let outputStreamWrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(outputStream)
                outputStreamWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IDataWriterWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IDataWriterBridge>
    public class IDataWriterFactory: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIDataWriterFactory }

        internal func CreateDataWriterImpl(_ outputStream: UWP.AnyIOutputStream?) throws -> IDataWriter {
            let (dataWriter) = try ComPtrs.initialize { dataWriterAbi in
                let outputStreamWrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(outputStream)
                let _outputStream = try! outputStreamWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIDataWriterFactory.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateDataWriter(pThis, _outputStream, &dataWriterAbi))
                }
            }
            return IDataWriter(dataWriter!)
        }

    }

    public class IFileRandomAccessStreamStatics: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics }

        internal func OpenAsyncImpl(_ filePath: String, _ accessMode: UWP.FileAccessMode) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _filePath = try! HString(filePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenAsync(pThis, _filePath.get(), accessMode, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        internal func OpenWithOptionsAsyncImpl(_ filePath: String, _ accessMode: UWP.FileAccessMode, _ sharingOptions: UWP.StorageOpenOptions, _ openDisposition: UWP.FileOpenDisposition) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _filePath = try! HString(filePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenWithOptionsAsync(pThis, _filePath.get(), accessMode, sharingOptions, openDisposition, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        internal func OpenTransactedWriteAsyncImpl(_ filePath: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _filePath = try! HString(filePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteAsync(pThis, _filePath.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

        internal func OpenTransactedWriteWithOptionsAsyncImpl(_ filePath: String, _ openOptions: UWP.StorageOpenOptions, _ openDisposition: UWP.FileOpenDisposition) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _filePath = try! HString(filePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteWithOptionsAsync(pThis, _filePath.get(), openOptions, openDisposition, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

        internal func OpenForUserAsyncImpl(_ user: UWP.User?, _ filePath: String, _ accessMode: UWP.FileAccessMode) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _filePath = try! HString(filePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenForUserAsync(pThis, RawPointer(user), _filePath.get(), accessMode, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        internal func OpenForUserWithOptionsAsyncImpl(_ user: UWP.User?, _ filePath: String, _ accessMode: UWP.FileAccessMode, _ sharingOptions: UWP.StorageOpenOptions, _ openDisposition: UWP.FileOpenDisposition) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _filePath = try! HString(filePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenForUserWithOptionsAsync(pThis, RawPointer(user), _filePath.get(), accessMode, sharingOptions, openDisposition, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        internal func OpenTransactedWriteForUserAsyncImpl(_ user: UWP.User?, _ filePath: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _filePath = try! HString(filePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteForUserAsync(pThis, RawPointer(user), _filePath.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

        internal func OpenTransactedWriteForUserWithOptionsAsyncImpl(_ user: UWP.User?, _ filePath: String, _ openOptions: UWP.StorageOpenOptions, _ openDisposition: UWP.FileOpenDisposition) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _filePath = try! HString(filePath)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIFileRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteForUserWithOptionsAsync(pThis, RawPointer(user), _filePath.get(), openOptions, openDisposition, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IInputStream: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIInputStream }

        open func ReadAsyncImpl(_ buffer: UWP.AnyIBuffer?, _ count: UInt32, _ options: UWP.InputStreamOptions) throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt32>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                let _buffer = try! bufferWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIInputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadAsync(pThis, _buffer, count, options, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IInputStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamVtbl = .init(
        QueryInterface: { IInputStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IInputStreamWrapper.addRef($0) },
        Release: { IInputStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IInputStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        ReadAsync: {
            do {
                guard let __unwrapped__instance = IInputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer: UWP.AnyIBuffer? = __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: ComPtr($1))
                let count: UInt32 = $2
                let options: UWP.InputStreamOptions = $3
                let operation = try __unwrapped__instance.readAsync(buffer, count, options)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2___x_ABI_CWindows__CStorage__CStreams__CIBuffer_UINT32Wrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IInputStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IInputStreamBridge>
    public class IInputStreamReference: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference }

        open func OpenSequentialReadAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIInputStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamReference.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenSequentialReadAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IInputStreamReferenceVTable: __x_ABI_CWindows_CStorage_CStreams_CIInputStreamReferenceVtbl = .init(
        QueryInterface: { IInputStreamReferenceWrapper.queryInterface($0, $1, $2) },
        AddRef: { IInputStreamReferenceWrapper.addRef($0) },
        Release: { IInputStreamReferenceWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IInputStreamReference").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenSequentialReadAsync: {
            do {
                guard let __unwrapped__instance = IInputStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openSequentialReadAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIInputStreamWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IInputStreamReferenceWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IInputStreamReferenceBridge>
    public class IOutputStream: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIOutputStream }

        open func WriteAsyncImpl(_ buffer: UWP.AnyIBuffer?) throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<UInt32, UInt32>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let bufferWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(buffer)
                let _buffer = try! bufferWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIOutputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.WriteAsync(pThis, _buffer, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper.unwrapFrom(abi: operation)
        }

        open func FlushAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<Bool>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIOutputStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.FlushAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IOutputStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIOutputStreamVtbl = .init(
        QueryInterface: { IOutputStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IOutputStreamWrapper.addRef($0) },
        Release: { IOutputStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IOutputStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        WriteAsync: {
            do {
                guard let __unwrapped__instance = IOutputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let buffer: UWP.AnyIBuffer? = __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.writeAsync(buffer)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT32_UINT32Wrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        FlushAsync: {
            do {
                guard let __unwrapped__instance = IOutputStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.flushAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1_booleanWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IOutputStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IOutputStreamBridge>
    public class IRandomAccessStream: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream }

        open func get_SizeImpl() throws -> UInt64 {
            var value: UINT64 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &value))
            }
            return value
        }

        open func put_SizeImpl(_ value: UInt64) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.put_Size(pThis, value))
            }
        }

        open func GetInputStreamAtImpl(_ position: UInt64) throws -> UWP.AnyIInputStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetInputStreamAt(pThis, position, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IInputStreamWrapper.unwrapFrom(abi: stream)
        }

        open func GetOutputStreamAtImpl(_ position: UInt64) throws -> UWP.AnyIOutputStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetOutputStreamAt(pThis, position, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IOutputStreamWrapper.unwrapFrom(abi: stream)
        }

        open func get_PositionImpl() throws -> UInt64 {
            var value: UINT64 = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Position(pThis, &value))
            }
            return value
        }

        open func SeekImpl(_ position: UInt64) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Seek(pThis, position))
            }
        }

        open func CloneStreamImpl() throws -> UWP.AnyIRandomAccessStream? {
            let (stream) = try ComPtrs.initialize { streamAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CloneStream(pThis, &streamAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.unwrapFrom(abi: stream)
        }

        open func get_CanReadImpl() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_CanRead(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_CanWriteImpl() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStream.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_CanWrite(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IRandomAccessStreamVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamVtbl = .init(
        QueryInterface: { IRandomAccessStreamWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamWrapper.addRef($0) },
        Release: { IRandomAccessStreamWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 6).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            $1!.pointee = 6
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStream").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Size: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.size
            $1?.initialize(to: value)
            return S_OK
        },

        put_Size: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value: UInt64 = $1
            __unwrapped__instance.size = value
            return S_OK
        },

        GetInputStreamAt: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                let stream = try __unwrapped__instance.getInputStreamAt(position)
                let streamWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(stream)
                streamWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetOutputStreamAt: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                let stream = try __unwrapped__instance.getOutputStreamAt(position)
                let streamWrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(stream)
                streamWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        get_Position: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.position
            $1?.initialize(to: value)
            return S_OK
        },

        Seek: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let position: UInt64 = $1
                try __unwrapped__instance.seek(position)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CloneStream: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let stream = try __unwrapped__instance.cloneStream()
                let streamWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper(stream)
                streamWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        get_CanRead: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.canRead
            $1?.initialize(to: .init(from: value))
            return S_OK
        },

        get_CanWrite: {
            guard let __unwrapped__instance = IRandomAccessStreamWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.canWrite
            $1?.initialize(to: .init(from: value))
            return S_OK
        }
    )

    public typealias IRandomAccessStreamWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamBridge>
    public class IRandomAccessStreamReference: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference }

        open func OpenReadAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStreamWithContentType?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReference.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenReadAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IRandomAccessStreamReferenceVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReferenceVtbl = .init(
        QueryInterface: { IRandomAccessStreamReferenceWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamReferenceWrapper.addRef($0) },
        Release: { IRandomAccessStreamReferenceWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStreamReference").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenReadAsync: {
            do {
                guard let __unwrapped__instance = IRandomAccessStreamReferenceWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openReadAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWithContentTypeWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IRandomAccessStreamReferenceWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamReferenceBridge>
    public class IRandomAccessStreamReferenceStatics: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReferenceStatics }

        internal func CreateFromFileImpl(_ file: UWP.AnyIStorageFile?) throws -> UWP.RandomAccessStreamReference? {
            let (streamReference) = try ComPtrs.initialize { streamReferenceAbi in
                let fileWrapper = __ABI_Windows_Storage.IStorageFileWrapper(file)
                let _file = try! fileWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReferenceStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromFile(pThis, _file, &streamReferenceAbi))
                }
            }
            return .from(abi: streamReference)
        }

        internal func CreateFromUriImpl(_ uri: WindowsFoundation.Uri?) throws -> UWP.RandomAccessStreamReference? {
            let (streamReference) = try ComPtrs.initialize { streamReferenceAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReferenceStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromUri(pThis, RawPointer(uri), &streamReferenceAbi))
                }
            }
            return .from(abi: streamReference)
        }

        internal func CreateFromStreamImpl(_ stream: UWP.AnyIRandomAccessStream?) throws -> UWP.RandomAccessStreamReference? {
            let (streamReference) = try ComPtrs.initialize { streamReferenceAbi in
                let streamWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper(stream)
                let _stream = try! streamWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamReferenceStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromStream(pThis, _stream, &streamReferenceAbi))
                }
            }
            return .from(abi: streamReference)
        }

    }

    public class IRandomAccessStreamStatics: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamStatics }

        internal func CopyAsyncImpl(_ source: UWP.AnyIInputStream?, _ destination: UWP.AnyIOutputStream?) throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<UInt64, UInt64>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let sourceWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(source)
                let _source = try! sourceWrapper?.toABI { $0 }
                let destinationWrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(destination)
                let _destination = try! destinationWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyAsync(pThis, _source, _destination, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.unwrapFrom(abi: operation)
        }

        internal func CopySizeAsyncImpl(_ source: UWP.AnyIInputStream?, _ destination: UWP.AnyIOutputStream?, _ bytesToCopy: UInt64) throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<UInt64, UInt64>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let sourceWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(source)
                let _source = try! sourceWrapper?.toABI { $0 }
                let destinationWrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(destination)
                let _destination = try! destinationWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopySizeAsync(pThis, _source, _destination, bytesToCopy, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.unwrapFrom(abi: operation)
        }

        internal func CopyAndCloseAsyncImpl(_ source: UWP.AnyIInputStream?, _ destination: UWP.AnyIOutputStream?) throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<UInt64, UInt64>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let sourceWrapper = __ABI_Windows_Storage_Streams.IInputStreamWrapper(source)
                let _source = try! sourceWrapper?.toABI { $0 }
                let destinationWrapper = __ABI_Windows_Storage_Streams.IOutputStreamWrapper(destination)
                let _destination = try! destinationWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyAndCloseAsync(pThis, _source, _destination, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperationWithProgress_2_UINT64_UINT64Wrapper.unwrapFrom(abi: operation)
        }

    }

    public class IRandomAccessStreamWithContentType: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType }

    }

    internal static var IRandomAccessStreamWithContentTypeVTable: __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentTypeVtbl = .init(
        QueryInterface: { IRandomAccessStreamWithContentTypeWrapper.queryInterface($0, $1, $2) },
        AddRef: { IRandomAccessStreamWithContentTypeWrapper.addRef($0) },
        Release: { IRandomAccessStreamWithContentTypeWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 8).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeWrapper.IID
            iids[3] = __ABI_Windows_Foundation.IClosableWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IInputStreamWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IOutputStreamWrapper.IID
            iids[6] = __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.IID
            iids[7] = __ABI_Windows_Storage_Streams.IContentTypeProviderWrapper.IID
            $1!.pointee = 8
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.Streams.IRandomAccessStreamWithContentType").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        }
    )

    public typealias IRandomAccessStreamWithContentTypeWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage_Streams.IRandomAccessStreamWithContentTypeBridge>
}
