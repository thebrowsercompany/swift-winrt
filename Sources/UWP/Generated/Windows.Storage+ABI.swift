// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

private var IID___x_ABI_CWindows_CStorage_CIStorageFile: WindowsFoundation.IID {
    .init(Data1: 0xFA3F6186, Data2: 0x4214, Data3: 0x428C, Data4: ( 0xA6,0x4C,0x14,0xC9,0xAC,0x73,0x15,0xEA ))// FA3F6186-4214-428C-A64C-14C9AC7315EA
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFile2: WindowsFoundation.IID {
    .init(Data1: 0x954E4BCF, Data2: 0x0A77, Data3: 0x42FB, Data4: ( 0xB7,0x77,0xC2,0xED,0x58,0xA5,0x2E,0x44 ))// 954E4BCF-0A77-42FB-B777-C2ED58A52E44
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability: WindowsFoundation.IID {
    .init(Data1: 0xAFCBBE9B, Data2: 0x582B, Data3: 0x4133, Data4: ( 0x96,0x48,0xE4,0x4C,0xA4,0x6E,0xE4,0x91 ))// AFCBBE9B-582B-4133-9648-E44CA46EE491
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFileStatics: WindowsFoundation.IID {
    .init(Data1: 0x5984C710, Data2: 0xDAF2, Data3: 0x43C8, Data4: ( 0x8B,0xB4,0xA4,0xD3,0xEA,0xCF,0xD0,0x3F ))// 5984C710-DAF2-43C8-8BB4-A4D3EACFD03F
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFolder: WindowsFoundation.IID {
    .init(Data1: 0x72D1CB78, Data2: 0xB3EF, Data3: 0x4F75, Data4: ( 0xA8,0x0B,0x6F,0xD9,0xDA,0xE2,0x94,0x4B ))// 72D1CB78-B3EF-4F75-A80B-6FD9DAE2944B
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFolder2: WindowsFoundation.IID {
    .init(Data1: 0xE827E8B9, Data2: 0x08D9, Data3: 0x4A8E, Data4: ( 0xA0,0xAC,0xFE,0x5E,0xD3,0xCB,0xBB,0xD3 ))// E827E8B9-08D9-4A8E-A0AC-FE5ED3CBBBD3
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFolder3: WindowsFoundation.IID {
    .init(Data1: 0x9F617899, Data2: 0xBDE1, Data3: 0x4124, Data4: ( 0xAE,0xB3,0xB0,0x6A,0xD9,0x6F,0x98,0xD4 ))// 9F617899-BDE1-4124-AEB3-B06AD96F98D4
}

private var IID___x_ABI_CWindows_CStorage_CIStorageFolderStatics: WindowsFoundation.IID {
    .init(Data1: 0x08F327FF, Data2: 0x85D5, Data3: 0x48B9, Data4: ( 0xAE,0xE9,0x28,0x51,0x1E,0x33,0x9F,0x9F ))// 08F327FF-85D5-48B9-AEE9-28511E339F9F
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItem: WindowsFoundation.IID {
    .init(Data1: 0x4207A996, Data2: 0xCA2F, Data3: 0x42F7, Data4: ( 0xBD,0xE8,0x8B,0x10,0x45,0x7A,0x7F,0x30 ))// 4207A996-CA2F-42F7-BDE8-8B10457A7F30
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItem2: WindowsFoundation.IID {
    .init(Data1: 0x53F926D2, Data2: 0x083C, Data3: 0x4283, Data4: ( 0xB4,0x5B,0x81,0xC0,0x07,0x23,0x7E,0x44 ))// 53F926D2-083C-4283-B45B-81C007237E44
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItemProperties: WindowsFoundation.IID {
    .init(Data1: 0x86664478, Data2: 0x8029, Data3: 0x46FE, Data4: ( 0xA7,0x89,0x1C,0x2F,0x3E,0x2F,0xFB,0x5C ))// 86664478-8029-46FE-A789-1C2F3E2FFB5C
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItemProperties2: WindowsFoundation.IID {
    .init(Data1: 0x8E86A951, Data2: 0x04B9, Data3: 0x4BD2, Data4: ( 0x92,0x9D,0xFE,0xF3,0xF7,0x16,0x21,0xD0 ))// 8E86A951-04B9-4BD2-929D-FEF3F71621D0
}

private var IID___x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider: WindowsFoundation.IID {
    .init(Data1: 0x861BF39B, Data2: 0x6368, Data3: 0x4DEE, Data4: ( 0xB4,0x0E,0x74,0x68,0x4A,0x5C,0xE7,0x14 ))// 861BF39B-6368-4DEE-B40E-74684A5CE714
}

private var IID___x_ABI_CWindows_CStorage_CIStorageLibraryChange: WindowsFoundation.IID {
    .init(Data1: 0x00980B23, Data2: 0x2BE2, Data3: 0x4909, Data4: ( 0xAA,0x48,0x15,0x9F,0x52,0x03,0xA5,0x1E ))// 00980B23-2BE2-4909-AA48-159F5203A51E
}

private var IID___x_ABI_CWindows_CStorage_CIStorageLibraryChangeReader: WindowsFoundation.IID {
    .init(Data1: 0xF205BC83, Data2: 0xFCA2, Data3: 0x41F9, Data4: ( 0x89,0x54,0xEE,0x2E,0x99,0x1E,0xB9,0x6F ))// F205BC83-FCA2-41F9-8954-EE2E991EB96F
}

private var IID___x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker: WindowsFoundation.IID {
    .init(Data1: 0x9E157316, Data2: 0x6073, Data3: 0x44F6, Data4: ( 0x96,0x81,0x74,0x92,0xD1,0x28,0x6C,0x90 ))// 9E157316-6073-44F6-9681-7492D1286C90
}

private var IID___x_ABI_CWindows_CStorage_CIStorageProvider: WindowsFoundation.IID {
    .init(Data1: 0xE705EED4, Data2: 0xD478, Data3: 0x47D6, Data4: ( 0xBA,0x46,0x1A,0x8E,0xBE,0x11,0x4A,0x20 ))// E705EED4-D478-47D6-BA46-1A8EBE114A20
}

private var IID___x_ABI_CWindows_CStorage_CIStorageProvider2: WindowsFoundation.IID {
    .init(Data1: 0x010D1917, Data2: 0x3404, Data3: 0x414B, Data4: ( 0x9F,0xD7,0xCD,0x44,0x47,0x2E,0xAA,0x39 ))// 010D1917-3404-414B-9FD7-CD44472EAA39
}

private var IID___x_ABI_CWindows_CStorage_CIStorageStreamTransaction: WindowsFoundation.IID {
    .init(Data1: 0xF67CF363, Data2: 0xA53D, Data3: 0x4D94, Data4: ( 0xAE,0x2C,0x67,0x23,0x2D,0x93,0xAC,0xDD ))// F67CF363-A53D-4D94-AE2C-67232D93ACDD
}

private var IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequest: WindowsFoundation.IID {
    .init(Data1: 0x1673FCCE, Data2: 0xDABD, Data3: 0x4D50, Data4: ( 0xBE,0xEE,0x18,0x0B,0x8A,0x81,0x91,0xB6 ))// 1673FCCE-DABD-4D50-BEEE-180B8A8191B6
}

private var IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandler: WindowsFoundation.IID {
    .init(Data1: 0xFEF6A824, Data2: 0x2FE1, Data3: 0x4D07, Data4: ( 0xA3,0x5B,0xB7,0x7C,0x50,0xB5,0xF4,0xCC ))// FEF6A824-2FE1-4D07-A35B-B77C50B5F4CC
}

public enum __ABI_Windows_Storage {
    public class IStorageFile: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageFile }

        open func get_FileTypeImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_FileType(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_ContentTypeImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ContentType(pThis, &value))
            }
            return .init(from: value)
        }

        open func OpenAsyncImpl(_ accessMode: UWP.FileAccessMode) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenAsync(pThis, accessMode, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        open func OpenTransactedWriteAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverloadDefaultNameAndOptionsImpl(_ destinationFolder: UWP.AnyIStorageFolder?) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverloadDefaultNameAndOptions(pThis, _destinationFolder, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverloadDefaultOptionsImpl(_ destinationFolder: UWP.AnyIStorageFolder?, _ desiredNewName: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverloadDefaultOptions(pThis, _destinationFolder, _desiredNewName.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyOverloadImpl(_ destinationFolder: UWP.AnyIStorageFolder?, _ desiredNewName: String, _ option: UWP.NameCollisionOption) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyOverload(pThis, _destinationFolder, _desiredNewName.get(), option, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CopyAndReplaceAsyncImpl(_ fileToReplace: UWP.AnyIStorageFile?) throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CopyAndReplaceAsync(pThis, _fileToReplace, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverloadDefaultNameAndOptionsImpl(_ destinationFolder: UWP.AnyIStorageFolder?) throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverloadDefaultNameAndOptions(pThis, _destinationFolder, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverloadDefaultOptionsImpl(_ destinationFolder: UWP.AnyIStorageFolder?, _ desiredNewName: String) throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverloadDefaultOptions(pThis, _destinationFolder, _desiredNewName.get(), &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveOverloadImpl(_ destinationFolder: UWP.AnyIStorageFolder?, _ desiredNewName: String, _ option: UWP.NameCollisionOption) throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let destinationFolderWrapper = __ABI_Windows_Storage.IStorageFolderWrapper(destinationFolder)
                let _destinationFolder = try! destinationFolderWrapper?.toABI { $0 }
                let _desiredNewName = try! HString(desiredNewName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveOverload(pThis, _destinationFolder, _desiredNewName.get(), option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func MoveAndReplaceAsyncImpl(_ fileToReplace: UWP.AnyIStorageFile?) throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.MoveAndReplaceAsync(pThis, _fileToReplace, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFileVTable: __x_ABI_CWindows_CStorage_CIStorageFileVtbl = .init(
        QueryInterface: { IStorageFileWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFileWrapper.addRef($0) },
        Release: { IStorageFileWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 6).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFileWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            iids[4] = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper.IID
            iids[5] = __ABI_Windows_Storage_Streams.IInputStreamReferenceWrapper.IID
            $1!.pointee = 6
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFile").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_FileType: {
            guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.fileType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_ContentType: {
            guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.contentType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        OpenAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let accessMode: UWP.FileAccessMode = $1
                let operation = try __unwrapped__instance.openAsync(accessMode)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        OpenTransactedWriteAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.openTransactedWriteAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CopyOverloadDefaultNameAndOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: UWP.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.copyAsync(destinationFolder)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CopyOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: UWP.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let operation = try __unwrapped__instance.copyAsync(destinationFolder, desiredNewName)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CopyOverload: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: UWP.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let option: UWP.NameCollisionOption = $3
                let operation = try __unwrapped__instance.copyAsync(destinationFolder, desiredNewName, option)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CopyAndReplaceAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let fileToReplace: UWP.AnyIStorageFile? = __ABI_Windows_Storage.IStorageFileWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.copyAndReplaceAsync(fileToReplace)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        MoveOverloadDefaultNameAndOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: UWP.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.moveAsync(destinationFolder)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        MoveOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: UWP.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let operation = try __unwrapped__instance.moveAsync(destinationFolder, desiredNewName)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        MoveOverload: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let destinationFolder: UWP.AnyIStorageFolder? = __ABI_Windows_Storage.IStorageFolderWrapper.unwrapFrom(abi: ComPtr($1))
                let desiredNewName: String = .init(from: $2)
                let option: UWP.NameCollisionOption = $3
                let operation = try __unwrapped__instance.moveAsync(destinationFolder, desiredNewName, option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        MoveAndReplaceAsync: {
            do {
                guard let __unwrapped__instance = IStorageFileWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let fileToReplace: UWP.AnyIStorageFile? = __ABI_Windows_Storage.IStorageFileWrapper.unwrapFrom(abi: ComPtr($1))
                let operation = try __unwrapped__instance.moveAndReplaceAsync(fileToReplace)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IStorageFileWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFileBridge>
    public class IStorageFile2: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageFile2 }

        open func OpenWithOptionsAsyncImpl(_ accessMode: UWP.FileAccessMode, _ options: UWP.StorageOpenOptions) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIRandomAccessStream?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenWithOptionsAsync(pThis, accessMode, options, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper.unwrapFrom(abi: operation)
        }

        open func OpenTransactedWriteWithOptionsAsyncImpl(_ options: UWP.StorageOpenOptions) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageStreamTransaction?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFile2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.OpenTransactedWriteWithOptionsAsync(pThis, options, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFile2VTable: __x_ABI_CWindows_CStorage_CIStorageFile2Vtbl = .init(
        QueryInterface: { IStorageFile2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFile2Wrapper.addRef($0) },
        Release: { IStorageFile2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFile2Wrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFile2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        OpenWithOptionsAsync: {
            do {
                guard let __unwrapped__instance = IStorageFile2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let accessMode: UWP.FileAccessMode = $1
                let options: UWP.StorageOpenOptions = $2
                let operation = try __unwrapped__instance.openAsync(accessMode, options)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIRandomAccessStreamWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        OpenTransactedWriteWithOptionsAsync: {
            do {
                guard let __unwrapped__instance = IStorageFile2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let options: UWP.StorageOpenOptions = $1
                let operation = try __unwrapped__instance.openTransactedWriteAsync(options)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageStreamTransactionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IStorageFile2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFile2Bridge>
    public class IStorageFilePropertiesWithAvailability: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability }

        open func get_IsAvailableImpl() throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailability.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_IsAvailable(pThis, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageFilePropertiesWithAvailabilityVTable: __x_ABI_CWindows_CStorage_CIStorageFilePropertiesWithAvailabilityVtbl = .init(
        QueryInterface: { IStorageFilePropertiesWithAvailabilityWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFilePropertiesWithAvailabilityWrapper.addRef($0) },
        Release: { IStorageFilePropertiesWithAvailabilityWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFilePropertiesWithAvailabilityWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFilePropertiesWithAvailability").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_IsAvailable: {
            guard let __unwrapped__instance = IStorageFilePropertiesWithAvailabilityWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.isAvailable
            $1?.initialize(to: .init(from: value))
            return S_OK
        }
    )

    public typealias IStorageFilePropertiesWithAvailabilityWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFilePropertiesWithAvailabilityBridge>
    public class IStorageFileStatics: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageFileStatics }

        internal func GetFileFromPathAsyncImpl(_ path: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _path = try! HString(path)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileFromPathAsync(pThis, _path.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        internal func GetFileFromApplicationUriAsyncImpl(_ uri: WindowsFoundation.Uri?) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileFromApplicationUriAsync(pThis, RawPointer(uri), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        internal func CreateStreamedFileAsyncImpl(_ displayNameWithExtension: String, _ dataRequested: UWP.StreamedFileDataRequestedHandler?, _ thumbnail: UWP.AnyIRandomAccessStreamReference?) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _displayNameWithExtension = try! HString(displayNameWithExtension)
                let dataRequestedWrapper = __ABI_Windows_Storage.StreamedFileDataRequestedHandlerWrapper(dataRequested)
                let _dataRequested = try! dataRequestedWrapper?.toABI { $0 }
                let thumbnailWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(thumbnail)
                let _thumbnail = try! thumbnailWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateStreamedFileAsync(pThis, _displayNameWithExtension.get(), _dataRequested, _thumbnail, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        internal func ReplaceWithStreamedFileAsyncImpl(_ fileToReplace: UWP.AnyIStorageFile?, _ dataRequested: UWP.StreamedFileDataRequestedHandler?, _ thumbnail: UWP.AnyIRandomAccessStreamReference?) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                let dataRequestedWrapper = __ABI_Windows_Storage.StreamedFileDataRequestedHandlerWrapper(dataRequested)
                let _dataRequested = try! dataRequestedWrapper?.toABI { $0 }
                let thumbnailWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(thumbnail)
                let _thumbnail = try! thumbnailWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReplaceWithStreamedFileAsync(pThis, _fileToReplace, _dataRequested, _thumbnail, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        internal func CreateStreamedFileFromUriAsyncImpl(_ displayNameWithExtension: String, _ uri: WindowsFoundation.Uri?, _ thumbnail: UWP.AnyIRandomAccessStreamReference?) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _displayNameWithExtension = try! HString(displayNameWithExtension)
                let thumbnailWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(thumbnail)
                let _thumbnail = try! thumbnailWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateStreamedFileFromUriAsync(pThis, _displayNameWithExtension.get(), RawPointer(uri), _thumbnail, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        internal func ReplaceWithStreamedFileFromUriAsyncImpl(_ fileToReplace: UWP.AnyIStorageFile?, _ uri: WindowsFoundation.Uri?, _ thumbnail: UWP.AnyIRandomAccessStreamReference?) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let fileToReplaceWrapper = __ABI_Windows_Storage.IStorageFileWrapper(fileToReplace)
                let _fileToReplace = try! fileToReplaceWrapper?.toABI { $0 }
                let thumbnailWrapper = __ABI_Windows_Storage_Streams.IRandomAccessStreamReferenceWrapper(thumbnail)
                let _thumbnail = try! thumbnailWrapper?.toABI { $0 }
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFileStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReplaceWithStreamedFileFromUriAsync(pThis, _fileToReplace, RawPointer(uri), _thumbnail, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageFolder: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolder }

        open func CreateFileAsyncOverloadDefaultOptionsImpl(_ desiredName: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFileAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFileAsyncImpl(_ desiredName: String, _ options: UWP.CreationCollisionOption) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFileAsync(pThis, _desiredName.get(), options, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFolderAsyncOverloadDefaultOptionsImpl(_ desiredName: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFolderAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func CreateFolderAsyncImpl(_ desiredName: String, _ options: UWP.CreationCollisionOption) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFolderAsync(pThis, _desiredName.get(), options, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetFileAsyncImpl(_ name: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func GetFolderAsyncImpl(_ name: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFolderAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetItemAsyncImpl(_ name: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIStorageItem?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetItemAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

        open func GetFilesAsyncOverloadDefaultOptionsStartAndCountImpl() throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFilesAsyncOverloadDefaultOptionsStartAndCount(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper.unwrapFrom(abi: operation)
        }

        open func GetFoldersAsyncOverloadDefaultOptionsStartAndCountImpl() throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFolder?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFoldersAsyncOverloadDefaultOptionsStartAndCount(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func GetItemsAsyncOverloadDefaultStartAndCountImpl() throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AnyIStorageItem?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetItemsAsyncOverloadDefaultStartAndCount(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFolderVTable: __x_ABI_CWindows_CStorage_CIStorageFolderVtbl = .init(
        QueryInterface: { IStorageFolderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFolderWrapper.addRef($0) },
        Release: { IStorageFolderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFolderWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFolder").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        CreateFileAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.createFileAsync(desiredName)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CreateFileAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let options: UWP.CreationCollisionOption = $2
                let operation = try __unwrapped__instance.createFileAsync(desiredName, options)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CreateFolderAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.createFolderAsync(desiredName)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        CreateFolderAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let options: UWP.CreationCollisionOption = $2
                let operation = try __unwrapped__instance.createFolderAsync(desiredName, options)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetFileAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getFileAsync(name)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetFolderAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getFolderAsync(name)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetItemAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.getItemAsync(name)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetFilesAsyncOverloadDefaultOptionsStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getFilesAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFileWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetFoldersAsyncOverloadDefaultOptionsStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getFoldersAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetItemsAsyncOverloadDefaultStartAndCount: {
            do {
                guard let __unwrapped__instance = IStorageFolderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getItemsAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IStorageFolderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFolderBridge>
    public class IStorageFolder2: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolder2 }

        open func TryGetItemAsyncImpl(_ name: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIStorageItem?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _name = try! HString(name)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.TryGetItemAsync(pThis, _name.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageFolder2VTable: __x_ABI_CWindows_CStorage_CIStorageFolder2Vtbl = .init(
        QueryInterface: { IStorageFolder2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageFolder2Wrapper.addRef($0) },
        Release: { IStorageFolder2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageFolder2Wrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageFolder2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        TryGetItemAsync: {
            do {
                guard let __unwrapped__instance = IStorageFolder2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let name: String = .init(from: $1)
                let operation = try __unwrapped__instance.tryGetItemAsync(name)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IStorageFolder2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageFolder2Bridge>
    public class IStorageFolder3: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolder3 }

        internal func TryGetChangeTrackerImpl() throws -> UWP.StorageLibraryChangeTracker? {
            let (result) = try ComPtrs.initialize { resultAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolder3.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.TryGetChangeTracker(pThis, &resultAbi))
                }
            }
            return .from(abi: result)
        }

    }

    public class IStorageFolderStatics: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageFolderStatics }

        internal func GetFolderFromPathAsyncImpl(_ path: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _path = try! HString(path)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageFolderStatics.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetFolderFromPathAsync(pThis, _path.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageItem: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageItem }

        open func RenameAsyncOverloadDefaultOptionsImpl(_ desiredName: String) throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.RenameAsyncOverloadDefaultOptions(pThis, _desiredName.get(), &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func RenameAsyncImpl(_ desiredName: String, _ option: UWP.NameCollisionOption) throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _desiredName = try! HString(desiredName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.RenameAsync(pThis, _desiredName.get(), option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func DeleteAsyncOverloadDefaultOptionsImpl() throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DeleteAsyncOverloadDefaultOptions(pThis, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func DeleteAsyncImpl(_ option: UWP.StorageDeleteOption) throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.DeleteAsync(pThis, option, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

        open func GetBasicPropertiesAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.BasicProperties?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetBasicPropertiesAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper.unwrapFrom(abi: operation)
        }

        open func get_NameImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Name(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_PathImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Path(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_AttributesImpl() throws -> UWP.FileAttributes {
            var value: __x_ABI_CWindows_CStorage_CFileAttributes = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Attributes(pThis, &value))
            }
            return value
        }

        open func get_DateCreatedImpl() throws -> WindowsFoundation.DateTime {
            var value: __x_ABI_CWindows_CFoundation_CDateTime = .init()
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DateCreated(pThis, &value))
            }
            return .from(abi: value)
        }

        open func IsOfTypeImpl(_ type: UWP.StorageItemTypes) throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.IsOfType(pThis, type, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageItemVTable: __x_ABI_CWindows_CStorage_CIStorageItemVtbl = .init(
        QueryInterface: { IStorageItemWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemWrapper.addRef($0) },
        Release: { IStorageItemWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItem").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        RenameAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let operation = try __unwrapped__instance.renameAsync(desiredName)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        RenameAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let desiredName: String = .init(from: $1)
                let option: UWP.NameCollisionOption = $2
                let operation = try __unwrapped__instance.renameAsync(desiredName, option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        DeleteAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.deleteAsync()
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        DeleteAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let option: UWP.StorageDeleteOption = $1
                let operation = try __unwrapped__instance.deleteAsync(option)
                let operationWrapper = __ABI_Windows_Foundation.IAsyncActionWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetBasicPropertiesAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getBasicPropertiesAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CBasicPropertiesWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        get_Name: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.name
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Path: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.path
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Attributes: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.attributes
            $1?.initialize(to: value)
            return S_OK
        },

        get_DateCreated: {
            guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.dateCreated
            $1?.initialize(to: .from(swift: value))
            return S_OK
        },

        IsOfType: {
            do {
                guard let __unwrapped__instance = IStorageItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let type: UWP.StorageItemTypes = $1
                let value = try __unwrapped__instance.isOfType(type)
                $2?.initialize(to: .init(from: value))
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IStorageItemWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemBridge>
    public class IStorageItem2: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageItem2 }

        open func GetParentAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetParentAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper.unwrapFrom(abi: operation)
        }

        open func IsEqualImpl(_ item: UWP.AnyIStorageItem?) throws -> Bool {
            var value: boolean = 0
            let itemWrapper = __ABI_Windows_Storage.IStorageItemWrapper(item)
            let _item = try! itemWrapper?.toABI { $0 }
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItem2.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.IsEqual(pThis, _item, &value))
            }
            return .init(from: value)
        }

    }

    internal static var IStorageItem2VTable: __x_ABI_CWindows_CStorage_CIStorageItem2Vtbl = .init(
        QueryInterface: { IStorageItem2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItem2Wrapper.addRef($0) },
        Release: { IStorageItem2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItem2Wrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItem2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetParentAsync: {
            do {
                guard let __unwrapped__instance = IStorageItem2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let operation = try __unwrapped__instance.getParentAsync()
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStorageFolderWrapper(operation)
                operationWrapper?.copyTo($1)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        IsEqual: {
            do {
                guard let __unwrapped__instance = IStorageItem2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let item: UWP.AnyIStorageItem? = __ABI_Windows_Storage.IStorageItemWrapper.unwrapFrom(abi: ComPtr($1))
                let value = try __unwrapped__instance.isEqual(item)
                $2?.initialize(to: .init(from: value))
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IStorageItem2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItem2Bridge>
    public class IStorageItemProperties: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemProperties }

        open func GetThumbnailAsyncOverloadDefaultSizeDefaultOptionsImpl(_ mode: UWP.ThumbnailMode) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(pThis, mode, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetThumbnailAsyncOverloadDefaultOptionsImpl(_ mode: UWP.ThumbnailMode, _ requestedSize: UInt32) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsyncOverloadDefaultOptions(pThis, mode, requestedSize, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetThumbnailAsyncImpl(_ mode: UWP.ThumbnailMode, _ requestedSize: UInt32, _ options: UWP.ThumbnailOptions) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetThumbnailAsync(pThis, mode, requestedSize, options, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func get_DisplayNameImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DisplayName(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_DisplayTypeImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DisplayType(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_FolderRelativeIdImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_FolderRelativeId(pThis, &value))
            }
            return .init(from: value)
        }

        open func get_PropertiesImpl() throws -> UWP.StorageItemContentProperties? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.get_Properties(pThis, &valueAbi))
                }
            }
            return .from(abi: value)
        }

    }

    internal static var IStorageItemPropertiesVTable: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesVtbl = .init(
        QueryInterface: { IStorageItemPropertiesWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemPropertiesWrapper.addRef($0) },
        Release: { IStorageItemPropertiesWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemProperties").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetThumbnailAsyncOverloadDefaultSizeDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: UWP.ThumbnailMode = $1
                let operation = try __unwrapped__instance.getThumbnailAsync(mode)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetThumbnailAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: UWP.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let operation = try __unwrapped__instance.getThumbnailAsync(mode, requestedSize)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetThumbnailAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: UWP.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let options: UWP.ThumbnailOptions = $3
                let operation = try __unwrapped__instance.getThumbnailAsync(mode, requestedSize, options)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        get_DisplayName: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.displayName
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_DisplayType: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.displayType
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_FolderRelativeId: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.folderRelativeId
            $1?.initialize(to: try! HString(value).detach())
            return S_OK
        },

        get_Properties: {
            guard let __unwrapped__instance = IStorageItemPropertiesWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.properties
            value?.copyTo($1)
            return S_OK
        }
    )

    public typealias IStorageItemPropertiesWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemPropertiesBridge>
    public class IStorageItemProperties2: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemProperties2 }

        open func GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptionsImpl(_ mode: UWP.ThumbnailMode) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(pThis, mode, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetScaledImageAsThumbnailAsyncOverloadDefaultOptionsImpl(_ mode: UWP.ThumbnailMode, _ requestedSize: UInt32) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(pThis, mode, requestedSize, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

        open func GetScaledImageAsThumbnailAsyncImpl(_ mode: UWP.ThumbnailMode, _ requestedSize: UInt32, _ options: UWP.ThumbnailOptions) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageItemThumbnail?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemProperties2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetScaledImageAsThumbnailAsync(pThis, mode, requestedSize, options, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper.unwrapFrom(abi: operation)
        }

    }

    internal static var IStorageItemProperties2VTable: __x_ABI_CWindows_CStorage_CIStorageItemProperties2Vtbl = .init(
        QueryInterface: { IStorageItemProperties2Wrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemProperties2Wrapper.addRef($0) },
        Release: { IStorageItemProperties2Wrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemProperties2Wrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemProperties2").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: UWP.ThumbnailMode = $1
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($2)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetScaledImageAsThumbnailAsyncOverloadDefaultOptions: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: UWP.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode, requestedSize)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($3)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        },

        GetScaledImageAsThumbnailAsync: {
            do {
                guard let __unwrapped__instance = IStorageItemProperties2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let mode: UWP.ThumbnailMode = $1
                let requestedSize: UInt32 = $2
                let options: UWP.ThumbnailOptions = $3
                let operation = try __unwrapped__instance.getScaledImageAsThumbnailAsync(mode, requestedSize, options)
                let operationWrapper = UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CFileProperties__CStorageItemThumbnailWrapper(operation)
                operationWrapper?.copyTo($4)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IStorageItemProperties2Wrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemProperties2Bridge>
    public class IStorageItemPropertiesWithProvider: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider }

        open func get_ProviderImpl() throws -> UWP.StorageProvider? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProvider.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.get_Provider(pThis, &valueAbi))
                }
            }
            return .from(abi: value)
        }

    }

    internal static var IStorageItemPropertiesWithProviderVTable: __x_ABI_CWindows_CStorage_CIStorageItemPropertiesWithProviderVtbl = .init(
        QueryInterface: { IStorageItemPropertiesWithProviderWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStorageItemPropertiesWithProviderWrapper.addRef($0) },
        Release: { IStorageItemPropertiesWithProviderWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStorageItemPropertiesWithProviderWrapper.IID
            iids[3] = __ABI_Windows_Storage.IStorageItemPropertiesWrapper.IID
            $1!.pointee = 4
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStorageItemPropertiesWithProvider").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        get_Provider: {
            guard let __unwrapped__instance = IStorageItemPropertiesWithProviderWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let value = __unwrapped__instance.provider
            value?.copyTo($1)
            return S_OK
        }
    )

    public typealias IStorageItemPropertiesWithProviderWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStorageItemPropertiesWithProviderBridge>
    public class IStorageLibraryChange: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageLibraryChange }

        internal func get_ChangeTypeImpl() throws -> UWP.StorageLibraryChangeType {
            var value: __x_ABI_CWindows_CStorage_CStorageLibraryChangeType = .init(0)
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_ChangeType(pThis, &value))
            }
            return value
        }

        internal func get_PathImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Path(pThis, &value))
            }
            return .init(from: value)
        }

        internal func get_PreviousPathImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_PreviousPath(pThis, &value))
            }
            return .init(from: value)
        }

        internal func IsOfTypeImpl(_ type: UWP.StorageItemTypes) throws -> Bool {
            var value: boolean = 0
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.IsOfType(pThis, type, &value))
            }
            return .init(from: value)
        }

        internal func GetStorageItemAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.AnyIStorageItem?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChange.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetStorageItemAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CIStorageItemWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageLibraryChangeReader: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageLibraryChangeReader }

        internal func ReadBatchAsyncImpl() throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageLibraryChange?>?>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeReader.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.ReadBatchAsync(pThis, &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageLibraryChangeWrapper.unwrapFrom(abi: operation)
        }

        internal func AcceptChangesAsyncImpl() throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeReader.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.AcceptChangesAsync(pThis, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageLibraryChangeTracker: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker }

        internal func GetChangeReaderImpl() throws -> UWP.StorageLibraryChangeReader? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.GetChangeReader(pThis, &valueAbi))
                }
            }
            return .from(abi: value)
        }

        internal func EnableImpl() throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Enable(pThis))
            }
        }

        internal func ResetImpl() throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageLibraryChangeTracker.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Reset(pThis))
            }
        }

    }

    public class IStorageProvider: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageProvider }

        internal func get_IdImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Id(pThis, &value))
            }
            return .init(from: value)
        }

        internal func get_DisplayNameImpl() throws -> String {
            var value: HSTRING?
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageProvider.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_DisplayName(pThis, &value))
            }
            return .init(from: value)
        }

    }

    public class IStorageProvider2: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageProvider2 }

        internal func IsPropertySupportedForPartialFileAsyncImpl(_ propertyCanonicalName: String) throws -> WindowsFoundation.AnyIAsyncOperation<Bool>? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                let _propertyCanonicalName = try! HString(propertyCanonicalName)
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageProvider2.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.IsPropertySupportedForPartialFileAsync(pThis, _propertyCanonicalName.get(), &operationAbi))
                }
            }
            return UWP.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStorageStreamTransaction: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStorageStreamTransaction }

        internal func get_StreamImpl() throws -> UWP.AnyIRandomAccessStream? {
            let (value) = try ComPtrs.initialize { valueAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageStreamTransaction.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.get_Stream(pThis, &valueAbi))
                }
            }
            return __ABI_Windows_Storage_Streams.IRandomAccessStreamWrapper.unwrapFrom(abi: value)
        }

        internal func CommitAsyncImpl() throws -> WindowsFoundation.AnyIAsyncAction? {
            let (operation) = try ComPtrs.initialize { operationAbi in
                _ = try perform(as: __x_ABI_CWindows_CStorage_CIStorageStreamTransaction.self) { pThis in
                    try CHECKED(pThis.pointee.lpVtbl.pointee.CommitAsync(pThis, &operationAbi))
                }
            }
            return __ABI_Windows_Foundation.IAsyncActionWrapper.unwrapFrom(abi: operation)
        }

    }

    public class IStreamedFileDataRequest: WindowsFoundation.IInspectable {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequest }

        open func FailAndCloseImpl(_ failureMode: UWP.StreamedFileFailureMode) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequest.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.FailAndClose(pThis, failureMode))
            }
        }

    }

    internal static var IStreamedFileDataRequestVTable: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestVtbl = .init(
        QueryInterface: { IStreamedFileDataRequestWrapper.queryInterface($0, $1, $2) },
        AddRef: { IStreamedFileDataRequestWrapper.addRef($0) },
        Release: { IStreamedFileDataRequestWrapper.release($0) },
        GetIids: {
            let size = MemoryLayout<WindowsFoundation.IID>.size
            let iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.self)
            iids[0] = IUnknown.IID
            iids[1] = IInspectable.IID
            iids[2] = __ABI_Windows_Storage.IStreamedFileDataRequestWrapper.IID
            $1!.pointee = 3
            $2!.pointee = iids
            return S_OK
        },

        GetRuntimeClassName: {
            _ = $0
            let hstring = try! HString("Windows.Storage.IStreamedFileDataRequest").detach()
            $1!.pointee = hstring
            return S_OK
        },

        GetTrustLevel: {
            _ = $0
            $1!.pointee = TrustLevel(rawValue: 0)
            return S_OK
        },

        FailAndClose: {
            do {
                guard let __unwrapped__instance = IStreamedFileDataRequestWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
                let failureMode: UWP.StreamedFileFailureMode = $1
                try __unwrapped__instance.failAndClose(failureMode)
                return S_OK
            } catch { return failWith(err: E_FAIL) } 
        }
    )

    public typealias IStreamedFileDataRequestWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.IStreamedFileDataRequestBridge>
}
// MARK - StreamedFileDataRequestedHandler
extension __ABI_Windows_Storage {
    public class StreamedFileDataRequestedHandler: WindowsFoundation.IUnknown {
        override public class var IID: WindowsFoundation.IID { IID___x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandler }

        open func InvokeImpl(_ stream: UWP.StreamedFileDataRequest?) throws {
            _ = try perform(as: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandler.self) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(stream)))
            }
        }

    }


    typealias StreamedFileDataRequestedHandlerWrapper = InterfaceWrapperBase<__IMPL_Windows_Storage.StreamedFileDataRequestedHandlerBridge>
    internal static var StreamedFileDataRequestedHandlerVTable: __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandlerVtbl = .init(
        QueryInterface: { StreamedFileDataRequestedHandlerWrapper.queryInterface($0, $1, $2) },
        AddRef: { StreamedFileDataRequestedHandlerWrapper.addRef($0) },
        Release: { StreamedFileDataRequestedHandlerWrapper.release($0) },
        Invoke: {
            guard let __unwrapped__instance = StreamedFileDataRequestedHandlerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            let stream: UWP.StreamedFileDataRequest? = .from(abi: ComPtr($1))
            __unwrapped__instance(stream)
            return S_OK
        }
    )
}
public extension WinRTDelegateBridge where CABI == __x_ABI_CWindows_CStorage_CIStreamedFileDataRequestedHandler {
    static func makeAbi() -> CABI {
        let vtblPtr = withUnsafeMutablePointer(to: &__ABI_Windows_Storage.StreamedFileDataRequestedHandlerVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

