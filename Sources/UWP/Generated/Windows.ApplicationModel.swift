// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagecontentgroupstate)
public typealias PackageContentGroupState = __x_ABI_CWindows_CApplicationModel_CPackageContentGroupState
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagesignaturekind)
public typealias PackageSignatureKind = __x_ABI_CWindows_CApplicationModel_CPackageSignatureKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageupdateavailability)
public typealias PackageUpdateAvailability = __x_ABI_CWindows_CApplicationModel_CPackageUpdateAvailability
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appdisplayinfo)
public final class AppDisplayInfo : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_ApplicationModel.IAppDisplayInfo
    private typealias CABI = __x_ABI_CWindows_CApplicationModel_CIAppDisplayInfo
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CApplicationModel_CIAppDisplayInfo>?) -> AppDisplayInfo? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appdisplayinfo.getlogo)
    public func getLogo(_ size: WindowsFoundation.Size) throws -> UWP.RandomAccessStreamReference! {
        try _default.GetLogoImpl(size)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appdisplayinfo.description)
    public var description : String {
        get { try! _default.get_DescriptionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appdisplayinfo.displayname)
    public var displayName : String {
        get { try! _default.get_DisplayNameImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appinfo)
public final class AppInfo : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_ApplicationModel.IAppInfo
    private typealias CABI = __x_ABI_CWindows_CApplicationModel_CIAppInfo
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CApplicationModel_CIAppInfo>?) -> AppInfo? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appinfo.appusermodelid)
    public var appUserModelId : String {
        get { try! _default.get_AppUserModelIdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appinfo.displayinfo)
    public var displayInfo : AppDisplayInfo! {
        get { try! _default.get_DisplayInfoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appinfo.id)
    public var id : String {
        get { try! _default.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appinfo.packagefamilyname)
    public var packageFamilyName : String {
        get { try! _default.get_PackageFamilyNameImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appinstallerinfo)
public final class AppInstallerInfo : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_ApplicationModel.IAppInstallerInfo
    private typealias CABI = __x_ABI_CWindows_CApplicationModel_CIAppInstallerInfo
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CApplicationModel_CIAppInstallerInfo>?) -> AppInstallerInfo? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.appinstallerinfo.uri)
    public var uri : WindowsFoundation.Uri! {
        get { try! _default.get_UriImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package)
public final class Package : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_ApplicationModel.IPackage
    private typealias CABI = __x_ABI_CWindows_CApplicationModel_CIPackage
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CApplicationModel_CIPackage>?) -> Package? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static let _IPackageStatics: __ABI_Windows_ApplicationModel.IPackageStatics = try! RoGetActivationFactory(HString("Windows.ApplicationModel.Package"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.current)
    public static var current : Package! {
        get { try! _IPackageStatics.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.dependencies)
    public var dependencies : WindowsFoundation.AnyIVectorView<Package?>! {
        get { try! _default.get_DependenciesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.id)
    public var id : PackageId! {
        get { try! _default.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.installedlocation)
    public var installedLocation : UWP.StorageFolder! {
        get { try! _default.get_InstalledLocationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.isframework)
    public var isFramework : Bool {
        get { try! _default.get_IsFrameworkImpl() }
    }

    private lazy var _IPackage2: __ABI_Windows_ApplicationModel.IPackage2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.description)
    public var description : String {
        get { try! _IPackage2.get_DescriptionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.displayname)
    public var displayName : String {
        get { try! _IPackage2.get_DisplayNameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.isbundle)
    public var isBundle : Bool {
        get { try! _IPackage2.get_IsBundleImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.isdevelopmentmode)
    public var isDevelopmentMode : Bool {
        get { try! _IPackage2.get_IsDevelopmentModeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.isresourcepackage)
    public var isResourcePackage : Bool {
        get { try! _IPackage2.get_IsResourcePackageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.logo)
    public var logo : WindowsFoundation.Uri! {
        get { try! _IPackage2.get_LogoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.publisherdisplayname)
    public var publisherDisplayName : String {
        get { try! _IPackage2.get_PublisherDisplayNameImpl() }
    }

    private lazy var _IPackage3: __ABI_Windows_ApplicationModel.IPackage3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.getapplistentriesasync)
    public func getAppListEntriesAsync() throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.AppListEntry?>?>! {
        try _IPackage3.GetAppListEntriesAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.installeddate)
    public var installedDate : WindowsFoundation.DateTime {
        get { try! _IPackage3.get_InstalledDateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.status)
    public var status : PackageStatus! {
        get { try! _IPackage3.get_StatusImpl() }
    }

    private lazy var _IPackageWithMetadata: __ABI_Windows_ApplicationModel.IPackageWithMetadata! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.getthumbnailtoken)
    public func getThumbnailToken() throws -> String {
        try _IPackageWithMetadata.GetThumbnailTokenImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.launch)
    public func launch(_ parameters: String) throws {
        try _IPackageWithMetadata.LaunchImpl(parameters)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.installdate)
    public var installDate : WindowsFoundation.DateTime {
        get { try! _IPackageWithMetadata.get_InstallDateImpl() }
    }

    private lazy var _IPackage4: __ABI_Windows_ApplicationModel.IPackage4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.verifycontentintegrityasync)
    public func verifyContentIntegrityAsync() throws -> WindowsFoundation.AnyIAsyncOperation<Bool>! {
        try _IPackage4.VerifyContentIntegrityAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.isoptional)
    public var isOptional : Bool {
        get { try! _IPackage4.get_IsOptionalImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.signaturekind)
    public var signatureKind : PackageSignatureKind {
        get { try! _IPackage4.get_SignatureKindImpl() }
    }

    private lazy var _IPackage5: __ABI_Windows_ApplicationModel.IPackage5! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.getcontentgroupsasync)
    public func getContentGroupsAsync() throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVector<PackageContentGroup?>?>! {
        try _IPackage5.GetContentGroupsAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.getcontentgroupasync)
    public func getContentGroupAsync(_ name: String) throws -> WindowsFoundation.AnyIAsyncOperation<PackageContentGroup?>! {
        try _IPackage5.GetContentGroupAsyncImpl(name)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.stagecontentgroupsasync)
    public func stageContentGroupsAsync(_ names: WindowsFoundation.AnyIIterable<String>!) throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVector<PackageContentGroup?>?>! {
        try _IPackage5.StageContentGroupsAsyncImpl(names)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.stagecontentgroupsasync)
    public func stageContentGroupsAsync(_ names: WindowsFoundation.AnyIIterable<String>!, _ moveToHeadOfQueue: Bool) throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVector<PackageContentGroup?>?>! {
        try _IPackage5.StageContentGroupsWithPriorityAsyncImpl(names, moveToHeadOfQueue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.setinuseasync)
    public func setInUseAsync(_ inUse: Bool) throws -> WindowsFoundation.AnyIAsyncOperation<Bool>! {
        try _IPackage5.SetInUseAsyncImpl(inUse)
    }

    private lazy var _IPackage6: __ABI_Windows_ApplicationModel.IPackage6! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.getappinstallerinfo)
    public func getAppInstallerInfo() throws -> AppInstallerInfo! {
        try _IPackage6.GetAppInstallerInfoImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.checkupdateavailabilityasync)
    public func checkUpdateAvailabilityAsync() throws -> WindowsFoundation.AnyIAsyncOperation<PackageUpdateAvailabilityResult?>! {
        try _IPackage6.CheckUpdateAvailabilityAsyncImpl()
    }

    private lazy var _IPackage7: __ABI_Windows_ApplicationModel.IPackage7! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.effectivelocation)
    public var effectiveLocation : UWP.StorageFolder! {
        get { try! _IPackage7.get_EffectiveLocationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.package.mutablelocation)
    public var mutableLocation : UWP.StorageFolder! {
        get { try! _IPackage7.get_MutableLocationImpl() }
    }

    deinit {
        _default = nil
        _IPackage2 = nil
        _IPackage3 = nil
        _IPackageWithMetadata = nil
        _IPackage4 = nil
        _IPackage5 = nil
        _IPackage6 = nil
        _IPackage7 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagecontentgroup)
public final class PackageContentGroup : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_ApplicationModel.IPackageContentGroup
    private typealias CABI = __x_ABI_CWindows_CApplicationModel_CIPackageContentGroup
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CApplicationModel_CIPackageContentGroup>?) -> PackageContentGroup? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static let _IPackageContentGroupStatics: __ABI_Windows_ApplicationModel.IPackageContentGroupStatics = try! RoGetActivationFactory(HString("Windows.ApplicationModel.PackageContentGroup"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagecontentgroup.requiredgroupname)
    public static var requiredGroupName : String {
        get { try! _IPackageContentGroupStatics.get_RequiredGroupNameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagecontentgroup.isrequired)
    public var isRequired : Bool {
        get { try! _default.get_IsRequiredImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagecontentgroup.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagecontentgroup.package)
    public var package : Package! {
        get { try! _default.get_PackageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagecontentgroup.state)
    public var state : PackageContentGroupState {
        get { try! _default.get_StateImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid)
public final class PackageId : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_ApplicationModel.IPackageId
    private typealias CABI = __x_ABI_CWindows_CApplicationModel_CIPackageId
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CApplicationModel_CIPackageId>?) -> PackageId? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.architecture)
    public var architecture : UWP.ProcessorArchitecture {
        get { try! _default.get_ArchitectureImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.familyname)
    public var familyName : String {
        get { try! _default.get_FamilyNameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.fullname)
    public var fullName : String {
        get { try! _default.get_FullNameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.publisher)
    public var publisher : String {
        get { try! _default.get_PublisherImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.publisherid)
    public var publisherId : String {
        get { try! _default.get_PublisherIdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.resourceid)
    public var resourceId : String {
        get { try! _default.get_ResourceIdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.version)
    public var version : PackageVersion {
        get { try! _default.get_VersionImpl() }
    }

    private lazy var _IPackageIdWithMetadata: __ABI_Windows_ApplicationModel.IPackageIdWithMetadata! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.author)
    public var author : String {
        get { try! _IPackageIdWithMetadata.get_AuthorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageid.productid)
    public var productId : String {
        get { try! _IPackageIdWithMetadata.get_ProductIdImpl() }
    }

    deinit {
        _default = nil
        _IPackageIdWithMetadata = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus)
public final class PackageStatus : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_ApplicationModel.IPackageStatus
    private typealias CABI = __x_ABI_CWindows_CApplicationModel_CIPackageStatus
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CApplicationModel_CIPackageStatus>?) -> PackageStatus? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.verifyisok)
    public func verifyIsOK() throws -> Bool {
        try _default.VerifyIsOKImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.dataoffline)
    public var dataOffline : Bool {
        get { try! _default.get_DataOfflineImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.dependencyissue)
    public var dependencyIssue : Bool {
        get { try! _default.get_DependencyIssueImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.deploymentinprogress)
    public var deploymentInProgress : Bool {
        get { try! _default.get_DeploymentInProgressImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.disabled)
    public var disabled : Bool {
        get { try! _default.get_DisabledImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.licenseissue)
    public var licenseIssue : Bool {
        get { try! _default.get_LicenseIssueImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.modified)
    public var modified : Bool {
        get { try! _default.get_ModifiedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.needsremediation)
    public var needsRemediation : Bool {
        get { try! _default.get_NeedsRemediationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.notavailable)
    public var notAvailable : Bool {
        get { try! _default.get_NotAvailableImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.packageoffline)
    public var packageOffline : Bool {
        get { try! _default.get_PackageOfflineImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.servicing)
    public var servicing : Bool {
        get { try! _default.get_ServicingImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.tampered)
    public var tampered : Bool {
        get { try! _default.get_TamperedImpl() }
    }

    private lazy var _IPackageStatus2: __ABI_Windows_ApplicationModel.IPackageStatus2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packagestatus.ispartiallystaged)
    public var isPartiallyStaged : Bool {
        get { try! _IPackageStatus2.get_IsPartiallyStagedImpl() }
    }

    deinit {
        _default = nil
        _IPackageStatus2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageupdateavailabilityresult)
public final class PackageUpdateAvailabilityResult : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_ApplicationModel.IPackageUpdateAvailabilityResult
    private typealias CABI = __x_ABI_CWindows_CApplicationModel_CIPackageUpdateAvailabilityResult
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CApplicationModel_CIPackageUpdateAvailabilityResult>?) -> PackageUpdateAvailabilityResult? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageupdateavailabilityresult.availability)
    public var availability : PackageUpdateAvailability {
        get { try! _default.get_AvailabilityImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageupdateavailabilityresult.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageversion)
public struct PackageVersion: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageversion.major)
    public var major: UInt16 = 0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageversion.minor)
    public var minor: UInt16 = 0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageversion.build)
    public var build: UInt16 = 0
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.applicationmodel.packageversion.revision)
    public var revision: UInt16 = 0
    public init() {}
    public init(major: UInt16, minor: UInt16, build: UInt16, revision: UInt16) {
        self.major = major
        self.minor = minor
        self.build = build
        self.revision = revision
    }
    public static func from(abi: __x_ABI_CWindows_CApplicationModel_CPackageVersion) -> PackageVersion {
        .init(major: abi.Major, minor: abi.Minor, build: abi.Build, revision: abi.Revision)
    }
}

extension UWP.PackageContentGroupState {
    public static var notStaged : UWP.PackageContentGroupState {
        __x_ABI_CWindows_CApplicationModel_CPackageContentGroupState_NotStaged
    }
    public static var queued : UWP.PackageContentGroupState {
        __x_ABI_CWindows_CApplicationModel_CPackageContentGroupState_Queued
    }
    public static var staging : UWP.PackageContentGroupState {
        __x_ABI_CWindows_CApplicationModel_CPackageContentGroupState_Staging
    }
    public static var staged : UWP.PackageContentGroupState {
        __x_ABI_CWindows_CApplicationModel_CPackageContentGroupState_Staged
    }
}
extension UWP.PackageContentGroupState: @retroactive Hashable, @retroactive Codable {}

extension UWP.PackageSignatureKind {
    public static var none : UWP.PackageSignatureKind {
        __x_ABI_CWindows_CApplicationModel_CPackageSignatureKind_None
    }
    public static var developer : UWP.PackageSignatureKind {
        __x_ABI_CWindows_CApplicationModel_CPackageSignatureKind_Developer
    }
    public static var enterprise : UWP.PackageSignatureKind {
        __x_ABI_CWindows_CApplicationModel_CPackageSignatureKind_Enterprise
    }
    public static var store : UWP.PackageSignatureKind {
        __x_ABI_CWindows_CApplicationModel_CPackageSignatureKind_Store
    }
    public static var system : UWP.PackageSignatureKind {
        __x_ABI_CWindows_CApplicationModel_CPackageSignatureKind_System
    }
}
extension UWP.PackageSignatureKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.PackageUpdateAvailability {
    public static var unknown : UWP.PackageUpdateAvailability {
        __x_ABI_CWindows_CApplicationModel_CPackageUpdateAvailability_Unknown
    }
    public static var noUpdates : UWP.PackageUpdateAvailability {
        __x_ABI_CWindows_CApplicationModel_CPackageUpdateAvailability_NoUpdates
    }
    public static var available : UWP.PackageUpdateAvailability {
        __x_ABI_CWindows_CApplicationModel_CPackageUpdateAvailability_Available
    }
    public static var required : UWP.PackageUpdateAvailability {
        __x_ABI_CWindows_CApplicationModel_CPackageUpdateAvailability_Required
    }
    public static var error : UWP.PackageUpdateAvailability {
        __x_ABI_CWindows_CApplicationModel_CPackageUpdateAvailability_Error
    }
}
extension UWP.PackageUpdateAvailability: @retroactive Hashable, @retroactive Codable {}

