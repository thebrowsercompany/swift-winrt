// WARNING: Please don't edit this file. It was generated by Swift/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.autoloadeddisplaypropertykind)
public typealias AutoLoadedDisplayPropertyKind = __x_ABI_CWindows_CMedia_CPlayback_CAutoLoadedDisplayPropertyKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakinsertionmethod)
public typealias MediaBreakInsertionMethod = __x_ABI_CWindows_CMedia_CPlayback_CMediaBreakInsertionMethod
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediacommandenablingrule)
public typealias MediaCommandEnablingRule = __x_ABI_CWindows_CMedia_CPlayback_CMediaCommandEnablingRule
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemchangedreason)
public typealias MediaPlaybackItemChangedReason = __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemChangedReason
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemerrorcode)
public typealias MediaPlaybackItemErrorCode = __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemErrorCode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionvideoconstrictionreason)
public typealias MediaPlaybackSessionVideoConstrictionReason = __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackSessionVideoConstrictionReason
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackstate)
public typealias MediaPlaybackState = __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackState
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayeraudiocategory)
public typealias MediaPlayerAudioCategory = __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayeraudiodevicetype)
public typealias MediaPlayerAudioDeviceType = __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioDeviceType
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayererror)
public typealias MediaPlayerError = __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerError
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayerstate)
public typealias MediaPlayerState = __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerState
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.sphericalvideoprojectionmode)
public typealias SphericalVideoProjectionMode = __x_ABI_CWindows_CMedia_CPlayback_CSphericalVideoProjectionMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.stereoscopicvideorendermode)
public typealias StereoscopicVideoRenderMode = __x_ABI_CWindows_CMedia_CPlayback_CStereoscopicVideoRenderMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.timedmetadatatrackpresentationmode)
public typealias TimedMetadataTrackPresentationMode = __x_ABI_CWindows_CMedia_CPlayback_CTimedMetadataTrackPresentationMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.currentmediaplaybackitemchangedeventargs)
public final class CurrentMediaPlaybackItemChangedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.ICurrentMediaPlaybackItemChangedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CICurrentMediaPlaybackItemChangedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CICurrentMediaPlaybackItemChangedEventArgs>?) -> CurrentMediaPlaybackItemChangedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.currentmediaplaybackitemchangedeventargs.newitem)
    public var newItem : MediaPlaybackItem! {
        get { try! _default.get_NewItemImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.currentmediaplaybackitemchangedeventargs.olditem)
    public var oldItem : MediaPlaybackItem! {
        get { try! _default.get_OldItemImpl() }
    }

    private lazy var _ICurrentMediaPlaybackItemChangedEventArgs2: __ABI_Windows_Media_Playback.ICurrentMediaPlaybackItemChangedEventArgs2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.currentmediaplaybackitemchangedeventargs.reason)
    public var reason : MediaPlaybackItemChangedReason {
        get { try! _ICurrentMediaPlaybackItemChangedEventArgs2.get_ReasonImpl() }
    }

    deinit {
        _default = nil
        _ICurrentMediaPlaybackItemChangedEventArgs2 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreak)
public final class MediaBreak : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaBreak
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaBreak
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaBreak>?) -> MediaBreak? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static let _IMediaBreakFactory: __ABI_Windows_Media_Playback.IMediaBreakFactory = try! RoGetActivationFactory(HString("Windows.Media.Playback.MediaBreak"))
    public init(_ insertionMethod: MediaBreakInsertionMethod) {
        super.init(try! Self._IMediaBreakFactory.CreateImpl(insertionMethod))
    }

    public init(_ insertionMethod: MediaBreakInsertionMethod, _ presentationPosition: WindowsFoundation.TimeSpan) {
        super.init(try! Self._IMediaBreakFactory.CreateWithPresentationPositionImpl(insertionMethod, presentationPosition))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreak.canstart)
    public var canStart : Bool {
        get { try! _default.get_CanStartImpl() }
        set { try! _default.put_CanStartImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreak.customproperties)
    public var customProperties : WindowsFoundation.ValueSet! {
        get { try! _default.get_CustomPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreak.insertionmethod)
    public var insertionMethod : MediaBreakInsertionMethod {
        get { try! _default.get_InsertionMethodImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreak.playbacklist)
    public var playbackList : MediaPlaybackList! {
        get { try! _default.get_PlaybackListImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreak.presentationposition)
    public var presentationPosition : WindowsFoundation.TimeSpan? {
        get { try! _default.get_PresentationPositionImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakendedeventargs)
public final class MediaBreakEndedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaBreakEndedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakEndedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakEndedEventArgs>?) -> MediaBreakEndedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakendedeventargs.mediabreak)
    public var mediaBreak : MediaBreak! {
        get { try! _default.get_MediaBreakImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager)
public final class MediaBreakManager : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaBreakManager
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakManager
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakManager>?) -> MediaBreakManager? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager.playbreak)
    public func playBreak(_ value: MediaBreak!) throws {
        try _default.PlayBreakImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager.skipcurrentbreak)
    public func skipCurrentBreak() throws {
        try _default.SkipCurrentBreakImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager.currentbreak)
    public var currentBreak : MediaBreak! {
        get { try! _default.get_CurrentBreakImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager.playbacksession)
    public var playbackSession : MediaPlaybackSession! {
        get { try! _default.get_PlaybackSessionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager.breakended)
    public lazy var breakEnded : Event<TypedEventHandler<MediaBreakManager?, MediaBreakEndedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BreakEndedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BreakEndedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager.breakskipped)
    public lazy var breakSkipped : Event<TypedEventHandler<MediaBreakManager?, MediaBreakSkippedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BreakSkippedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BreakSkippedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager.breakstarted)
    public lazy var breakStarted : Event<TypedEventHandler<MediaBreakManager?, MediaBreakStartedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BreakStartedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BreakStartedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakmanager.breaksseekedover)
    public lazy var breaksSeekedOver : Event<TypedEventHandler<MediaBreakManager?, MediaBreakSeekedOverEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BreaksSeekedOverImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BreaksSeekedOverImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakschedule)
public final class MediaBreakSchedule : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaBreakSchedule
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakSchedule
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakSchedule>?) -> MediaBreakSchedule? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakschedule.insertmidrollbreak)
    public func insertMidrollBreak(_ mediaBreak: MediaBreak!) throws {
        try _default.InsertMidrollBreakImpl(mediaBreak)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakschedule.removemidrollbreak)
    public func removeMidrollBreak(_ mediaBreak: MediaBreak!) throws {
        try _default.RemoveMidrollBreakImpl(mediaBreak)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakschedule.midrollbreaks)
    public var midrollBreaks : WindowsFoundation.AnyIVectorView<MediaBreak?>! {
        get { try! _default.get_MidrollBreaksImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakschedule.playbackitem)
    public var playbackItem : MediaPlaybackItem! {
        get { try! _default.get_PlaybackItemImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakschedule.postrollbreak)
    public var postrollBreak : MediaBreak! {
        get { try! _default.get_PostrollBreakImpl() }
        set { try! _default.put_PostrollBreakImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakschedule.prerollbreak)
    public var prerollBreak : MediaBreak! {
        get { try! _default.get_PrerollBreakImpl() }
        set { try! _default.put_PrerollBreakImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakschedule.schedulechanged)
    public lazy var scheduleChanged : Event<TypedEventHandler<MediaBreakSchedule?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ScheduleChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ScheduleChangedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakseekedovereventargs)
public final class MediaBreakSeekedOverEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaBreakSeekedOverEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakSeekedOverEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakSeekedOverEventArgs>?) -> MediaBreakSeekedOverEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakseekedovereventargs.newposition)
    public var newPosition : WindowsFoundation.TimeSpan {
        get { try! _default.get_NewPositionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakseekedovereventargs.oldposition)
    public var oldPosition : WindowsFoundation.TimeSpan {
        get { try! _default.get_OldPositionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakseekedovereventargs.seekedoverbreaks)
    public var seekedOverBreaks : WindowsFoundation.AnyIVectorView<MediaBreak?>! {
        get { try! _default.get_SeekedOverBreaksImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakskippedeventargs)
public final class MediaBreakSkippedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaBreakSkippedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakSkippedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakSkippedEventArgs>?) -> MediaBreakSkippedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakskippedeventargs.mediabreak)
    public var mediaBreak : MediaBreak! {
        get { try! _default.get_MediaBreakImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakstartedeventargs)
public final class MediaBreakStartedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaBreakStartedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakStartedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaBreakStartedEventArgs>?) -> MediaBreakStartedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediabreakstartedeventargs.mediabreak)
    public var mediaBreak : MediaBreak! {
        get { try! _default.get_MediaBreakImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaitemdisplayproperties)
public final class MediaItemDisplayProperties : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaItemDisplayProperties
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaItemDisplayProperties
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaItemDisplayProperties>?) -> MediaItemDisplayProperties? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaitemdisplayproperties.clearall)
    public func clearAll() throws {
        try _default.ClearAllImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaitemdisplayproperties.musicproperties)
    public var musicProperties : UWP.MusicDisplayProperties! {
        get { try! _default.get_MusicPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaitemdisplayproperties.thumbnail)
    public var thumbnail : UWP.RandomAccessStreamReference! {
        get { try! _default.get_ThumbnailImpl() }
        set { try! _default.put_ThumbnailImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaitemdisplayproperties.type)
    public var type : UWP.MediaPlaybackType {
        get { try! _default.get_TypeImpl() }
        set { try! _default.put_TypeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaitemdisplayproperties.videoproperties)
    public var videoProperties : UWP.VideoDisplayProperties! {
        get { try! _default.get_VideoPropertiesImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackaudiotracklist)
public final class MediaPlaybackAudioTrackList : WinRTClass, IVectorView, IIterable, UWP.ISingleSelectMediaTrackList {
    public typealias T = UWP.AudioTrack?
    private typealias SwiftABI = UWP.IVectorViewAudioTrack
    private typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CAudioTrack>?) -> MediaPlaybackAudioTrackList? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    // MARK: Collection
    public typealias Element = T
    public var startIndex: Int { 0 }
    public var endIndex: Int { Int(size) }
    public func index(after i: Int) -> Int {
        i+1
    }

    public func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    public var count: Int { Int(size) }

    public subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackaudiotracklist.getat)
    public func getAt(_ index: UInt32) -> UWP.AudioTrack? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackaudiotracklist.indexof)
    public func indexOf(_ value: UWP.AudioTrack?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackaudiotracklist.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAudioTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackaudiotracklist.first)
    public func first() -> WindowsFoundation.AnyIIterator<UWP.AudioTrack?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _ISingleSelectMediaTrackList: __ABI_Windows_Media_Core.ISingleSelectMediaTrackList! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackaudiotracklist.selectedindex)
    public var selectedIndex : Int32 {
        get { try! _ISingleSelectMediaTrackList.get_SelectedIndexImpl() }
        set { try! _ISingleSelectMediaTrackList.put_SelectedIndexImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackaudiotracklist.selectedindexchanged)
    public lazy var selectedIndexChanged : Event<TypedEventHandler<ISingleSelectMediaTrackList?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._ISingleSelectMediaTrackList else { return .init() }
          return try! this.add_SelectedIndexChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._ISingleSelectMediaTrackList.remove_SelectedIndexChangedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
        _IIterable = nil
        _ISingleSelectMediaTrackList = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager)
public final class MediaPlaybackCommandManager : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManager
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManager
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManager>?) -> MediaPlaybackCommandManager? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.autorepeatmodebehavior)
    public var autoRepeatModeBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_AutoRepeatModeBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.fastforwardbehavior)
    public var fastForwardBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_FastForwardBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.isenabled)
    public var isEnabled : Bool {
        get { try! _default.get_IsEnabledImpl() }
        set { try! _default.put_IsEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.mediaplayer)
    public var mediaPlayer : MediaPlayer! {
        get { try! _default.get_MediaPlayerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.nextbehavior)
    public var nextBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_NextBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.pausebehavior)
    public var pauseBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_PauseBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.playbehavior)
    public var playBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_PlayBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.positionbehavior)
    public var positionBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_PositionBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.previousbehavior)
    public var previousBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_PreviousBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.ratebehavior)
    public var rateBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_RateBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.rewindbehavior)
    public var rewindBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_RewindBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.shufflebehavior)
    public var shuffleBehavior : MediaPlaybackCommandManagerCommandBehavior! {
        get { try! _default.get_ShuffleBehaviorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.autorepeatmodereceived)
    public lazy var autoRepeatModeReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_AutoRepeatModeReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_AutoRepeatModeReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.fastforwardreceived)
    public lazy var fastForwardReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerFastForwardReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_FastForwardReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_FastForwardReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.nextreceived)
    public lazy var nextReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerNextReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_NextReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_NextReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.pausereceived)
    public lazy var pauseReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerPauseReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PauseReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PauseReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.playreceived)
    public lazy var playReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerPlayReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PlayReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PlayReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.positionreceived)
    public lazy var positionReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerPositionReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PositionReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PositionReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.previousreceived)
    public lazy var previousReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerPreviousReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PreviousReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PreviousReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.ratereceived)
    public lazy var rateReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerRateReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_RateReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_RateReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.rewindreceived)
    public lazy var rewindReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerRewindReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_RewindReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_RewindReceivedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanager.shufflereceived)
    public lazy var shuffleReceived : Event<TypedEventHandler<MediaPlaybackCommandManager?, MediaPlaybackCommandManagerShuffleReceivedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ShuffleReceivedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ShuffleReceivedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerautorepeatmodereceivedeventargs)
public final class MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>?) -> MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerautorepeatmodereceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerautorepeatmodereceivedeventargs.autorepeatmode)
    public var autoRepeatMode : UWP.MediaPlaybackAutoRepeatMode {
        get { try! _default.get_AutoRepeatModeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerautorepeatmodereceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagercommandbehavior)
public final class MediaPlaybackCommandManagerCommandBehavior : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerCommandBehavior
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerCommandBehavior
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerCommandBehavior>?) -> MediaPlaybackCommandManagerCommandBehavior? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagercommandbehavior.commandmanager)
    public var commandManager : MediaPlaybackCommandManager! {
        get { try! _default.get_CommandManagerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagercommandbehavior.enablingrule)
    public var enablingRule : MediaCommandEnablingRule {
        get { try! _default.get_EnablingRuleImpl() }
        set { try! _default.put_EnablingRuleImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagercommandbehavior.isenabled)
    public var isEnabled : Bool {
        get { try! _default.get_IsEnabledImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagercommandbehavior.isenabledchanged)
    public lazy var isEnabledChanged : Event<TypedEventHandler<MediaPlaybackCommandManagerCommandBehavior?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_IsEnabledChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_IsEnabledChangedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerfastforwardreceivedeventargs)
public final class MediaPlaybackCommandManagerFastForwardReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerFastForwardReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerFastForwardReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerFastForwardReceivedEventArgs>?) -> MediaPlaybackCommandManagerFastForwardReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerfastforwardreceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerfastforwardreceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagernextreceivedeventargs)
public final class MediaPlaybackCommandManagerNextReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerNextReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerNextReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerNextReceivedEventArgs>?) -> MediaPlaybackCommandManagerNextReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagernextreceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagernextreceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpausereceivedeventargs)
public final class MediaPlaybackCommandManagerPauseReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerPauseReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerPauseReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerPauseReceivedEventArgs>?) -> MediaPlaybackCommandManagerPauseReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpausereceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpausereceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerplayreceivedeventargs)
public final class MediaPlaybackCommandManagerPlayReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerPlayReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerPlayReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerPlayReceivedEventArgs>?) -> MediaPlaybackCommandManagerPlayReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerplayreceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerplayreceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpositionreceivedeventargs)
public final class MediaPlaybackCommandManagerPositionReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerPositionReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerPositionReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerPositionReceivedEventArgs>?) -> MediaPlaybackCommandManagerPositionReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpositionreceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpositionreceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpositionreceivedeventargs.position)
    public var position : WindowsFoundation.TimeSpan {
        get { try! _default.get_PositionImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpreviousreceivedeventargs)
public final class MediaPlaybackCommandManagerPreviousReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerPreviousReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerPreviousReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerPreviousReceivedEventArgs>?) -> MediaPlaybackCommandManagerPreviousReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpreviousreceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerpreviousreceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerratereceivedeventargs)
public final class MediaPlaybackCommandManagerRateReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerRateReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerRateReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerRateReceivedEventArgs>?) -> MediaPlaybackCommandManagerRateReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerratereceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerratereceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerratereceivedeventargs.playbackrate)
    public var playbackRate : Double {
        get { try! _default.get_PlaybackRateImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerrewindreceivedeventargs)
public final class MediaPlaybackCommandManagerRewindReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerRewindReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerRewindReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerRewindReceivedEventArgs>?) -> MediaPlaybackCommandManagerRewindReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerrewindreceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagerrewindreceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagershufflereceivedeventargs)
public final class MediaPlaybackCommandManagerShuffleReceivedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackCommandManagerShuffleReceivedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerShuffleReceivedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackCommandManagerShuffleReceivedEventArgs>?) -> MediaPlaybackCommandManagerShuffleReceivedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagershufflereceivedeventargs.getdeferral)
    public func getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagershufflereceivedeventargs.handled)
    public var handled : Bool {
        get { try! _default.get_HandledImpl() }
        set { try! _default.put_HandledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackcommandmanagershufflereceivedeventargs.isshufflerequested)
    public var isShuffleRequested : Bool {
        get { try! _default.get_IsShuffleRequestedImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem)
public final class MediaPlaybackItem : WinRTClass, IMediaPlaybackSource {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackItem
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackItem
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackItem>?) -> MediaPlaybackItem? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static let _IMediaPlaybackItemFactory: __ABI_Windows_Media_Playback.IMediaPlaybackItemFactory = try! RoGetActivationFactory(HString("Windows.Media.Playback.MediaPlaybackItem"))
    public init(_ source: UWP.MediaSource!) {
        super.init(try! Self._IMediaPlaybackItemFactory.CreateImpl(source))
    }

    private static let _IMediaPlaybackItemFactory2: __ABI_Windows_Media_Playback.IMediaPlaybackItemFactory2 = try! RoGetActivationFactory(HString("Windows.Media.Playback.MediaPlaybackItem"))
    public init(_ source: UWP.MediaSource!, _ startTime: WindowsFoundation.TimeSpan) {
        super.init(try! Self._IMediaPlaybackItemFactory2.CreateWithStartTimeImpl(source, startTime))
    }

    public init(_ source: UWP.MediaSource!, _ startTime: WindowsFoundation.TimeSpan, _ durationLimit: WindowsFoundation.TimeSpan) {
        super.init(try! Self._IMediaPlaybackItemFactory2.CreateWithStartTimeAndDurationLimitImpl(source, startTime, durationLimit))
    }

    private static let _IMediaPlaybackItemStatics: __ABI_Windows_Media_Playback.IMediaPlaybackItemStatics = try! RoGetActivationFactory(HString("Windows.Media.Playback.MediaPlaybackItem"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.findfrommediasource)
    public static func findFromMediaSource(_ source: UWP.MediaSource!) -> MediaPlaybackItem! {
        return try! _IMediaPlaybackItemStatics.FindFromMediaSourceImpl(source)
    }

    private lazy var _IMediaPlaybackSource: __ABI_Windows_Media_Playback.IMediaPlaybackSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.audiotracks)
    public var audioTracks : MediaPlaybackAudioTrackList! {
        get { try! _default.get_AudioTracksImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.source)
    public var source : UWP.MediaSource! {
        get { try! _default.get_SourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.timedmetadatatracks)
    public var timedMetadataTracks : MediaPlaybackTimedMetadataTrackList! {
        get { try! _default.get_TimedMetadataTracksImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.videotracks)
    public var videoTracks : MediaPlaybackVideoTrackList! {
        get { try! _default.get_VideoTracksImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.audiotrackschanged)
    public lazy var audioTracksChanged : Event<TypedEventHandler<MediaPlaybackItem?, IVectorChangedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_AudioTracksChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_AudioTracksChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.timedmetadatatrackschanged)
    public lazy var timedMetadataTracksChanged : Event<TypedEventHandler<MediaPlaybackItem?, IVectorChangedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_TimedMetadataTracksChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_TimedMetadataTracksChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.videotrackschanged)
    public lazy var videoTracksChanged : Event<TypedEventHandler<MediaPlaybackItem?, IVectorChangedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_VideoTracksChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_VideoTracksChangedImpl($0)
       }
      )
    }()

    private lazy var _IMediaPlaybackItem2: __ABI_Windows_Media_Playback.IMediaPlaybackItem2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.getdisplayproperties)
    public func getDisplayProperties() throws -> MediaItemDisplayProperties! {
        try _IMediaPlaybackItem2.GetDisplayPropertiesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.applydisplayproperties)
    public func applyDisplayProperties(_ value: MediaItemDisplayProperties!) throws {
        try _IMediaPlaybackItem2.ApplyDisplayPropertiesImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.breakschedule)
    public var breakSchedule : MediaBreakSchedule! {
        get { try! _IMediaPlaybackItem2.get_BreakScheduleImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.canskip)
    public var canSkip : Bool {
        get { try! _IMediaPlaybackItem2.get_CanSkipImpl() }
        set { try! _IMediaPlaybackItem2.put_CanSkipImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.durationlimit)
    public var durationLimit : WindowsFoundation.TimeSpan? {
        get { try! _IMediaPlaybackItem2.get_DurationLimitImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.starttime)
    public var startTime : WindowsFoundation.TimeSpan {
        get { try! _IMediaPlaybackItem2.get_StartTimeImpl() }
    }

    private lazy var _IMediaPlaybackItem3: __ABI_Windows_Media_Playback.IMediaPlaybackItem3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.autoloadeddisplayproperties)
    public var autoLoadedDisplayProperties : AutoLoadedDisplayPropertyKind {
        get { try! _IMediaPlaybackItem3.get_AutoLoadedDisplayPropertiesImpl() }
        set { try! _IMediaPlaybackItem3.put_AutoLoadedDisplayPropertiesImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.isdisabledinplaybacklist)
    public var isDisabledInPlaybackList : Bool {
        get { try! _IMediaPlaybackItem3.get_IsDisabledInPlaybackListImpl() }
        set { try! _IMediaPlaybackItem3.put_IsDisabledInPlaybackListImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.totaldownloadprogress)
    public var totalDownloadProgress : Double {
        get { try! _IMediaPlaybackItem3.get_TotalDownloadProgressImpl() }
    }

    deinit {
        _IMediaPlaybackSource = nil
        _default = nil
        _IMediaPlaybackItem2 = nil
        _IMediaPlaybackItem3 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemerror)
public final class MediaPlaybackItemError : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackItemError
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackItemError
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackItemError>?) -> MediaPlaybackItemError? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemerror.errorcode)
    public var errorCode : MediaPlaybackItemErrorCode {
        get { try! _default.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemerror.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemfailedeventargs)
public final class MediaPlaybackItemFailedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackItemFailedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackItemFailedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackItemFailedEventArgs>?) -> MediaPlaybackItemFailedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemfailedeventargs.error)
    public var error : MediaPlaybackItemError! {
        get { try! _default.get_ErrorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemfailedeventargs.item)
    public var item : MediaPlaybackItem! {
        get { try! _default.get_ItemImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemopenedeventargs)
public final class MediaPlaybackItemOpenedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackItemOpenedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackItemOpenedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackItemOpenedEventArgs>?) -> MediaPlaybackItemOpenedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitemopenedeventargs.item)
    public var item : MediaPlaybackItem! {
        get { try! _default.get_ItemImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist)
public final class MediaPlaybackList : WinRTClass, IMediaPlaybackSource {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackList
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackList
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackList>?) -> MediaPlaybackList? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Playback.MediaPlaybackList")))
    }

    private lazy var _IMediaPlaybackSource: __ABI_Windows_Media_Playback.IMediaPlaybackSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.movenext)
    public func moveNext() throws -> MediaPlaybackItem! {
        try _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.moveprevious)
    public func movePrevious() throws -> MediaPlaybackItem! {
        try _default.MovePreviousImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.moveto)
    public func moveTo(_ itemIndex: UInt32) throws -> MediaPlaybackItem! {
        try _default.MoveToImpl(itemIndex)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.autorepeatenabled)
    public var autoRepeatEnabled : Bool {
        get { try! _default.get_AutoRepeatEnabledImpl() }
        set { try! _default.put_AutoRepeatEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.currentitem)
    public var currentItem : MediaPlaybackItem! {
        get { try! _default.get_CurrentItemImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.currentitemindex)
    public var currentItemIndex : UInt32 {
        get { try! _default.get_CurrentItemIndexImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.items)
    public var items : WindowsFoundation.AnyIObservableVector<MediaPlaybackItem?>! {
        get { try! _default.get_ItemsImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.shuffleenabled)
    public var shuffleEnabled : Bool {
        get { try! _default.get_ShuffleEnabledImpl() }
        set { try! _default.put_ShuffleEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.currentitemchanged)
    public lazy var currentItemChanged : Event<TypedEventHandler<MediaPlaybackList?, CurrentMediaPlaybackItemChangedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_CurrentItemChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_CurrentItemChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.itemfailed)
    public lazy var itemFailed : Event<TypedEventHandler<MediaPlaybackList?, MediaPlaybackItemFailedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ItemFailedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ItemFailedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.itemopened)
    public lazy var itemOpened : Event<TypedEventHandler<MediaPlaybackList?, MediaPlaybackItemOpenedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_ItemOpenedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_ItemOpenedImpl($0)
       }
      )
    }()

    private lazy var _IMediaPlaybackList2: __ABI_Windows_Media_Playback.IMediaPlaybackList2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.setshuffleditems)
    public func setShuffledItems(_ value: WindowsFoundation.AnyIIterable<MediaPlaybackItem?>!) throws {
        try _IMediaPlaybackList2.SetShuffledItemsImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.maxprefetchtime)
    public var maxPrefetchTime : WindowsFoundation.TimeSpan? {
        get { try! _IMediaPlaybackList2.get_MaxPrefetchTimeImpl() }
        set { try! _IMediaPlaybackList2.put_MaxPrefetchTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.shuffleditems)
    public var shuffledItems : WindowsFoundation.AnyIVectorView<MediaPlaybackItem?>! {
        get { try! _IMediaPlaybackList2.get_ShuffledItemsImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.startingitem)
    public var startingItem : MediaPlaybackItem! {
        get { try! _IMediaPlaybackList2.get_StartingItemImpl() }
        set { try! _IMediaPlaybackList2.put_StartingItemImpl(newValue) }
    }

    private lazy var _IMediaPlaybackList3: __ABI_Windows_Media_Playback.IMediaPlaybackList3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacklist.maxplayeditemstokeepopen)
    public var maxPlayedItemsToKeepOpen : UInt32? {
        get { try! _IMediaPlaybackList3.get_MaxPlayedItemsToKeepOpenImpl() }
        set { try! _IMediaPlaybackList3.put_MaxPlayedItemsToKeepOpenImpl(newValue) }
    }

    deinit {
        _IMediaPlaybackSource = nil
        _default = nil
        _IMediaPlaybackList2 = nil
        _IMediaPlaybackList3 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession)
public final class MediaPlaybackSession : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackSession
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackSession
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackSession>?) -> MediaPlaybackSession? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.bufferingprogress)
    public var bufferingProgress : Double {
        get { try! _default.get_BufferingProgressImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.canpause)
    public var canPause : Bool {
        get { try! _default.get_CanPauseImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.canseek)
    public var canSeek : Bool {
        get { try! _default.get_CanSeekImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.downloadprogress)
    public var downloadProgress : Double {
        get { try! _default.get_DownloadProgressImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.isprotected)
    public var isProtected : Bool {
        get { try! _default.get_IsProtectedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.mediaplayer)
    public var mediaPlayer : MediaPlayer! {
        get { try! _default.get_MediaPlayerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.naturalduration)
    public var naturalDuration : WindowsFoundation.TimeSpan {
        get { try! _default.get_NaturalDurationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.naturalvideoheight)
    public var naturalVideoHeight : UInt32 {
        get { try! _default.get_NaturalVideoHeightImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.naturalvideowidth)
    public var naturalVideoWidth : UInt32 {
        get { try! _default.get_NaturalVideoWidthImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.normalizedsourcerect)
    public var normalizedSourceRect : WindowsFoundation.Rect {
        get { try! _default.get_NormalizedSourceRectImpl() }
        set { try! _default.put_NormalizedSourceRectImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.playbackrate)
    public var playbackRate : Double {
        get { try! _default.get_PlaybackRateImpl() }
        set { try! _default.put_PlaybackRateImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.playbackstate)
    public var playbackState : MediaPlaybackState {
        get { try! _default.get_PlaybackStateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.position)
    public var position : WindowsFoundation.TimeSpan {
        get { try! _default.get_PositionImpl() }
        set { try! _default.put_PositionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.stereoscopicvideopackingmode)
    public var stereoscopicVideoPackingMode : UWP.StereoscopicVideoPackingMode {
        get { try! _default.get_StereoscopicVideoPackingModeImpl() }
        set { try! _default.put_StereoscopicVideoPackingModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.bufferingended)
    public lazy var bufferingEnded : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BufferingEndedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BufferingEndedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.bufferingprogresschanged)
    public lazy var bufferingProgressChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BufferingProgressChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BufferingProgressChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.bufferingstarted)
    public lazy var bufferingStarted : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BufferingStartedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BufferingStartedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.downloadprogresschanged)
    public lazy var downloadProgressChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_DownloadProgressChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_DownloadProgressChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.naturaldurationchanged)
    public lazy var naturalDurationChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_NaturalDurationChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_NaturalDurationChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.naturalvideosizechanged)
    public lazy var naturalVideoSizeChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_NaturalVideoSizeChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_NaturalVideoSizeChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.playbackratechanged)
    public lazy var playbackRateChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PlaybackRateChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PlaybackRateChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.playbackstatechanged)
    public lazy var playbackStateChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PlaybackStateChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PlaybackStateChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.positionchanged)
    public lazy var positionChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PositionChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PositionChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.seekcompleted)
    public lazy var seekCompleted : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_SeekCompletedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_SeekCompletedImpl($0)
       }
      )
    }()

    private lazy var _IMediaPlaybackSession2: __ABI_Windows_Media_Playback.IMediaPlaybackSession2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.getbufferedranges)
    public func getBufferedRanges() throws -> WindowsFoundation.AnyIVectorView<UWP.MediaTimeRange>! {
        try _IMediaPlaybackSession2.GetBufferedRangesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.getplayedranges)
    public func getPlayedRanges() throws -> WindowsFoundation.AnyIVectorView<UWP.MediaTimeRange>! {
        try _IMediaPlaybackSession2.GetPlayedRangesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.getseekableranges)
    public func getSeekableRanges() throws -> WindowsFoundation.AnyIVectorView<UWP.MediaTimeRange>! {
        try _IMediaPlaybackSession2.GetSeekableRangesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.issupportedplaybackraterange)
    public func isSupportedPlaybackRateRange(_ rate1: Double, _ rate2: Double) throws -> Bool {
        try _IMediaPlaybackSession2.IsSupportedPlaybackRateRangeImpl(rate1, rate2)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.ismirroring)
    public var isMirroring : Bool {
        get { try! _IMediaPlaybackSession2.get_IsMirroringImpl() }
        set { try! _IMediaPlaybackSession2.put_IsMirroringImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.sphericalvideoprojection)
    public var sphericalVideoProjection : MediaPlaybackSphericalVideoProjection! {
        get { try! _IMediaPlaybackSession2.get_SphericalVideoProjectionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.bufferedrangeschanged)
    public lazy var bufferedRangesChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlaybackSession2 else { return .init() }
          return try! this.add_BufferedRangesChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlaybackSession2.remove_BufferedRangesChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.playedrangeschanged)
    public lazy var playedRangesChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlaybackSession2 else { return .init() }
          return try! this.add_PlayedRangesChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlaybackSession2.remove_PlayedRangesChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.seekablerangeschanged)
    public lazy var seekableRangesChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlaybackSession2 else { return .init() }
          return try! this.add_SeekableRangesChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlaybackSession2.remove_SeekableRangesChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.supportedplaybackrateschanged)
    public lazy var supportedPlaybackRatesChanged : Event<TypedEventHandler<MediaPlaybackSession?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlaybackSession2 else { return .init() }
          return try! this.add_SupportedPlaybackRatesChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlaybackSession2.remove_SupportedPlaybackRatesChangedImpl($0)
       }
      )
    }()

    private lazy var _IMediaPlaybackSession3: __ABI_Windows_Media_Playback.IMediaPlaybackSession3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.getoutputdegradationpolicystate)
    public func getOutputDegradationPolicyState() throws -> MediaPlaybackSessionOutputDegradationPolicyState! {
        try _IMediaPlaybackSession3.GetOutputDegradationPolicyStateImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.playbackrotation)
    public var playbackRotation : UWP.MediaRotation {
        get { try! _IMediaPlaybackSession3.get_PlaybackRotationImpl() }
        set { try! _IMediaPlaybackSession3.put_PlaybackRotationImpl(newValue) }
    }

    deinit {
        _default = nil
        _IMediaPlaybackSession2 = nil
        _IMediaPlaybackSession3 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionoutputdegradationpolicystate)
public final class MediaPlaybackSessionOutputDegradationPolicyState : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackSessionOutputDegradationPolicyState
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackSessionOutputDegradationPolicyState
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackSessionOutputDegradationPolicyState>?) -> MediaPlaybackSessionOutputDegradationPolicyState? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionoutputdegradationpolicystate.videoconstrictionreason)
    public var videoConstrictionReason : MediaPlaybackSessionVideoConstrictionReason {
        get { try! _default.get_VideoConstrictionReasonImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection)
public final class MediaPlaybackSphericalVideoProjection : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlaybackSphericalVideoProjection
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackSphericalVideoProjection
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlaybackSphericalVideoProjection>?) -> MediaPlaybackSphericalVideoProjection? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.frameformat)
    public var frameFormat : UWP.SphericalVideoFrameFormat {
        get { try! _default.get_FrameFormatImpl() }
        set { try! _default.put_FrameFormatImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.horizontalfieldofviewindegrees)
    public var horizontalFieldOfViewInDegrees : Double {
        get { try! _default.get_HorizontalFieldOfViewInDegreesImpl() }
        set { try! _default.put_HorizontalFieldOfViewInDegreesImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.isenabled)
    public var isEnabled : Bool {
        get { try! _default.get_IsEnabledImpl() }
        set { try! _default.put_IsEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.projectionmode)
    public var projectionMode : SphericalVideoProjectionMode {
        get { try! _default.get_ProjectionModeImpl() }
        set { try! _default.put_ProjectionModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.vieworientation)
    public var viewOrientation : WindowsFoundation.Quaternion {
        get { try! _default.get_ViewOrientationImpl() }
        set { try! _default.put_ViewOrientationImpl(newValue) }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacktimedmetadatatracklist)
public final class MediaPlaybackTimedMetadataTrackList : WinRTClass, IVectorView, IIterable {
    public typealias T = UWP.TimedMetadataTrack?
    private typealias SwiftABI = UWP.IVectorViewTimedMetadataTrack
    private typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CTimedMetadataTrack>?) -> MediaPlaybackTimedMetadataTrackList? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    // MARK: Collection
    public typealias Element = T
    public var startIndex: Int { 0 }
    public var endIndex: Int { Int(size) }
    public func index(after i: Int) -> Int {
        i+1
    }

    public func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    public var count: Int { Int(size) }

    public subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacktimedmetadatatracklist.getat)
    public func getAt(_ index: UInt32) -> UWP.TimedMetadataTrack? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacktimedmetadatatracklist.indexof)
    public func indexOf(_ value: UWP.TimedMetadataTrack?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacktimedmetadatatracklist.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimedMetadataTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacktimedmetadatatracklist.first)
    public func first() -> WindowsFoundation.AnyIIterator<UWP.TimedMetadataTrack?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IMediaPlaybackTimedMetadataTrackList: __ABI_Windows_Media_Playback.IMediaPlaybackTimedMetadataTrackList! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacktimedmetadatatracklist.getpresentationmode)
    public func getPresentationMode(_ index: UInt32) throws -> TimedMetadataTrackPresentationMode {
        try _IMediaPlaybackTimedMetadataTrackList.GetPresentationModeImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacktimedmetadatatracklist.setpresentationmode)
    public func setPresentationMode(_ index: UInt32, _ value: TimedMetadataTrackPresentationMode) throws {
        try _IMediaPlaybackTimedMetadataTrackList.SetPresentationModeImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybacktimedmetadatatracklist.presentationmodechanged)
    public lazy var presentationModeChanged : Event<TypedEventHandler<MediaPlaybackTimedMetadataTrackList?, TimedMetadataPresentationModeChangedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlaybackTimedMetadataTrackList else { return .init() }
          return try! this.add_PresentationModeChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlaybackTimedMetadataTrackList.remove_PresentationModeChangedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
        _IIterable = nil
        _IMediaPlaybackTimedMetadataTrackList = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackvideotracklist)
public final class MediaPlaybackVideoTrackList : WinRTClass, IVectorView, IIterable, UWP.ISingleSelectMediaTrackList {
    public typealias T = UWP.VideoTrack?
    private typealias SwiftABI = UWP.IVectorViewVideoTrack
    private typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CMedia__CCore__CVideoTrack>?) -> MediaPlaybackVideoTrackList? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    // MARK: Collection
    public typealias Element = T
    public var startIndex: Int { 0 }
    public var endIndex: Int { Int(size) }
    public func index(after i: Int) -> Int {
        i+1
    }

    public func index(of: Element) -> Int? {
        var index: UInt32 = 0
        let result = indexOf(of, &index)
        guard result else { return nil }
        return Int(index)
    }
    public var count: Int { Int(size) }

    public subscript(position: Int) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackvideotracklist.getat)
    public func getAt(_ index: UInt32) -> UWP.VideoTrack? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackvideotracklist.indexof)
    public func indexOf(_ value: UWP.VideoTrack?, _ index: inout UInt32) -> Bool {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackvideotracklist.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableVideoTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackvideotracklist.first)
    public func first() -> WindowsFoundation.AnyIIterator<UWP.VideoTrack?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _ISingleSelectMediaTrackList: __ABI_Windows_Media_Core.ISingleSelectMediaTrackList! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackvideotracklist.selectedindex)
    public var selectedIndex : Int32 {
        get { try! _ISingleSelectMediaTrackList.get_SelectedIndexImpl() }
        set { try! _ISingleSelectMediaTrackList.put_SelectedIndexImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplaybackvideotracklist.selectedindexchanged)
    public lazy var selectedIndexChanged : Event<TypedEventHandler<ISingleSelectMediaTrackList?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._ISingleSelectMediaTrackList else { return .init() }
          return try! this.add_SelectedIndexChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._ISingleSelectMediaTrackList.remove_SelectedIndexChangedImpl($0)
       }
      )
    }()

    deinit {
        _default = nil
        _IIterable = nil
        _ISingleSelectMediaTrackList = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer)
public final class MediaPlayer : WinRTClass, WindowsFoundation.IClosable {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlayer
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlayer
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlayer>?) -> MediaPlayer? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Playback.MediaPlayer")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.play)
    public func play() throws {
        try _default.PlayImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.pause)
    public func pause() throws {
        try _default.PauseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.seturisource)
    public func setUriSource(_ value: WindowsFoundation.Uri!) throws {
        try _default.SetUriSourceImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.autoplay)
    public var autoPlay : Bool {
        get { try! _default.get_AutoPlayImpl() }
        set { try! _default.put_AutoPlayImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.bufferingprogress)
    public var bufferingProgress : Double {
        get { try! _default.get_BufferingProgressImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.canpause)
    public var canPause : Bool {
        get { try! _default.get_CanPauseImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.canseek)
    public var canSeek : Bool {
        get { try! _default.get_CanSeekImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.currentstate)
    public var currentState : MediaPlayerState {
        get { try! _default.get_CurrentStateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.isloopingenabled)
    public var isLoopingEnabled : Bool {
        get { try! _default.get_IsLoopingEnabledImpl() }
        set { try! _default.put_IsLoopingEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.ismuted)
    public var isMuted : Bool {
        get { try! _default.get_IsMutedImpl() }
        set { try! _default.put_IsMutedImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.isprotected)
    public var isProtected : Bool {
        get { try! _default.get_IsProtectedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.naturalduration)
    public var naturalDuration : WindowsFoundation.TimeSpan {
        get { try! _default.get_NaturalDurationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.playbackmediamarkers)
    public var playbackMediaMarkers : PlaybackMediaMarkerSequence! {
        get { try! _default.get_PlaybackMediaMarkersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.playbackrate)
    public var playbackRate : Double {
        get { try! _default.get_PlaybackRateImpl() }
        set { try! _default.put_PlaybackRateImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.position)
    public var position : WindowsFoundation.TimeSpan {
        get { try! _default.get_PositionImpl() }
        set { try! _default.put_PositionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.volume)
    public var volume : Double {
        get { try! _default.get_VolumeImpl() }
        set { try! _default.put_VolumeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.bufferingended)
    public lazy var bufferingEnded : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BufferingEndedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BufferingEndedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.bufferingstarted)
    public lazy var bufferingStarted : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_BufferingStartedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_BufferingStartedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.currentstatechanged)
    public lazy var currentStateChanged : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_CurrentStateChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_CurrentStateChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.mediaended)
    public lazy var mediaEnded : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_MediaEndedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_MediaEndedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.mediafailed)
    public lazy var mediaFailed : Event<TypedEventHandler<MediaPlayer?, MediaPlayerFailedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_MediaFailedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_MediaFailedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.mediaopened)
    public lazy var mediaOpened : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_MediaOpenedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_MediaOpenedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.mediaplayerratechanged)
    public lazy var mediaPlayerRateChanged : Event<TypedEventHandler<MediaPlayer?, MediaPlayerRateChangedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_MediaPlayerRateChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_MediaPlayerRateChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.playbackmediamarkerreached)
    public lazy var playbackMediaMarkerReached : Event<TypedEventHandler<MediaPlayer?, PlaybackMediaMarkerReachedEventArgs?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_PlaybackMediaMarkerReachedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_PlaybackMediaMarkerReachedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.seekcompleted)
    public lazy var seekCompleted : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_SeekCompletedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_SeekCompletedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.volumechanged)
    public lazy var volumeChanged : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._default else { return .init() }
          return try! this.add_VolumeChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._default.remove_VolumeChangedImpl($0)
       }
      )
    }()

    private lazy var _IMediaPlayerSource: __ABI_Windows_Media_Playback.IMediaPlayerSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.setfilesource)
    public func setFileSource(_ file: UWP.AnyIStorageFile!) throws {
        try _IMediaPlayerSource.SetFileSourceImpl(file)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.setstreamsource)
    public func setStreamSource(_ stream: UWP.AnyIRandomAccessStream!) throws {
        try _IMediaPlayerSource.SetStreamSourceImpl(stream)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.setmediasource)
    public func setMediaSource(_ source: UWP.AnyIMediaSource!) throws {
        try _IMediaPlayerSource.SetMediaSourceImpl(source)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.protectionmanager)
    public var protectionManager : UWP.MediaProtectionManager! {
        get { try! _IMediaPlayerSource.get_ProtectionManagerImpl() }
        set { try! _IMediaPlayerSource.put_ProtectionManagerImpl(newValue) }
    }

    private lazy var _IMediaPlayerSource2: __ABI_Windows_Media_Playback.IMediaPlayerSource2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.source)
    public var source : AnyIMediaPlaybackSource! {
        get { try! _IMediaPlayerSource2.get_SourceImpl() }
        set { try! _IMediaPlayerSource2.put_SourceImpl(newValue) }
    }

    private lazy var _IMediaPlayer2: __ABI_Windows_Media_Playback.IMediaPlayer2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.audiocategory)
    public var audioCategory : MediaPlayerAudioCategory {
        get { try! _IMediaPlayer2.get_AudioCategoryImpl() }
        set { try! _IMediaPlayer2.put_AudioCategoryImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.audiodevicetype)
    public var audioDeviceType : MediaPlayerAudioDeviceType {
        get { try! _IMediaPlayer2.get_AudioDeviceTypeImpl() }
        set { try! _IMediaPlayer2.put_AudioDeviceTypeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.systemmediatransportcontrols)
    public var systemMediaTransportControls : UWP.SystemMediaTransportControls! {
        get { try! _IMediaPlayer2.get_SystemMediaTransportControlsImpl() }
    }

    private lazy var _IMediaPlayerEffects: __ABI_Windows_Media_Playback.IMediaPlayerEffects! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.addaudioeffect)
    public func addAudioEffect(_ activatableClassId: String, _ effectOptional: Bool, _ configuration: WindowsFoundation.AnyIPropertySet!) throws {
        try _IMediaPlayerEffects.AddAudioEffectImpl(activatableClassId, effectOptional, configuration)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.removealleffects)
    public func removeAllEffects() throws {
        try _IMediaPlayerEffects.RemoveAllEffectsImpl()
    }

    private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.close)
    public func close() throws {
        try _IClosable.CloseImpl()
    }

    private lazy var _IMediaPlayer3: __ABI_Windows_Media_Playback.IMediaPlayer3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.stepforwardoneframe)
    public func stepForwardOneFrame() throws {
        try _IMediaPlayer3.StepForwardOneFrameImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.stepbackwardoneframe)
    public func stepBackwardOneFrame() throws {
        try _IMediaPlayer3.StepBackwardOneFrameImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.getascastingsource)
    public func getAsCastingSource() throws -> UWP.CastingSource! {
        try _IMediaPlayer3.GetAsCastingSourceImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.audiobalance)
    public var audioBalance : Double {
        get { try! _IMediaPlayer3.get_AudioBalanceImpl() }
        set { try! _IMediaPlayer3.put_AudioBalanceImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.audiodevice)
    public var audioDevice : UWP.DeviceInformation! {
        get { try! _IMediaPlayer3.get_AudioDeviceImpl() }
        set { try! _IMediaPlayer3.put_AudioDeviceImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.breakmanager)
    public var breakManager : MediaBreakManager! {
        get { try! _IMediaPlayer3.get_BreakManagerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.commandmanager)
    public var commandManager : MediaPlaybackCommandManager! {
        get { try! _IMediaPlayer3.get_CommandManagerImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.playbacksession)
    public var playbackSession : MediaPlaybackSession! {
        get { try! _IMediaPlayer3.get_PlaybackSessionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.realtimeplayback)
    public var realTimePlayback : Bool {
        get { try! _IMediaPlayer3.get_RealTimePlaybackImpl() }
        set { try! _IMediaPlayer3.put_RealTimePlaybackImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.stereoscopicvideorendermode)
    public var stereoscopicVideoRenderMode : StereoscopicVideoRenderMode {
        get { try! _IMediaPlayer3.get_StereoscopicVideoRenderModeImpl() }
        set { try! _IMediaPlayer3.put_StereoscopicVideoRenderModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.timelinecontroller)
    public var timelineController : UWP.MediaTimelineController! {
        get { try! _IMediaPlayer3.get_TimelineControllerImpl() }
        set { try! _IMediaPlayer3.put_TimelineControllerImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.timelinecontrollerpositionoffset)
    public var timelineControllerPositionOffset : WindowsFoundation.TimeSpan {
        get { try! _IMediaPlayer3.get_TimelineControllerPositionOffsetImpl() }
        set { try! _IMediaPlayer3.put_TimelineControllerPositionOffsetImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.ismutedchanged)
    public lazy var isMutedChanged : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlayer3 else { return .init() }
          return try! this.add_IsMutedChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlayer3.remove_IsMutedChangedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.sourcechanged)
    public lazy var sourceChanged : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlayer3 else { return .init() }
          return try! this.add_SourceChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlayer3.remove_SourceChangedImpl($0)
       }
      )
    }()

    private lazy var _IMediaPlayer4: __ABI_Windows_Media_Playback.IMediaPlayer4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.setsurfacesize)
    public func setSurfaceSize(_ size: WindowsFoundation.Size) throws {
        try _IMediaPlayer4.SetSurfaceSizeImpl(size)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.getsurface)
    public func getSurface(_ compositor: UWP.Compositor!) throws -> MediaPlayerSurface! {
        try _IMediaPlayer4.GetSurfaceImpl(compositor)
    }

    private lazy var _IMediaPlayerEffects2: __ABI_Windows_Media_Playback.IMediaPlayerEffects2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.addvideoeffect)
    public func addVideoEffect(_ activatableClassId: String, _ effectOptional: Bool, _ effectConfiguration: WindowsFoundation.AnyIPropertySet!) throws {
        try _IMediaPlayerEffects2.AddVideoEffectImpl(activatableClassId, effectOptional, effectConfiguration)
    }

    private lazy var _IMediaPlayer5: __ABI_Windows_Media_Playback.IMediaPlayer5! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.copyframetovideosurface)
    public func copyFrameToVideoSurface(_ destination: UWP.AnyIDirect3DSurface!) throws {
        try _IMediaPlayer5.CopyFrameToVideoSurfaceImpl(destination)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.copyframetovideosurface)
    public func copyFrameToVideoSurface(_ destination: UWP.AnyIDirect3DSurface!, _ targetRectangle: WindowsFoundation.Rect) throws {
        try _IMediaPlayer5.CopyFrameToVideoSurfaceWithTargetRectangleImpl(destination, targetRectangle)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.copyframetostereoscopicvideosurfaces)
    public func copyFrameToStereoscopicVideoSurfaces(_ destinationLeftEye: UWP.AnyIDirect3DSurface!, _ destinationRightEye: UWP.AnyIDirect3DSurface!) throws {
        try _IMediaPlayer5.CopyFrameToStereoscopicVideoSurfacesImpl(destinationLeftEye, destinationRightEye)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.isvideoframeserverenabled)
    public var isVideoFrameServerEnabled : Bool {
        get { try! _IMediaPlayer5.get_IsVideoFrameServerEnabledImpl() }
        set { try! _IMediaPlayer5.put_IsVideoFrameServerEnabledImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.videoframeavailable)
    public lazy var videoFrameAvailable : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlayer5 else { return .init() }
          return try! this.add_VideoFrameAvailableImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlayer5.remove_VideoFrameAvailableImpl($0)
       }
      )
    }()

    private lazy var _IMediaPlayer6: __ABI_Windows_Media_Playback.IMediaPlayer6! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.rendersubtitlestosurface)
    public func renderSubtitlesToSurface(_ destination: UWP.AnyIDirect3DSurface!) throws -> Bool {
        try _IMediaPlayer6.RenderSubtitlesToSurfaceImpl(destination)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.rendersubtitlestosurface)
    public func renderSubtitlesToSurface(_ destination: UWP.AnyIDirect3DSurface!, _ targetRectangle: WindowsFoundation.Rect) throws -> Bool {
        try _IMediaPlayer6.RenderSubtitlesToSurfaceWithTargetRectangleImpl(destination, targetRectangle)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.subtitleframechanged)
    public lazy var subtitleFrameChanged : Event<TypedEventHandler<MediaPlayer?, Any?>> = {
      .init(
        add: { [weak self] in
          guard let this = self?._IMediaPlayer6 else { return .init() }
          return try! this.add_SubtitleFrameChangedImpl($0)
        },
        remove: { [weak self] in
         try? self?._IMediaPlayer6.remove_SubtitleFrameChangedImpl($0)
       }
      )
    }()

    private lazy var _IMediaPlayer7: __ABI_Windows_Media_Playback.IMediaPlayer7! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayer.audiostatemonitor)
    public var audioStateMonitor : UWP.AudioStateMonitor! {
        get { try! _IMediaPlayer7.get_AudioStateMonitorImpl() }
    }

    deinit {
        _default = nil
        _IMediaPlayerSource = nil
        _IMediaPlayerSource2 = nil
        _IMediaPlayer2 = nil
        _IMediaPlayerEffects = nil
        _IClosable = nil
        _IMediaPlayer3 = nil
        _IMediaPlayer4 = nil
        _IMediaPlayerEffects2 = nil
        _IMediaPlayer5 = nil
        _IMediaPlayer6 = nil
        _IMediaPlayer7 = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayerfailedeventargs)
public final class MediaPlayerFailedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlayerFailedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlayerFailedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlayerFailedEventArgs>?) -> MediaPlayerFailedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayerfailedeventargs.error)
    public var error : MediaPlayerError {
        get { try! _default.get_ErrorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayerfailedeventargs.errormessage)
    public var errorMessage : String {
        get { try! _default.get_ErrorMessageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayerfailedeventargs.extendederrorcode)
    public var extendedErrorCode : HRESULT {
        get { try! _default.get_ExtendedErrorCodeImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayerratechangedeventargs)
public final class MediaPlayerRateChangedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlayerRateChangedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlayerRateChangedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlayerRateChangedEventArgs>?) -> MediaPlayerRateChangedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayerratechangedeventargs.newrate)
    public var newRate : Double {
        get { try! _default.get_NewRateImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayersurface)
public final class MediaPlayerSurface : WinRTClass, WindowsFoundation.IClosable {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IMediaPlayerSurface
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIMediaPlayerSurface
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIMediaPlayerSurface>?) -> MediaPlayerSurface? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayersurface.compositionsurface)
    public var compositionSurface : UWP.AnyICompositionSurface! {
        get { try! _default.get_CompositionSurfaceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayersurface.compositor)
    public var compositor : UWP.Compositor! {
        get { try! _default.get_CompositorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayersurface.mediaplayer)
    public var mediaPlayer : MediaPlayer! {
        get { try! _default.get_MediaPlayerImpl() }
    }

    private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.mediaplayersurface.close)
    public func close() throws {
        try _IClosable.CloseImpl()
    }

    deinit {
        _default = nil
        _IClosable = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarker)
public final class PlaybackMediaMarker : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IPlaybackMediaMarker
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIPlaybackMediaMarker
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIPlaybackMediaMarker>?) -> PlaybackMediaMarker? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static let _IPlaybackMediaMarkerFactory: __ABI_Windows_Media_Playback.IPlaybackMediaMarkerFactory = try! RoGetActivationFactory(HString("Windows.Media.Playback.PlaybackMediaMarker"))
    public init(_ value: WindowsFoundation.TimeSpan) {
        super.init(try! Self._IPlaybackMediaMarkerFactory.CreateFromTimeImpl(value))
    }

    public init(_ value: WindowsFoundation.TimeSpan, _ mediaMarketType: String, _ text: String) {
        super.init(try! Self._IPlaybackMediaMarkerFactory.CreateImpl(value, mediaMarketType, text))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarker.mediamarkertype)
    public var mediaMarkerType : String {
        get { try! _default.get_MediaMarkerTypeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarker.text)
    public var text : String {
        get { try! _default.get_TextImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarker.time)
    public var time : WindowsFoundation.TimeSpan {
        get { try! _default.get_TimeImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarkerreachedeventargs)
public final class PlaybackMediaMarkerReachedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IPlaybackMediaMarkerReachedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIPlaybackMediaMarkerReachedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIPlaybackMediaMarkerReachedEventArgs>?) -> PlaybackMediaMarkerReachedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarkerreachedeventargs.playbackmediamarker)
    public var playbackMediaMarker : PlaybackMediaMarker! {
        get { try! _default.get_PlaybackMediaMarkerImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarkersequence)
public final class PlaybackMediaMarkerSequence : WinRTClass, IIterable {
    public typealias T = PlaybackMediaMarker?
    private typealias SwiftABI = __ABI_Windows_Media_Playback.IPlaybackMediaMarkerSequence
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CIPlaybackMediaMarkerSequence
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CIPlaybackMediaMarkerSequence>?) -> PlaybackMediaMarkerSequence? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IIterable: IIterablePlaybackMediaMarker! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarkersequence.first)
    public func first() -> WindowsFoundation.AnyIIterator<PlaybackMediaMarker?>? {
        try! _IIterable.FirstImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarkersequence.insert)
    public func insert(_ value: PlaybackMediaMarker!) throws {
        try _default.InsertImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarkersequence.clear)
    public func clear() throws {
        try _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.playbackmediamarkersequence.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    deinit {
        _IIterable = nil
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.timedmetadatapresentationmodechangedeventargs)
public final class TimedMetadataPresentationModeChangedEventArgs : WinRTClass {
    private typealias SwiftABI = __ABI_Windows_Media_Playback.ITimedMetadataPresentationModeChangedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CPlayback_CITimedMetadataPresentationModeChangedEventArgs
    private lazy var _default: SwiftABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public func _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.self == CABI.self {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static func from(abi: ComPtr<__x_ABI_CWindows_CMedia_CPlayback_CITimedMetadataPresentationModeChangedEventArgs>?) -> TimedMetadataPresentationModeChangedEventArgs? {
        guard let abi = abi else { return nil }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.timedmetadatapresentationmodechangedeventargs.newpresentationmode)
    public var newPresentationMode : TimedMetadataTrackPresentationMode {
        get { try! _default.get_NewPresentationModeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.timedmetadatapresentationmodechangedeventargs.oldpresentationmode)
    public var oldPresentationMode : TimedMetadataTrackPresentationMode {
        get { try! _default.get_OldPresentationModeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.timedmetadatapresentationmodechangedeventargs.track)
    public var track : UWP.TimedMetadataTrack! {
        get { try! _default.get_TrackImpl() }
    }

    deinit {
        _default = nil
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.playback.imediaplaybacksource)
public protocol IMediaPlaybackSource : WinRTInterface {
}

extension IMediaPlaybackSource {
    public func queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Playback.IMediaPlaybackSourceWrapper.IID:
                let wrapper = __ABI_Windows_Media_Playback.IMediaPlaybackSourceWrapper(self)
                return wrapper!.queryInterface(iid)
            default: return nil
        }
    }
}
public typealias AnyIMediaPlaybackSource = any IMediaPlaybackSource

extension UWP.AutoLoadedDisplayPropertyKind {
    public static var none : UWP.AutoLoadedDisplayPropertyKind {
        __x_ABI_CWindows_CMedia_CPlayback_CAutoLoadedDisplayPropertyKind_None
    }
    public static var musicOrVideo : UWP.AutoLoadedDisplayPropertyKind {
        __x_ABI_CWindows_CMedia_CPlayback_CAutoLoadedDisplayPropertyKind_MusicOrVideo
    }
    public static var music : UWP.AutoLoadedDisplayPropertyKind {
        __x_ABI_CWindows_CMedia_CPlayback_CAutoLoadedDisplayPropertyKind_Music
    }
    public static var video : UWP.AutoLoadedDisplayPropertyKind {
        __x_ABI_CWindows_CMedia_CPlayback_CAutoLoadedDisplayPropertyKind_Video
    }
}
extension UWP.AutoLoadedDisplayPropertyKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaBreakInsertionMethod {
    public static var interrupt : UWP.MediaBreakInsertionMethod {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaBreakInsertionMethod_Interrupt
    }
    public static var replace : UWP.MediaBreakInsertionMethod {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaBreakInsertionMethod_Replace
    }
}
extension UWP.MediaBreakInsertionMethod: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaCommandEnablingRule {
    public static var auto : UWP.MediaCommandEnablingRule {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaCommandEnablingRule_Auto
    }
    public static var always : UWP.MediaCommandEnablingRule {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaCommandEnablingRule_Always
    }
    public static var never : UWP.MediaCommandEnablingRule {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaCommandEnablingRule_Never
    }
}
extension UWP.MediaCommandEnablingRule: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaPlaybackItemChangedReason {
    public static var initialItem : UWP.MediaPlaybackItemChangedReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemChangedReason_InitialItem
    }
    public static var endOfStream : UWP.MediaPlaybackItemChangedReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemChangedReason_EndOfStream
    }
    public static var error : UWP.MediaPlaybackItemChangedReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemChangedReason_Error
    }
    public static var appRequested : UWP.MediaPlaybackItemChangedReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemChangedReason_AppRequested
    }
}
extension UWP.MediaPlaybackItemChangedReason: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaPlaybackItemErrorCode {
    public static var none : UWP.MediaPlaybackItemErrorCode {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemErrorCode_None
    }
    public static var aborted : UWP.MediaPlaybackItemErrorCode {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemErrorCode_Aborted
    }
    public static var networkError : UWP.MediaPlaybackItemErrorCode {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemErrorCode_NetworkError
    }
    public static var decodeError : UWP.MediaPlaybackItemErrorCode {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemErrorCode_DecodeError
    }
    public static var sourceNotSupportedError : UWP.MediaPlaybackItemErrorCode {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemErrorCode_SourceNotSupportedError
    }
    public static var encryptionError : UWP.MediaPlaybackItemErrorCode {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackItemErrorCode_EncryptionError
    }
}
extension UWP.MediaPlaybackItemErrorCode: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaPlaybackSessionVideoConstrictionReason {
    public static var none : UWP.MediaPlaybackSessionVideoConstrictionReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackSessionVideoConstrictionReason_None
    }
    public static var virtualMachine : UWP.MediaPlaybackSessionVideoConstrictionReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackSessionVideoConstrictionReason_VirtualMachine
    }
    public static var unsupportedDisplayAdapter : UWP.MediaPlaybackSessionVideoConstrictionReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackSessionVideoConstrictionReason_UnsupportedDisplayAdapter
    }
    public static var unsignedDriver : UWP.MediaPlaybackSessionVideoConstrictionReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackSessionVideoConstrictionReason_UnsignedDriver
    }
    public static var frameServerEnabled : UWP.MediaPlaybackSessionVideoConstrictionReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackSessionVideoConstrictionReason_FrameServerEnabled
    }
    public static var outputProtectionFailed : UWP.MediaPlaybackSessionVideoConstrictionReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackSessionVideoConstrictionReason_OutputProtectionFailed
    }
    public static var unknown : UWP.MediaPlaybackSessionVideoConstrictionReason {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackSessionVideoConstrictionReason_Unknown
    }
}
extension UWP.MediaPlaybackSessionVideoConstrictionReason: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaPlaybackState {
    public static var none : UWP.MediaPlaybackState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackState_None
    }
    public static var opening : UWP.MediaPlaybackState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackState_Opening
    }
    public static var buffering : UWP.MediaPlaybackState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackState_Buffering
    }
    public static var playing : UWP.MediaPlaybackState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackState_Playing
    }
    public static var paused : UWP.MediaPlaybackState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlaybackState_Paused
    }
}
extension UWP.MediaPlaybackState: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaPlayerAudioCategory {
    public static var other : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_Other
    }
    public static var communications : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_Communications
    }
    public static var alerts : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_Alerts
    }
    public static var soundEffects : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_SoundEffects
    }
    public static var gameEffects : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_GameEffects
    }
    public static var gameMedia : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_GameMedia
    }
    public static var gameChat : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_GameChat
    }
    public static var speech : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_Speech
    }
    public static var movie : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_Movie
    }
    public static var media : UWP.MediaPlayerAudioCategory {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioCategory_Media
    }
}
extension UWP.MediaPlayerAudioCategory: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaPlayerAudioDeviceType {
    public static var console : UWP.MediaPlayerAudioDeviceType {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioDeviceType_Console
    }
    public static var multimedia : UWP.MediaPlayerAudioDeviceType {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioDeviceType_Multimedia
    }
    public static var communications : UWP.MediaPlayerAudioDeviceType {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerAudioDeviceType_Communications
    }
}
extension UWP.MediaPlayerAudioDeviceType: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaPlayerError {
    public static var unknown : UWP.MediaPlayerError {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerError_Unknown
    }
    public static var aborted : UWP.MediaPlayerError {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerError_Aborted
    }
    public static var networkError : UWP.MediaPlayerError {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerError_NetworkError
    }
    public static var decodingError : UWP.MediaPlayerError {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerError_DecodingError
    }
    public static var sourceNotSupported : UWP.MediaPlayerError {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerError_SourceNotSupported
    }
}
extension UWP.MediaPlayerError: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaPlayerState {
    public static var closed : UWP.MediaPlayerState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerState_Closed
    }
    public static var opening : UWP.MediaPlayerState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerState_Opening
    }
    public static var buffering : UWP.MediaPlayerState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerState_Buffering
    }
    public static var playing : UWP.MediaPlayerState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerState_Playing
    }
    public static var paused : UWP.MediaPlayerState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerState_Paused
    }
    public static var stopped : UWP.MediaPlayerState {
        __x_ABI_CWindows_CMedia_CPlayback_CMediaPlayerState_Stopped
    }
}
extension UWP.MediaPlayerState: @retroactive Hashable, @retroactive Codable {}

extension UWP.SphericalVideoProjectionMode {
    public static var spherical : UWP.SphericalVideoProjectionMode {
        __x_ABI_CWindows_CMedia_CPlayback_CSphericalVideoProjectionMode_Spherical
    }
    public static var flat : UWP.SphericalVideoProjectionMode {
        __x_ABI_CWindows_CMedia_CPlayback_CSphericalVideoProjectionMode_Flat
    }
}
extension UWP.SphericalVideoProjectionMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.StereoscopicVideoRenderMode {
    public static var mono : UWP.StereoscopicVideoRenderMode {
        __x_ABI_CWindows_CMedia_CPlayback_CStereoscopicVideoRenderMode_Mono
    }
    public static var stereo : UWP.StereoscopicVideoRenderMode {
        __x_ABI_CWindows_CMedia_CPlayback_CStereoscopicVideoRenderMode_Stereo
    }
}
extension UWP.StereoscopicVideoRenderMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedMetadataTrackPresentationMode {
    public static var disabled : UWP.TimedMetadataTrackPresentationMode {
        __x_ABI_CWindows_CMedia_CPlayback_CTimedMetadataTrackPresentationMode_Disabled
    }
    public static var hidden : UWP.TimedMetadataTrackPresentationMode {
        __x_ABI_CWindows_CMedia_CPlayback_CTimedMetadataTrackPresentationMode_Hidden
    }
    public static var applicationPresented : UWP.TimedMetadataTrackPresentationMode {
        __x_ABI_CWindows_CMedia_CPlayback_CTimedMetadataTrackPresentationMode_ApplicationPresented
    }
    public static var platformPresented : UWP.TimedMetadataTrackPresentationMode {
        __x_ABI_CWindows_CMedia_CPlayback_CTimedMetadataTrackPresentationMode_PlatformPresented
    }
}
extension UWP.TimedMetadataTrackPresentationMode: @retroactive Hashable, @retroactive Codable {}

